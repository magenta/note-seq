<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.sequences_lib_test API documentation</title>
<meta name="description" content="Tests for sequences_lib." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.sequences_lib_test</code></h1>
</header>
<section id="section-intro">
<p>Tests for sequences_lib.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Tests for sequences_lib.&#34;&#34;&#34;

import copy

from absl.testing import absltest
from note_seq import constants
from note_seq import sequences_lib
from note_seq import testing_lib
from note_seq.protobuf import music_pb2
import numpy as np

CHORD_SYMBOL = music_pb2.NoteSequence.TextAnnotation.CHORD_SYMBOL
DEFAULT_FRAMES_PER_SECOND = 16000.0 / 512
MIDI_PITCHES = constants.MAX_MIDI_PITCH - constants.MIN_MIDI_PITCH + 1


class SequencesLibTest(testing_lib.ProtoTestCase):

  def testTransposeNoteSequence(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    sequence.text_annotations.add(
        time=1, annotation_type=CHORD_SYMBOL, text=&#39;N.C.&#39;)
    sequence.text_annotations.add(
        time=2, annotation_type=CHORD_SYMBOL, text=&#39;E7&#39;)
    sequence.key_signatures.add(
        time=0, key=music_pb2.NoteSequence.KeySignature.E,
        mode=music_pb2.NoteSequence.KeySignature.MIXOLYDIAN)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(13, 100, 0.01, 10.0), (12, 55, 0.22, 0.50), (41, 45, 2.50, 3.50),
         (56, 120, 4.0, 4.01), (53, 99, 4.75, 5.0)])
    expected_sequence.text_annotations.add(
        time=1, annotation_type=CHORD_SYMBOL, text=&#39;N.C.&#39;)
    expected_sequence.text_annotations.add(
        time=2, annotation_type=CHORD_SYMBOL, text=&#39;F7&#39;)
    expected_sequence.key_signatures.add(
        time=0, key=music_pb2.NoteSequence.KeySignature.F,
        mode=music_pb2.NoteSequence.KeySignature.MIXOLYDIAN)

    transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
        sequence, 1)
    self.assertProtoEquals(expected_sequence, transposed_sequence)
    self.assertEqual(delete_count, 0)

  def testTransposeNoteSequenceOutOfRange(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(35, 100, 0.01, 10.0), (36, 55, 0.22, 0.50), (37, 45, 2.50, 3.50),
         (38, 120, 4.0, 4.01), (39, 99, 4.75, 5.0)])

    expected_sequence_1 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence_1, 0,
        [(39, 100, 0.01, 10.0), (40, 55, 0.22, 0.50)])

    expected_sequence_2 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence_2, 0,
        [(30, 120, 4.0, 4.01), (31, 99, 4.75, 5.0)])

    sequence_copy = copy.copy(sequence)
    transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
        sequence_copy, 4, 30, 40)
    self.assertProtoEquals(expected_sequence_1, transposed_sequence)
    self.assertEqual(delete_count, 3)

    sequence_copy = copy.copy(sequence)
    transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
        sequence_copy, -8, 30, 40)
    self.assertProtoEquals(expected_sequence_2, transposed_sequence)
    self.assertEqual(delete_count, 3)

  def testClampTranspose(self):
    clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
        5, 20, 60, 10, 70)
    self.assertEqual(clamped, 5)

    clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
        15, 20, 60, 10, 65)
    self.assertEqual(clamped, 5)

    clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
        -16, 20, 60, 10, 70)
    self.assertEqual(clamped, -10)

  def testAugmentNoteSequenceDeleteFalse(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=2,
        max_stretch_factor=2,
        min_transpose=-15,
        max_transpose=-10,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=False)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(10, 100, 0.02, 20.0), (11, 55, 0.44, 1.0),
                               (38, 45, 5., 7.), (53, 120, 8.0, 8.02),
                               (50, 99, 9.5, 10.0)])
    expected_sequence.tempos[0].qpm = 30.

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testAugmentNoteSequenceDeleteTrue(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=2,
        max_stretch_factor=2,
        min_transpose=-15,
        max_transpose=-15,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=True)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(25, 45, 5., 7.), (40, 120, 8.0, 8.02),
                               (37, 99, 9.5, 10.0)])
    expected_sequence.tempos[0].qpm = 30.

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testAugmentNoteSequenceNoStretch(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=1,
        max_stretch_factor=1.,
        min_transpose=-15,
        max_transpose=-15,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=True)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(25, 45, 2.5, 3.50), (40, 120, 4.0, 4.01),
                               (37, 99, 4.75, 5.0)])

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testAugmentNoteSequenceNoTranspose(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=2,
        max_stretch_factor=2.,
        min_transpose=0,
        max_transpose=0,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=True)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(12, 100, 0.02, 20.0), (13, 55, 0.44, 1.0),
                               (40, 45, 5., 7.), (55, 120, 8.0, 8.02),
                               (52, 99, 9.5, 10.0)])
    expected_sequence.tempos[0].qpm = 30.

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testTrimNoteSequence(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    expected_subsequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_subsequence, 0,
        [(40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01)])
    expected_subsequence.total_time = 4.75

    subsequence = sequences_lib.trim_note_sequence(sequence, 2.5, 4.75)
    self.assertProtoEquals(expected_subsequence, subsequence)

  def testExtractSubsequence(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 1, [(2.0, 64, 127)])
    expected_subsequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_subsequence, 0,
        [(40, 45, 0.0, 1.0), (55, 120, 1.5, 1.51)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 0.5)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 64, 0), (1.5, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 1, [(0.0, 64, 127)])
    expected_subsequence.total_time = 1.51
    expected_subsequence.subsequence_info.start_time_offset = 2.5
    expected_subsequence.subsequence_info.end_time_offset = 5.99

    subsequence = sequences_lib.extract_subsequence(sequence, 2.5, 4.75)
    subsequence.control_changes.sort(
        key=lambda cc: (cc.instrument, cc.time))
    self.assertProtoEquals(expected_subsequence, subsequence)

  def testExtractSubsequencePastEnd(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 18.0)])

    with self.assertRaises(ValueError):
      sequences_lib.extract_subsequence(sequence, 15.0, 16.0)

  def testExtractSubsequencePedalEvents(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(60, 80, 2.5, 5.0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 1, [(2.0, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 66, 0), (2.0, 66, 127), (4.0, 66, 0), (5.0, 66, 127)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 67, 10), (2.0, 67, 20), (4.0, 67, 30), (5.0, 67, 40)])
    expected_subsequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_subsequence, 0, [(60, 80, 0, 2.25)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 64, 0), (1.5, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 1, [(0.0, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 66, 127), (1.5, 66, 0)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 67, 20), (1.5, 67, 30)])
    expected_subsequence.control_changes.sort(
        key=lambda cc: (cc.instrument, cc.control_number, cc.time))
    expected_subsequence.total_time = 2.25
    expected_subsequence.subsequence_info.start_time_offset = 2.5
    expected_subsequence.subsequence_info.end_time_offset = .25

    subsequence = sequences_lib.extract_subsequence(sequence, 2.5, 4.75)
    subsequence.control_changes.sort(
        key=lambda cc: (cc.instrument, cc.control_number, cc.time))
    self.assertProtoEquals(expected_subsequence, subsequence)

  def testSplitNoteSequenceWithHopSize(self):
    # Tests splitting a NoteSequence at regular hop size, truncating notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0), (&#39;F&#39;, 4.0)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0)])
    expected_subsequence_1.total_time = 3.0
    expected_subsequence_1.subsequence_info.end_time_offset = 5.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(55, 120, 1.0, 1.01), (52, 99, 1.75, 2.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 1.0)])
    expected_subsequence_2.total_time = 2.0
    expected_subsequence_2.subsequence_info.start_time_offset = 3.0
    expected_subsequence_2.subsequence_info.end_time_offset = 3.0

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_chords_to_sequence(
        expected_subsequence_3, [(&#39;F&#39;, 0.0)])
    expected_subsequence_3.total_time = 0.0
    expected_subsequence_3.subsequence_info.start_time_offset = 6.0
    expected_subsequence_3.subsequence_info.end_time_offset = 2.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=3.0)
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceAtTimes(self):
    # Tests splitting a NoteSequence at specified times, truncating notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0), (&#39;F&#39;, 4.0)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0)])
    expected_subsequence_1.total_time = 3.0
    expected_subsequence_1.subsequence_info.end_time_offset = 5.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;G7&#39;, 0.0)])
    expected_subsequence_2.total_time = 0.0
    expected_subsequence_2.subsequence_info.start_time_offset = 3.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.0

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_3, [(&#39;F&#39;, 0.0)])
    expected_subsequence_3.total_time = 1.0
    expected_subsequence_3.subsequence_info.start_time_offset = 4.0
    expected_subsequence_3.subsequence_info.end_time_offset = 3.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=[3.0, 4.0])
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceSkipSplitsInsideNotes(self):
    # Tests splitting a NoteSequence at regular hop size, skipping splits that
    # would have occurred inside a note.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.5)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 3.0)])
    expected_subsequence_1.total_time = 3.50
    expected_subsequence_1.subsequence_info.end_time_offset = 1.5

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.5)])
    expected_subsequence_2.total_time = 1.0
    expected_subsequence_2.subsequence_info.start_time_offset = 4.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=2.0, skip_splits_inside_notes=True)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testSplitNoteSequenceNoTimeChanges(self):
    # Tests splitting a NoteSequence on time changes for a NoteSequence that has
    # no time changes (time signature and tempo changes).
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence = music_pb2.NoteSequence()
    expected_subsequence.CopyFrom(sequence)
    expected_subsequence.subsequence_info.start_time_offset = 0.0
    expected_subsequence.subsequence_info.end_time_offset = 0.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 1)
    self.assertProtoEquals(expected_subsequence, subsequences[0])

  def testSplitNoteSequenceDuplicateTimeChanges(self):
    # Tests splitting a NoteSequence on time changes for a NoteSequence that has
    # duplicate time changes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence = music_pb2.NoteSequence()
    expected_subsequence.CopyFrom(sequence)
    expected_subsequence.subsequence_info.start_time_offset = 0.0
    expected_subsequence.subsequence_info.end_time_offset = 0.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 1)
    self.assertProtoEquals(expected_subsequence, subsequences[0])

  def testSplitNoteSequenceCoincidentTimeChanges(self):
    # Tests splitting a NoteSequence on time changes for a NoteSequence that has
    # two time changes occurring simultaneously.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}
        tempos: {
          time: 2.0
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 2.0), (11, 55, 0.22, 0.50)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.5)])
    expected_subsequence_1.total_time = 2.0
    expected_subsequence_1.subsequence_info.end_time_offset = 8.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(40, 45, 0.50, 1.50), (55, 120, 2.0, 2.01), (52, 99, 2.75, 3.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 1.0), (&#39;F&#39;, 2.8)])
    expected_subsequence_2.total_time = 3.0
    expected_subsequence_2.subsequence_info.start_time_offset = 2.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes(self):
    # Tests splitting a NoteSequence on time changes skipping splits that occur
    # inside notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}
        tempos: {
          time: 4.25
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0)])
    expected_subsequence_1.total_time = 4.01
    expected_subsequence_1.subsequence_info.end_time_offset = 0.99

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0, [(52, 99, 0.5, 0.75)])
    testing_lib.add_chords_to_sequence(expected_subsequence_2, [
        (&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.55)])
    expected_subsequence_2.total_time = 0.75
    expected_subsequence_2.subsequence_info.start_time_offset = 4.25

    subsequences = sequences_lib.split_note_sequence_on_time_changes(
        sequence, skip_splits_inside_notes=True)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testSplitNoteSequenceMultipleTimeChanges(self):
    # Tests splitting a NoteSequence on time changes, truncating notes on splits
    # that occur inside notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}
        tempos: {
          time: 4.25
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 2.0), (11, 55, 0.22, 0.50)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.5)])
    expected_subsequence_1.total_time = 2.0
    expected_subsequence_1.subsequence_info.end_time_offset = 8.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(40, 45, 0.50, 1.50), (55, 120, 2.0, 2.01)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 1.0)])
    expected_subsequence_2.total_time = 2.01
    expected_subsequence_2.subsequence_info.start_time_offset = 2.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.99

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(52, 99, 0.5, 0.75)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_3, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.55)])
    expected_subsequence_3.total_time = 0.75
    expected_subsequence_3.subsequence_info.start_time_offset = 4.25
    expected_subsequence_3.subsequence_info.end_time_offset = 5.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceWithStatelessEvents(self):
    # Tests splitting a NoteSequence at specified times with stateless events.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_beats_to_sequence(sequence, [1.0, 2.0, 4.0])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
    testing_lib.add_beats_to_sequence(expected_subsequence_1, [1.0, 2.0])
    expected_subsequence_1.total_time = 3.0
    expected_subsequence_1.subsequence_info.end_time_offset = 5.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    expected_subsequence_2.total_time = 0.0
    expected_subsequence_2.subsequence_info.start_time_offset = 3.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.0

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
    testing_lib.add_beats_to_sequence(expected_subsequence_3, [0.0])
    expected_subsequence_3.total_time = 1.0
    expected_subsequence_3.subsequence_info.start_time_offset = 4.0
    expected_subsequence_3.subsequence_info.end_time_offset = 3.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=[3.0, 4.0])
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceOnSilence(self):
    sequence = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 1.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

    expected_subsequence_1 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 1.0), (11, 55, 0.22, 0.50)])
    expected_subsequence_1.total_time = 1.0
    expected_subsequence_1.subsequence_info.end_time_offset = 4.0

    expected_subsequence_2 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(40, 45, 0.0, 1.0), (55, 120, 1.50, 1.51)])
    expected_subsequence_2.total_time = 1.51
    expected_subsequence_2.subsequence_info.start_time_offset = 2.50
    expected_subsequence_2.subsequence_info.end_time_offset = 0.99

    expected_subsequence_3 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(52, 99, 0.0, 0.25)])
    expected_subsequence_3.total_time = 0.25
    expected_subsequence_3.subsequence_info.start_time_offset = 4.75

    subsequences = sequences_lib.split_note_sequence_on_silence(
        sequence, gap_seconds=0.5)
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceOnSilenceInitialGap(self):
    sequence = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 1.5, 2.0), (11, 55, 1.5, 3.0), (40, 45, 2.5, 3.5)])

    expected_subsequence_1 = music_pb2.NoteSequence()
    expected_subsequence_1.total_time = 0.0
    expected_subsequence_1.subsequence_info.end_time_offset = 3.5

    expected_subsequence_2 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(12, 100, 0.0, 0.5), (11, 55, 0.0, 1.5), (40, 45, 1.0, 2.0)])
    expected_subsequence_2.total_time = 2.0
    expected_subsequence_2.subsequence_info.start_time_offset = 1.5

    subsequences = sequences_lib.split_note_sequence_on_silence(
        sequence, gap_seconds=1.0)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testQuantizeNoteSequence(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        self.note_sequence,
        [(&#39;B7&#39;, 0.22), (&#39;Em9&#39;, 4.0)])
    testing_lib.add_control_changes_to_sequence(
        self.note_sequence, 0,
        [(2.0, 64, 127), (4.0, 64, 0)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_quarter = (
        self.steps_per_quarter)
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(0, 40), (1, 2), (10, 14), (16, 17), (19, 20)])
    testing_lib.add_quantized_chord_steps_to_sequence(
        expected_quantized_sequence, [1, 16])
    testing_lib.add_quantized_control_steps_to_sequence(
        expected_quantized_sequence, [8, 16])

    quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, steps_per_quarter=self.steps_per_quarter)

    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testQuantizeNoteSequenceAbsolute(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        self.note_sequence,
        [(&#39;B7&#39;, 0.22), (&#39;Em9&#39;, 4.0)])
    testing_lib.add_control_changes_to_sequence(
        self.note_sequence, 0,
        [(2.0, 64, 127), (4.0, 64, 0)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_second = 4
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(0, 40), (1, 2), (10, 14), (16, 17), (19, 20)])
    testing_lib.add_quantized_chord_steps_to_sequence(
        expected_quantized_sequence, [1, 16])
    testing_lib.add_quantized_control_steps_to_sequence(
        expected_quantized_sequence, [8, 16])

    quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
        self.note_sequence, steps_per_second=4)

    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testAssertIsQuantizedNoteSequence(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

    relative_quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, steps_per_quarter=self.steps_per_quarter)
    absolute_quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
        self.note_sequence, steps_per_second=4)

    sequences_lib.assert_is_quantized_sequence(relative_quantized_sequence)
    sequences_lib.assert_is_quantized_sequence(absolute_quantized_sequence)
    with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
      sequences_lib.assert_is_quantized_sequence(self.note_sequence)

  def testAssertIsRelativeQuantizedNoteSequence(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

    relative_quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, steps_per_quarter=self.steps_per_quarter)
    absolute_quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
        self.note_sequence, steps_per_second=4)

    sequences_lib.assert_is_relative_quantized_sequence(
        relative_quantized_sequence)
    with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
      sequences_lib.assert_is_relative_quantized_sequence(
          absolute_quantized_sequence)
    with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
      sequences_lib.assert_is_relative_quantized_sequence(self.note_sequence)

  def testQuantizeNoteSequence_TimeSignatureChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.time_signatures[:]
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Single time signature.
    self.note_sequence.time_signatures.add(numerator=4, denominator=4, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Multiple time signatures with no change.
    self.note_sequence.time_signatures.add(numerator=4, denominator=4, time=1)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Time signature change.
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
    with self.assertRaises(sequences_lib.MultipleTimeSignatureError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testQuantizeNoteSequence_ImplicitTimeSignatureChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.time_signatures[:]

    # No time signature.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Implicit time signature change.
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
    with self.assertRaises(sequences_lib.MultipleTimeSignatureError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.time_signatures[:]

    # No time signature.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # No implicit time signature change, but time signatures are added out of
    # order.
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

  def testStepsPerQuarterToStepsPerSecond(self):
    self.assertEqual(
        4.0, sequences_lib.steps_per_quarter_to_steps_per_second(4, 60.0))

  def testQuantizeToStep(self):
    self.assertEqual(
        32, sequences_lib.quantize_to_step(8.0001, 4))
    self.assertEqual(
        34, sequences_lib.quantize_to_step(8.4999, 4))
    self.assertEqual(
        33, sequences_lib.quantize_to_step(8.4999, 4, quantize_cutoff=1.0))

  def testFromNoteSequence_TempoChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.tempos[:]

    # No tempos.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Single tempo.
    self.note_sequence.tempos.add(qpm=60, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Multiple tempos with no change.
    self.note_sequence.tempos.add(qpm=60, time=1)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Tempo change.
    self.note_sequence.tempos.add(qpm=120, time=2)
    with self.assertRaises(sequences_lib.MultipleTempoError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testFromNoteSequence_ImplicitTempoChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.tempos[:]

    # No tempo.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Implicit tempo change.
    self.note_sequence.tempos.add(qpm=60, time=2)
    with self.assertRaises(sequences_lib.MultipleTempoError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testFromNoteSequence_NoImplicitTempoChangeOutOfOrder(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.tempos[:]

    # No tempo.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # No implicit tempo change, but tempos are added out of order.
    self.note_sequence.tempos.add(qpm=60, time=2)
    self.note_sequence.tempos.add(qpm=60, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

  def testRounding(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 1,
        [(12, 100, 0.01, 0.24), (11, 100, 0.22, 0.55), (40, 100, 0.50, 0.75),
         (41, 100, 0.689, 1.18), (44, 100, 1.19, 1.69), (55, 100, 4.0, 4.01)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_quarter = (
        self.steps_per_quarter)
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(0, 1), (1, 2), (2, 3), (3, 5), (5, 7), (16, 17)])
    quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testMultiTrack(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 1.0, 4.0), (19, 100, 0.95, 3.0)])
    testing_lib.add_track_to_sequence(
        self.note_sequence, 3,
        [(12, 100, 1.0, 4.0), (19, 100, 2.0, 5.0)])
    testing_lib.add_track_to_sequence(
        self.note_sequence, 7,
        [(12, 100, 1.0, 5.0), (19, 100, 2.0, 4.0), (24, 100, 3.0, 3.5)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_quarter = (
        self.steps_per_quarter)
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(4, 16), (4, 12), (4, 16), (8, 20), (4, 20), (8, 16), (12, 14)])
    quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testStepsPerBar(self):
    qns = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertEqual(16, sequences_lib.steps_per_bar_in_quantized_sequence(qns))

    self.note_sequence.time_signatures[0].numerator = 6
    self.note_sequence.time_signatures[0].denominator = 8
    qns = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertEqual(12.0,
                     sequences_lib.steps_per_bar_in_quantized_sequence(qns))

  def testStretchNoteSequence(self):
    expected_stretched_sequence = copy.deepcopy(self.note_sequence)
    expected_stretched_sequence.tempos[0].qpm = 40

    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.0, 10.0), (11, 55, 0.2, 0.5), (40, 45, 2.5, 3.5)])
    testing_lib.add_track_to_sequence(
        expected_stretched_sequence, 0,
        [(12, 100, 0.0, 15.0), (11, 55, 0.3, 0.75), (40, 45, 3.75, 5.25)])

    testing_lib.add_chords_to_sequence(
        self.note_sequence, [(&#39;B7&#39;, 0.5), (&#39;Em9&#39;, 2.0)])
    testing_lib.add_chords_to_sequence(
        expected_stretched_sequence, [(&#39;B7&#39;, 0.75), (&#39;Em9&#39;, 3.0)])

    prestretched_sequence = copy.deepcopy(self.note_sequence)

    stretched_sequence = sequences_lib.stretch_note_sequence(
        self.note_sequence, stretch_factor=1.5, in_place=False)
    self.assertProtoEquals(expected_stretched_sequence, stretched_sequence)

    # Make sure the proto was not modified
    self.assertProtoEquals(prestretched_sequence, self.note_sequence)

    sequences_lib.stretch_note_sequence(
        self.note_sequence, stretch_factor=1.5, in_place=True)
    self.assertProtoEquals(stretched_sequence, self.note_sequence)

  def testAdjustNoteSequenceTimes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.control_changes.add(control_number=1, time=2.0)
    sequence.pitch_bends.add(bend=5, time=2.0)
    sequence.total_time = 7.0

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, lambda t: t - 1)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.notes.add(pitch=60, start_time=0.0, end_time=4.0)
    expected_sequence.notes.add(pitch=61, start_time=5.0, end_time=6.0)
    expected_sequence.control_changes.add(control_number=1, time=1.0)
    expected_sequence.pitch_bends.add(bend=5, time=1.0)
    expected_sequence.total_time = 6.0

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(0, skipped_notes)

  def testAdjustNoteSequenceTimesWithSkippedNotes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
    sequence.total_time = 8.0

    def time_func(time):
      if time &gt; 5:
        return 5
      else:
        return time

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, time_func)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    expected_sequence.total_time = 5.0

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(2, skipped_notes)

  def testAdjustNoteSequenceTimesWithNotesBeforeTimeZero(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
    sequence.total_time = 8.0

    def time_func(time):
      return time - 5

    with self.assertRaises(sequences_lib.InvalidTimeAdjustmentError):
      sequences_lib.adjust_notesequence_times(sequence, time_func)

  def testAdjustNoteSequenceTimesWithZeroDurations(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
    sequence.notes.add(pitch=61, start_time=3.0, end_time=4.0)
    sequence.notes.add(pitch=62, start_time=5.0, end_time=6.0)
    sequence.total_time = 8.0

    def time_func(time):
      if time % 2 == 0:
        return time - 1
      else:
        return time

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, time_func)

    expected_sequence = music_pb2.NoteSequence()

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(3, skipped_notes)

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, time_func, minimum_duration=.1)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.notes.add(pitch=60, start_time=1.0, end_time=1.1)
    expected_sequence.notes.add(pitch=61, start_time=3.0, end_time=3.1)
    expected_sequence.notes.add(pitch=62, start_time=5.0, end_time=5.1)
    expected_sequence.total_time = 5.1

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(0, skipped_notes)

  def testAdjustNoteSequenceTimesEndBeforeStart(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
    sequence.notes.add(pitch=61, start_time=3.0, end_time=4.0)
    sequence.notes.add(pitch=62, start_time=5.0, end_time=6.0)
    sequence.total_time = 8.0

    def time_func(time):
      if time % 2 == 0:
        return time - 2
      else:
        return time

    with self.assertRaises(sequences_lib.InvalidTimeAdjustmentError):
      sequences_lib.adjust_notesequence_times(sequence, time_func)

  def testRectifyBeats(self):
    sequence = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.25, 0.5), (62, 100, 0.5, 0.75), (64, 100, 0.75, 2.5),
         (65, 100, 1.0, 1.5), (67, 100, 1.5, 2.0)])
    testing_lib.add_beats_to_sequence(sequence, [0.5, 1.0, 2.0])

    rectified_sequence, alignment = sequences_lib.rectify_beats(
        sequence, 120)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.tempos.add(qpm=120)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.25, 0.5), (62, 100, 0.5, 0.75), (64, 100, 0.75, 2.0),
         (65, 100, 1.0, 1.25), (67, 100, 1.25, 1.5)])
    testing_lib.add_beats_to_sequence(expected_sequence, [0.5, 1.0, 1.5])

    self.assertEqual(expected_sequence, rectified_sequence)

    expected_alignment = [
        [0.0, 0.5, 1.0, 2.0, 2.5],
        [0.0, 0.5, 1.0, 1.5, 2.0]
    ]
    self.assertEqual(expected_alignment, alignment.T.tolist())

  def testApplySustainControlChanges(self):
    &#34;&#34;&#34;Verify sustain controls extend notes until the end of the control.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (0.75, 64, 0), (2.0, 64, 127), (3.0, 64, 0),
         (3.75, 64, 127), (4.5, 64, 127), (4.8, 64, 0), (4.9, 64, 127),
         (6.0, 64, 0)])
    testing_lib.add_track_to_sequence(
        sequence, 1,
        [(12, 100, 0.01, 10.0), (52, 99, 4.75, 5.0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.8)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithRepeatedNotes(self):
    &#34;&#34;&#34;Verify that sustain control handles repeated notes correctly.

    For example, a single pitch played before sustain:
    x-- x-- x--
    After sustain:
    x---x---x--

    Notes should be extended until either the end of the sustain control or the
    beginning of another note of the same pitch.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.25, 1.50), (60, 100, 1.25, 1.50), (72, 100, 2.00, 3.50),
         (60, 100, 2.0, 3.00), (60, 100, 3.50, 4.50)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.25, 1.25), (60, 100, 1.25, 2.00), (72, 100, 2.00, 4.00),
         (60, 100, 2.0, 3.50), (60, 100, 3.50, 4.50)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithRepeatedNotesBeforeSustain(self):
    &#34;&#34;&#34;Repeated notes before sustain can overlap and should not be modified.

    Once a repeat happens within the sustain, any active notes should end
    before the next one starts.

    This is kind of an edge case because a note overlapping a note of the same
    pitch may not make sense, but apply_sustain_control_changes tries not to
    modify events that happen outside of a sustain.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.25, 1.50), (60, 100, .50, 1.50), (60, 100, 1.25, 2.0)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.25, 1.25), (60, 100, 0.50, 1.25), (60, 100, 1.25, 4.00)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesSimultaneousOnOff(self):
    &#34;&#34;&#34;Test sustain on and off events happening at the same time.

    The off event should be processed last, so this should be a no-op.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0, [(1.0, 64, 127), (1.0, 64, 0)])
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.50, 1.50), (60, 100, 2.0, 3.0)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(sequence, sus_sequence)

  def testApplySustainControlChangesExtendNotesToEnd(self):
    &#34;&#34;&#34;Test sustain control extending the duration of the final note.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0, [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.50, 4.00), (72, 100, 2.0, 4.0)])
    expected_sequence.total_time = 4.0

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesExtraneousSustain(self):
    &#34;&#34;&#34;Test applying extraneous sustain control at the end of the sequence.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0, [(4.0, 64, 127), (5.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
    # The total_time field only takes *notes* into account, and should not be
    # affected by a sustain-on event beyond the last note.
    expected_sequence.total_time = 3.0

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithIdenticalNotes(self):
    &#34;&#34;&#34;In the case of identical notes, one should be dropped.

    This is an edge case because in most cases, the same pitch should not sound
    twice at the same time on one instrument.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 2.00, 2.50), (60, 100, 2.00, 2.50)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 2.00, 4.00)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithDrumNotes(self):
    &#34;&#34;&#34;Drum notes should not be modified when applying sustain changes.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 2.00, 2.50)])
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(38, 100, 2.00, 2.50)], is_drum=True)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 2.00, 4.00)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(38, 100, 2.0, 2.5)], is_drum=True)

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesProcessSustainBeforeNotes(self):
    &#34;&#34;&#34;Verify sustain controls extend notes until the end of the control.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (0.75, 64, 0), (2.0, 64, 127), (3.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testInferDenseChordsForSequence(self):
    # Test non-quantized sequence.
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 1.0, 3.0), (64, 100, 1.0, 2.0), (67, 100, 1.0, 2.0),
         (65, 100, 2.0, 3.0), (69, 100, 2.0, 3.0),
         (62, 100, 3.0, 5.0), (65, 100, 3.0, 4.0), (69, 100, 3.0, 4.0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_chords_to_sequence(
        expected_sequence, [(&#39;C&#39;, 1.0), (&#39;F/C&#39;, 2.0), (&#39;Dm&#39;, 3.0)])
    sequences_lib.infer_dense_chords_for_sequence(sequence)
    self.assertProtoEquals(expected_sequence, sequence)

    # Test quantized sequence.
    sequence = copy.copy(self.note_sequence)
    sequence.quantization_info.steps_per_quarter = 1
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 1.1, 3.0), (64, 100, 1.0, 1.9), (67, 100, 1.0, 2.0),
         (65, 100, 2.0, 3.2), (69, 100, 2.1, 3.1),
         (62, 100, 2.9, 4.8), (65, 100, 3.0, 4.0), (69, 100, 3.0, 4.1)])
    testing_lib.add_quantized_steps_to_sequence(
        sequence,
        [(1, 3), (1, 2), (1, 2), (2, 3), (2, 3), (3, 5), (3, 4), (3, 4)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_chords_to_sequence(
        expected_sequence, [(&#39;C&#39;, 1.0), (&#39;F/C&#39;, 2.0), (&#39;Dm&#39;, 3.0)])
    testing_lib.add_quantized_chord_steps_to_sequence(
        expected_sequence, [1, 2, 3])
    sequences_lib.infer_dense_chords_for_sequence(sequence)
    self.assertProtoEquals(expected_sequence, sequence)

  def testShiftSequenceTimes(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 1, [(2.0, 64, 127)])
    testing_lib.add_pitch_bends_to_sequence(
        sequence, 1, 1, [(2.0, 100), (3.0, 0)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(12, 100, 1.01, 11.0), (11, 55, 1.22, 1.50), (40, 45, 3.50, 4.50),
         (55, 120, 5.0, 5.01), (52, 99, 5.75, 6.0)])
    testing_lib.add_chords_to_sequence(
        expected_sequence, [(&#39;C&#39;, 2.5), (&#39;G7&#39;, 4.0), (&#39;F&#39;, 5.8)])
    testing_lib.add_control_changes_to_sequence(
        expected_sequence, 0,
        [(1.0, 64, 127), (3.0, 64, 0), (5.0, 64, 127), (6.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        expected_sequence, 1, [(3.0, 64, 127)])
    testing_lib.add_pitch_bends_to_sequence(
        expected_sequence, 1, 1, [(3.0, 100), (4.0, 0)])

    expected_sequence.time_signatures[0].time = 1
    expected_sequence.tempos[0].time = 1

    shifted_sequence = sequences_lib.shift_sequence_times(sequence, 1.0)
    self.assertProtoEquals(expected_sequence, shifted_sequence)

  def testConcatenateSequences(self):
    sequence1 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence1, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])
    sequence2 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence2, 0,
        [(59, 100, 0.0, 1.0), (71, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (59, 100, 1.5, 2.5), (71, 100, 2.0, 3.0)])

    cat_seq = sequences_lib.concatenate_sequences([sequence1, sequence2])
    self.assertProtoEquals(expected_sequence, cat_seq)

  def testConcatenateSequencesWithSpecifiedDurations(self):
    sequence1 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence1, 0, [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])
    sequence2 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence2, 0,
        [(59, 100, 0.0, 1.0)])
    sequence3 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence3, 0,
        [(72, 100, 0.0, 1.0), (73, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (59, 100, 2.0, 3.0),
         (72, 100, 3.5, 4.5), (73, 100, 4.0, 5.0)])

    cat_seq = sequences_lib.concatenate_sequences(
        [sequence1, sequence2, sequence3],
        sequence_durations=[2, 1.5, 2])
    self.assertProtoEquals(expected_sequence, cat_seq)

  def testRepeatSequenceToDuration(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (60, 100, 1.5, 2.5), (72, 100, 2.0, 3.0)])

    repeated_seq = sequences_lib.repeat_sequence_to_duration(
        sequence, duration=3)
    self.assertProtoEquals(expected_sequence, repeated_seq)

  def testRepeatSequenceToDurationProvidedDuration(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (60, 100, 2.0, 3.0), (72, 100, 2.5, 3.0)])

    repeated_seq = sequences_lib.repeat_sequence_to_duration(
        sequence, duration=3, sequence_duration=2)
    self.assertProtoEquals(expected_sequence, repeated_seq)

  def testRemoveRedundantData(self):
    sequence = copy.copy(self.note_sequence)
    redundant_tempo = sequence.tempos.add()
    redundant_tempo.CopyFrom(sequence.tempos[0])
    redundant_tempo.time = 5.0
    sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
    sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
    sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
    sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
    sequence.sequence_metadata.genre.append(&#39;Classical&#39;)
    sequence.sequence_metadata.genre.append(&#39;Classical&#39;)

    fixed_sequence = sequences_lib.remove_redundant_data(sequence)

    expected_sequence = copy.copy(self.note_sequence)
    expected_sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
    expected_sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
    expected_sequence.sequence_metadata.genre.append(&#39;Classical&#39;)

    self.assertProtoEquals(expected_sequence, fixed_sequence)

  def testRemoveRedundantDataOutOfOrder(self):
    sequence = copy.copy(self.note_sequence)
    meaningful_tempo = sequence.tempos.add()
    meaningful_tempo.time = 5.0
    meaningful_tempo.qpm = 50
    redundant_tempo = sequence.tempos.add()
    redundant_tempo.CopyFrom(sequence.tempos[0])

    expected_sequence = copy.copy(self.note_sequence)
    expected_meaningful_tempo = expected_sequence.tempos.add()
    expected_meaningful_tempo.time = 5.0
    expected_meaningful_tempo.qpm = 50

    fixed_sequence = sequences_lib.remove_redundant_data(sequence)
    self.assertProtoEquals(expected_sequence, fixed_sequence)

  def testExpandSectionGroups(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 1.0, 2.0),
         (59, 100, 2.0, 3.0), (71, 100, 3.0, 4.0)])
    sequence.section_annotations.add(time=0, section_id=0)
    sequence.section_annotations.add(time=1, section_id=1)
    sequence.section_annotations.add(time=2, section_id=2)
    sequence.section_annotations.add(time=3, section_id=3)

    # A((BC)2D)2
    sg = sequence.section_groups.add()
    sg.sections.add(section_id=0)
    sg.num_times = 1
    sg = sequence.section_groups.add()
    sg.sections.add(section_group=music_pb2.NoteSequence.SectionGroup(
        sections=[music_pb2.NoteSequence.Section(section_id=1),
                  music_pb2.NoteSequence.Section(section_id=2)],
        num_times=2))
    sg.sections.add(section_id=3)
    sg.num_times = 2

    expanded = sequences_lib.expand_section_groups(sequence)

    expected = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected, 0,
        [(60, 100, 0.0, 1.0),
         (72, 100, 1.0, 2.0),
         (59, 100, 2.0, 3.0),
         (72, 100, 3.0, 4.0),
         (59, 100, 4.0, 5.0),
         (71, 100, 5.0, 6.0),
         (72, 100, 6.0, 7.0),
         (59, 100, 7.0, 8.0),
         (72, 100, 8.0, 9.0),
         (59, 100, 9.0, 10.0),
         (71, 100, 10.0, 11.0)])
    expected.section_annotations.add(time=0, section_id=0)
    expected.section_annotations.add(time=1, section_id=1)
    expected.section_annotations.add(time=2, section_id=2)
    expected.section_annotations.add(time=3, section_id=1)
    expected.section_annotations.add(time=4, section_id=2)
    expected.section_annotations.add(time=5, section_id=3)
    expected.section_annotations.add(time=6, section_id=1)
    expected.section_annotations.add(time=7, section_id=2)
    expected.section_annotations.add(time=8, section_id=1)
    expected.section_annotations.add(time=9, section_id=2)
    expected.section_annotations.add(time=10, section_id=3)
    self.assertProtoEquals(expected, expanded)

  def testExpandWithoutSectionGroups(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 1.0, 2.0),
         (59, 100, 2.0, 3.0), (71, 100, 3.0, 4.0)])
    sequence.section_annotations.add(time=0, section_id=0)
    sequence.section_annotations.add(time=1, section_id=1)
    sequence.section_annotations.add(time=2, section_id=2)
    sequence.section_annotations.add(time=3, section_id=3)

    expanded = sequences_lib.expand_section_groups(sequence)

    self.assertEqual(sequence, expanded)

  def testSequenceToPianoroll(self):
    sequence = music_pb2.NoteSequence(total_time=1.21)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.11, 1.01),
                                                    (2, 55, 0.22, 0.50),
                                                    (3, 100, 0.3, 0.8),
                                                    (2, 45, 1.0, 1.21)])

    pianoroll_tuple = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=1, max_pitch=2)
    output = pianoroll_tuple.active
    offset = pianoroll_tuple.offsets

    expected_pianoroll = [[0, 0],
                          [1, 0],
                          [1, 1],
                          [1, 1],
                          [1, 1],
                          [1, 0],
                          [1, 0],
                          [1, 0],
                          [1, 0],
                          [1, 0],
                          [1, 1],
                          [0, 1],
                          [0, 1]]

    expected_offsets = [[0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 1],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [1, 0],
                        [0, 0],
                        [0, 1]]

    np.testing.assert_allclose(expected_pianoroll, output)
    np.testing.assert_allclose(expected_offsets, offset)

  def testSequenceToPianorollWithBlankFrameBeforeOffset(self):
    sequence = music_pb2.NoteSequence(total_time=1.5)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.00, 1.00),
                                                    (2, 100, 0.20, 0.50),
                                                    (1, 100, 1.20, 1.50),
                                                    (2, 100, 0.50, 1.50)])

    expected_pianoroll = [
        [1, 0],
        [1, 0],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 1],
        [0, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 0],
    ]

    output = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=1, max_pitch=2).active

    np.testing.assert_allclose(expected_pianoroll, output)

    expected_pianoroll_with_blank_frame = [
        [1, 0],
        [1, 0],
        [1, 1],
        [1, 1],
        [1, 0],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 1],
        [0, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 0],
    ]

    output_with_blank_frame = sequences_lib.sequence_to_pianoroll(
        sequence,
        frames_per_second=10,
        min_pitch=1,
        max_pitch=2,
        add_blank_frame_before_onset=True).active

    np.testing.assert_allclose(expected_pianoroll_with_blank_frame,
                               output_with_blank_frame)

  def testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder(self):
    sequence = music_pb2.NoteSequence(total_time=.5)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.20, 0.50),
                                                    (1, 100, 0.00, 0.20)])

    expected_pianoroll = [
        [1],
        [0],
        [1],
        [1],
        [1],
        [0],
    ]

    output = sequences_lib.sequence_to_pianoroll(
        sequence,
        frames_per_second=10,
        min_pitch=1,
        max_pitch=1,
        add_blank_frame_before_onset=True).active

    np.testing.assert_allclose(expected_pianoroll, output)

  def testSequenceToPianorollWeightedRoll(self):
    sequence = music_pb2.NoteSequence(total_time=2.0)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.00, 1.00),
                                                    (2, 100, 0.20, 0.50),
                                                    (3, 100, 1.20, 1.50),
                                                    (4, 100, 0.40, 2.00),
                                                    (6, 100, 0.10, 0.60)])

    onset_upweight = 5.0
    expected_roll_weights = [
        [onset_upweight, onset_upweight, 1, onset_upweight],
        [onset_upweight, onset_upweight, onset_upweight, onset_upweight],
        [1, 1, onset_upweight, onset_upweight / 1],
        [1, 1, onset_upweight, onset_upweight / 2],
        [1, 1, 1, 1],
    ]

    expected_onsets = [
        [1, 1, 0, 1],
        [1, 1, 1, 1],
        [0, 0, 1, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 0],
    ]
    roll = sequences_lib.sequence_to_pianoroll(
        sequence,
        frames_per_second=2,
        min_pitch=1,
        max_pitch=4,
        onset_upweight=onset_upweight)

    np.testing.assert_allclose(expected_roll_weights, roll.weights)
    np.testing.assert_allclose(expected_onsets, roll.onsets)

  def testSequenceToPianorollOnsets(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=2.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
    sequence.total_time = 8.0

    onsets = sequences_lib.sequence_to_pianoroll(
        sequence,
        100,
        60,
        62,
        onset_mode=&#39;length_ms&#39;,
        onset_length_ms=100.0,
        onset_delay_ms=10.0,
        min_frame_occupancy_for_label=.999).onsets

    expected_roll = np.zeros([801, 3])
    expected_roll[201:211, 0] = 1.
    expected_roll[601:611, 1] = 1.
    expected_roll[701:711, 2] = 1.

    np.testing.assert_equal(expected_roll, onsets)

  def testSequenceToPianorollFrameOccupancy(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=1.7)
    sequence.notes.add(pitch=61, start_time=6.2, end_time=6.55)
    sequence.notes.add(pitch=62, start_time=3.4, end_time=4.3)
    sequence.total_time = 6.55

    active = sequences_lib.sequence_to_pianoroll(
        sequence, 2, 60, 62, min_frame_occupancy_for_label=0.5).active

    expected_roll = np.zeros([14, 3])
    expected_roll[2:3, 0] = 1.
    expected_roll[12:13, 1] = 1.
    expected_roll[7:9, 2] = 1.

    np.testing.assert_equal(expected_roll, active)

  def testSequenceToPianorollOnsetVelocities(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=0.0, end_time=2.0, velocity=16)
    sequence.notes.add(pitch=61, start_time=0.0, end_time=2.0, velocity=32)
    sequence.notes.add(pitch=62, start_time=0.0, end_time=2.0, velocity=64)
    sequence.total_time = 2.0

    roll = sequences_lib.sequence_to_pianoroll(
        sequence, 1, 60, 62, max_velocity=64, onset_window=0)
    onset_velocities = roll.onset_velocities

    self.assertEqual(onset_velocities[0, 0], 0.25)
    self.assertEqual(onset_velocities[0, 1], 0.5)
    self.assertEqual(onset_velocities[0, 2], 1.)
    self.assertEqual(np.all(onset_velocities[1:] == 0), True)

  def testSequenceToPianorollActiveVelocities(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=0.0, end_time=2.0, velocity=16)
    sequence.notes.add(pitch=61, start_time=0.0, end_time=2.0, velocity=32)
    sequence.notes.add(pitch=62, start_time=0.0, end_time=2.0, velocity=64)
    sequence.total_time = 2.0

    roll = sequences_lib.sequence_to_pianoroll(
        sequence, 1, 60, 62, max_velocity=64)
    active_velocities = roll.active_velocities

    self.assertEqual(np.all(active_velocities[0:2, 0] == 0.25), True)
    self.assertEqual(np.all(active_velocities[0:2, 1] == 0.5), True)
    self.assertEqual(np.all(active_velocities[0:2, 2] == 1.), True)
    self.assertEqual(np.all(active_velocities[2:] == 0), True)

  def testPianorollToNoteSequence(self):
    # 100 frames of notes.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames.
    frames[25:75, 39] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames, frames_per_second=DEFAULT_FRAMES_PER_SECOND, min_duration_ms=0)

    self.assertLen(sequence.notes, 1)
    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[0].start_time)
    self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

  def testPianorollToNoteSequenceAllNotes(self):
    # Test all 128 notes
    frames = np.eye(MIDI_PITCHES, dtype=np.bool)  # diagonal identity matrix
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames, frames_per_second=DEFAULT_FRAMES_PER_SECOND, min_duration_ms=0)

    self.assertLen(sequence.notes, MIDI_PITCHES)
    for i in range(MIDI_PITCHES):
      self.assertEqual(i, sequence.notes[i].pitch)
      self.assertAlmostEqual(i / DEFAULT_FRAMES_PER_SECOND,
                             sequence.notes[i].start_time)
      self.assertAlmostEqual((i+1) / DEFAULT_FRAMES_PER_SECOND,
                             sequence.notes[i].end_time)

  def testPianorollToNoteSequenceWithOnsets(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    # Add an onset for the first occurrence.
    onsets[25, 39] = True
    # Add an onset for a note that doesn&#39;t have an active frame.
    onsets[80, 49] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[0].start_time)
    self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

    self.assertEqual(49, sequence.notes[1].pitch)
    self.assertEqual(80 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[1].start_time)
    self.assertEqual(81 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[1].end_time)

  def testPianorollToNoteSequenceWithOnsetsAndVelocity(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    velocity_values = np.zeros((100, MIDI_PITCHES), np.float32)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    # Add an onset for the first occurrence with a valid velocity.
    onsets[25, 39] = True
    velocity_values[25, 39] = 0.5
    # Add an onset for the second occurrence with a NaN velocity.
    onsets[90, 39] = True
    velocity_values[90, 39] = float(&#39;nan&#39;)
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets,
        velocity_values=velocity_values)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(50, sequence.notes[0].velocity)
    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(0, sequence.notes[1].velocity)

  def testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    velocity_values = np.zeros((100, MIDI_PITCHES), np.float32)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    onsets[25, 39] = True
    velocity_values[25, 39] = 0.5
    onsets[90, 39] = True
    velocity_values[90, 39] = 1.0
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets,
        velocity_values=velocity_values,
        velocity_scale=127,
        velocity_bias=0)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(63, sequence.notes[0].velocity)
    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(127, sequence.notes[1].velocity)

  def testPianorollToNoteSequenceWithOnsetsDefaultVelocity(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    onsets[25, 39] = True
    onsets[90, 39] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets,
        velocity=100)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(100, sequence.notes[0].velocity)
    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(100, sequence.notes[1].velocity)

  def testPianorollToNoteSequenceWithOnsetsOverlappingFrames(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames.
    frames[25:75, 39] = True
    # Add multiple onsets within those frames.
    onsets[25, 39] = True
    onsets[30, 39] = True
    # If an onset lasts for multiple frames, it should create only 1 note.
    onsets[35, 39] = True
    onsets[36, 39] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets)
    self.assertLen(sequence.notes, 3)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[0].start_time)
    self.assertEqual(30 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(30 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[1].start_time)
    self.assertEqual(35 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[1].end_time)

    self.assertEqual(39, sequence.notes[2].pitch)
    self.assertEqual(35 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[2].start_time)
    self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[2].end_time)

  def testPianorollOnsetsToNoteSequence(self):
    onsets = np.zeros((10, 2), np.bool)
    velocity_values = np.zeros_like(onsets, np.float32)
    onsets[0:2, 0] = True
    velocity_values[0:2, 0] = .5
    onsets[1:2, 1] = True
    velocity_values[1:2, 1] = 1
    sequence = sequences_lib.pianoroll_onsets_to_note_sequence(
        onsets, frames_per_second=10, note_duration_seconds=0.05,
        min_midi_pitch=60, velocity_values=velocity_values)

    self.assertLen(sequence.notes, 3)

    self.assertEqual(60, sequence.notes[0].pitch)
    self.assertEqual(0, sequence.notes[0].start_time)
    self.assertAlmostEqual(0.05, sequence.notes[0].end_time)
    self.assertEqual(50, sequence.notes[0].velocity)

    self.assertEqual(60, sequence.notes[1].pitch)
    self.assertEqual(0.1, sequence.notes[1].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[1].end_time)
    self.assertEqual(50, sequence.notes[1].velocity)

    self.assertEqual(61, sequence.notes[2].pitch)
    self.assertEqual(0.1, sequence.notes[2].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[2].end_time)
    self.assertEqual(90, sequence.notes[2].velocity)

  def testPianorollOnsetsToNoteSequenceFullVelocityScale(self):
    onsets = np.zeros((10, 2), np.bool)
    velocity_values = np.zeros_like(onsets, np.float32)
    onsets[0:2, 0] = True
    velocity_values[0:2, 0] = .5
    onsets[1:2, 1] = True
    velocity_values[1:2, 1] = 1
    sequence = sequences_lib.pianoroll_onsets_to_note_sequence(
        onsets, frames_per_second=10, note_duration_seconds=0.05,
        min_midi_pitch=60, velocity_values=velocity_values,
        velocity_scale=127, velocity_bias=0)

    self.assertLen(sequence.notes, 3)

    self.assertEqual(60, sequence.notes[0].pitch)
    self.assertEqual(0, sequence.notes[0].start_time)
    self.assertAlmostEqual(0.05, sequence.notes[0].end_time)
    self.assertEqual(63, sequence.notes[0].velocity)

    self.assertEqual(60, sequence.notes[1].pitch)
    self.assertEqual(0.1, sequence.notes[1].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[1].end_time)
    self.assertEqual(63, sequence.notes[1].velocity)

    self.assertEqual(61, sequence.notes[2].pitch)
    self.assertEqual(0.1, sequence.notes[2].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[2].end_time)
    self.assertEqual(127, sequence.notes[2].velocity)

  def testSequenceToPianorollControlChanges(self):
    sequence = music_pb2.NoteSequence(total_time=2.0)
    cc = music_pb2.NoteSequence.ControlChange
    sequence.control_changes.extend([
        cc(time=0.7, control_number=3, control_value=16),
        cc(time=0.0, control_number=4, control_value=32),
        cc(time=0.5, control_number=4, control_value=32),
        cc(time=1.6, control_number=3, control_value=64),
    ])

    expected_cc_roll = np.zeros((5, 128), dtype=np.int32)
    expected_cc_roll[0:2, 4] = 33
    expected_cc_roll[1, 3] = 17
    expected_cc_roll[3, 3] = 65

    cc_roll = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=2, min_pitch=1, max_pitch=4).control_changes

    np.testing.assert_allclose(expected_cc_roll, cc_roll)

  def testSequenceToPianorollOverlappingNotes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
    sequence.notes.add(pitch=60, start_time=1.2, end_time=2.0)
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.5)
    sequence.total_time = 2.5

    rolls = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=60, max_pitch=60,
        onset_mode=&#39;length_ms&#39;, onset_length_ms=10)

    expected_onsets = np.zeros([26, 1])
    expected_onsets[10, 0] = 1
    expected_onsets[12, 0] = 1
    np.testing.assert_equal(expected_onsets, rolls.onsets)

    expected_offsets = np.zeros([26, 1])
    expected_offsets[20, 0] = 1
    expected_offsets[25, 0] = 1
    np.testing.assert_equal(expected_offsets, rolls.offsets)

    expected_active = np.zeros([26, 1])
    expected_active[10:25, 0] = 1
    np.testing.assert_equal(expected_active, rolls.active)

  def testSequenceToPianorollShortNotes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=1.0001)
    sequence.notes.add(pitch=60, start_time=1.2, end_time=1.2001)
    sequence.total_time = 2.5

    rolls = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=60, max_pitch=60,
        onset_mode=&#39;length_ms&#39;, onset_length_ms=0)

    expected_onsets = np.zeros([26, 1])
    expected_onsets[10, 0] = 1
    expected_onsets[12, 0] = 1
    np.testing.assert_equal(expected_onsets, rolls.onsets)

    expected_offsets = np.zeros([26, 1])
    expected_offsets[10, 0] = 1
    expected_offsets[12, 0] = 1
    np.testing.assert_equal(expected_offsets, rolls.offsets)

    expected_active = np.zeros([26, 1])
    expected_active[10:11, 0] = 1
    expected_active[12:13, 0] = 1
    np.testing.assert_equal(expected_active, rolls.active)

  def testSequenceToValuedIntervals(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=69, start_time=1.0, end_time=2.0, velocity=80)
    # Should be dropped because it is 0 duration.
    sequence.notes.add(pitch=60, start_time=3.0, end_time=3.0, velocity=90)

    intervals, pitches, velocities = sequences_lib.sequence_to_valued_intervals(
        sequence)
    np.testing.assert_array_equal([[1., 2.]], intervals)
    np.testing.assert_array_equal([440.0], pitches)
    np.testing.assert_array_equal([80], velocities)


if __name__ == &#39;__main__&#39;:
  absltest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.sequences_lib_test.SequencesLibTest"><code class="flex name class">
<span>class <span class="ident">SequencesLibTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds assertProtoEquals from tf.test.TestCase.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequencesLibTest(testing_lib.ProtoTestCase):

  def testTransposeNoteSequence(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    sequence.text_annotations.add(
        time=1, annotation_type=CHORD_SYMBOL, text=&#39;N.C.&#39;)
    sequence.text_annotations.add(
        time=2, annotation_type=CHORD_SYMBOL, text=&#39;E7&#39;)
    sequence.key_signatures.add(
        time=0, key=music_pb2.NoteSequence.KeySignature.E,
        mode=music_pb2.NoteSequence.KeySignature.MIXOLYDIAN)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(13, 100, 0.01, 10.0), (12, 55, 0.22, 0.50), (41, 45, 2.50, 3.50),
         (56, 120, 4.0, 4.01), (53, 99, 4.75, 5.0)])
    expected_sequence.text_annotations.add(
        time=1, annotation_type=CHORD_SYMBOL, text=&#39;N.C.&#39;)
    expected_sequence.text_annotations.add(
        time=2, annotation_type=CHORD_SYMBOL, text=&#39;F7&#39;)
    expected_sequence.key_signatures.add(
        time=0, key=music_pb2.NoteSequence.KeySignature.F,
        mode=music_pb2.NoteSequence.KeySignature.MIXOLYDIAN)

    transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
        sequence, 1)
    self.assertProtoEquals(expected_sequence, transposed_sequence)
    self.assertEqual(delete_count, 0)

  def testTransposeNoteSequenceOutOfRange(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(35, 100, 0.01, 10.0), (36, 55, 0.22, 0.50), (37, 45, 2.50, 3.50),
         (38, 120, 4.0, 4.01), (39, 99, 4.75, 5.0)])

    expected_sequence_1 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence_1, 0,
        [(39, 100, 0.01, 10.0), (40, 55, 0.22, 0.50)])

    expected_sequence_2 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence_2, 0,
        [(30, 120, 4.0, 4.01), (31, 99, 4.75, 5.0)])

    sequence_copy = copy.copy(sequence)
    transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
        sequence_copy, 4, 30, 40)
    self.assertProtoEquals(expected_sequence_1, transposed_sequence)
    self.assertEqual(delete_count, 3)

    sequence_copy = copy.copy(sequence)
    transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
        sequence_copy, -8, 30, 40)
    self.assertProtoEquals(expected_sequence_2, transposed_sequence)
    self.assertEqual(delete_count, 3)

  def testClampTranspose(self):
    clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
        5, 20, 60, 10, 70)
    self.assertEqual(clamped, 5)

    clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
        15, 20, 60, 10, 65)
    self.assertEqual(clamped, 5)

    clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
        -16, 20, 60, 10, 70)
    self.assertEqual(clamped, -10)

  def testAugmentNoteSequenceDeleteFalse(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=2,
        max_stretch_factor=2,
        min_transpose=-15,
        max_transpose=-10,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=False)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(10, 100, 0.02, 20.0), (11, 55, 0.44, 1.0),
                               (38, 45, 5., 7.), (53, 120, 8.0, 8.02),
                               (50, 99, 9.5, 10.0)])
    expected_sequence.tempos[0].qpm = 30.

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testAugmentNoteSequenceDeleteTrue(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=2,
        max_stretch_factor=2,
        min_transpose=-15,
        max_transpose=-15,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=True)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(25, 45, 5., 7.), (40, 120, 8.0, 8.02),
                               (37, 99, 9.5, 10.0)])
    expected_sequence.tempos[0].qpm = 30.

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testAugmentNoteSequenceNoStretch(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=1,
        max_stretch_factor=1.,
        min_transpose=-15,
        max_transpose=-15,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=True)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(25, 45, 2.5, 3.50), (40, 120, 4.0, 4.01),
                               (37, 99, 4.75, 5.0)])

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testAugmentNoteSequenceNoTranspose(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                      (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                      (52, 99, 4.75, 5.0)])

    augmented_sequence = sequences_lib.augment_note_sequence(
        sequence,
        min_stretch_factor=2,
        max_stretch_factor=2.,
        min_transpose=0,
        max_transpose=0,
        min_allowed_pitch=10,
        max_allowed_pitch=127,
        delete_out_of_range_notes=True)

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0, [(12, 100, 0.02, 20.0), (13, 55, 0.44, 1.0),
                               (40, 45, 5., 7.), (55, 120, 8.0, 8.02),
                               (52, 99, 9.5, 10.0)])
    expected_sequence.tempos[0].qpm = 30.

    self.assertProtoEquals(augmented_sequence, expected_sequence)

  def testTrimNoteSequence(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    expected_subsequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_subsequence, 0,
        [(40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01)])
    expected_subsequence.total_time = 4.75

    subsequence = sequences_lib.trim_note_sequence(sequence, 2.5, 4.75)
    self.assertProtoEquals(expected_subsequence, subsequence)

  def testExtractSubsequence(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 1, [(2.0, 64, 127)])
    expected_subsequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_subsequence, 0,
        [(40, 45, 0.0, 1.0), (55, 120, 1.5, 1.51)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 0.5)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 64, 0), (1.5, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 1, [(0.0, 64, 127)])
    expected_subsequence.total_time = 1.51
    expected_subsequence.subsequence_info.start_time_offset = 2.5
    expected_subsequence.subsequence_info.end_time_offset = 5.99

    subsequence = sequences_lib.extract_subsequence(sequence, 2.5, 4.75)
    subsequence.control_changes.sort(
        key=lambda cc: (cc.instrument, cc.time))
    self.assertProtoEquals(expected_subsequence, subsequence)

  def testExtractSubsequencePastEnd(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 18.0)])

    with self.assertRaises(ValueError):
      sequences_lib.extract_subsequence(sequence, 15.0, 16.0)

  def testExtractSubsequencePedalEvents(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0, [(60, 80, 2.5, 5.0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 1, [(2.0, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 66, 0), (2.0, 66, 127), (4.0, 66, 0), (5.0, 66, 127)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 67, 10), (2.0, 67, 20), (4.0, 67, 30), (5.0, 67, 40)])
    expected_subsequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_subsequence, 0, [(60, 80, 0, 2.25)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 64, 0), (1.5, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 1, [(0.0, 64, 127)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 66, 127), (1.5, 66, 0)])
    testing_lib.add_control_changes_to_sequence(
        expected_subsequence, 0, [(0.0, 67, 20), (1.5, 67, 30)])
    expected_subsequence.control_changes.sort(
        key=lambda cc: (cc.instrument, cc.control_number, cc.time))
    expected_subsequence.total_time = 2.25
    expected_subsequence.subsequence_info.start_time_offset = 2.5
    expected_subsequence.subsequence_info.end_time_offset = .25

    subsequence = sequences_lib.extract_subsequence(sequence, 2.5, 4.75)
    subsequence.control_changes.sort(
        key=lambda cc: (cc.instrument, cc.control_number, cc.time))
    self.assertProtoEquals(expected_subsequence, subsequence)

  def testSplitNoteSequenceWithHopSize(self):
    # Tests splitting a NoteSequence at regular hop size, truncating notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0), (&#39;F&#39;, 4.0)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0)])
    expected_subsequence_1.total_time = 3.0
    expected_subsequence_1.subsequence_info.end_time_offset = 5.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(55, 120, 1.0, 1.01), (52, 99, 1.75, 2.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 1.0)])
    expected_subsequence_2.total_time = 2.0
    expected_subsequence_2.subsequence_info.start_time_offset = 3.0
    expected_subsequence_2.subsequence_info.end_time_offset = 3.0

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_chords_to_sequence(
        expected_subsequence_3, [(&#39;F&#39;, 0.0)])
    expected_subsequence_3.total_time = 0.0
    expected_subsequence_3.subsequence_info.start_time_offset = 6.0
    expected_subsequence_3.subsequence_info.end_time_offset = 2.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=3.0)
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceAtTimes(self):
    # Tests splitting a NoteSequence at specified times, truncating notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0), (&#39;F&#39;, 4.0)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0)])
    expected_subsequence_1.total_time = 3.0
    expected_subsequence_1.subsequence_info.end_time_offset = 5.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;G7&#39;, 0.0)])
    expected_subsequence_2.total_time = 0.0
    expected_subsequence_2.subsequence_info.start_time_offset = 3.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.0

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_3, [(&#39;F&#39;, 0.0)])
    expected_subsequence_3.total_time = 1.0
    expected_subsequence_3.subsequence_info.start_time_offset = 4.0
    expected_subsequence_3.subsequence_info.end_time_offset = 3.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=[3.0, 4.0])
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceSkipSplitsInsideNotes(self):
    # Tests splitting a NoteSequence at regular hop size, skipping splits that
    # would have occurred inside a note.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.5)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 3.0)])
    expected_subsequence_1.total_time = 3.50
    expected_subsequence_1.subsequence_info.end_time_offset = 1.5

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.5)])
    expected_subsequence_2.total_time = 1.0
    expected_subsequence_2.subsequence_info.start_time_offset = 4.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=2.0, skip_splits_inside_notes=True)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testSplitNoteSequenceNoTimeChanges(self):
    # Tests splitting a NoteSequence on time changes for a NoteSequence that has
    # no time changes (time signature and tempo changes).
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence = music_pb2.NoteSequence()
    expected_subsequence.CopyFrom(sequence)
    expected_subsequence.subsequence_info.start_time_offset = 0.0
    expected_subsequence.subsequence_info.end_time_offset = 0.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 1)
    self.assertProtoEquals(expected_subsequence, subsequences[0])

  def testSplitNoteSequenceDuplicateTimeChanges(self):
    # Tests splitting a NoteSequence on time changes for a NoteSequence that has
    # duplicate time changes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence = music_pb2.NoteSequence()
    expected_subsequence.CopyFrom(sequence)
    expected_subsequence.subsequence_info.start_time_offset = 0.0
    expected_subsequence.subsequence_info.end_time_offset = 0.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 1)
    self.assertProtoEquals(expected_subsequence, subsequences[0])

  def testSplitNoteSequenceCoincidentTimeChanges(self):
    # Tests splitting a NoteSequence on time changes for a NoteSequence that has
    # two time changes occurring simultaneously.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}
        tempos: {
          time: 2.0
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 2.0), (11, 55, 0.22, 0.50)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.5)])
    expected_subsequence_1.total_time = 2.0
    expected_subsequence_1.subsequence_info.end_time_offset = 8.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(40, 45, 0.50, 1.50), (55, 120, 2.0, 2.01), (52, 99, 2.75, 3.0)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 1.0), (&#39;F&#39;, 2.8)])
    expected_subsequence_2.total_time = 3.0
    expected_subsequence_2.subsequence_info.start_time_offset = 2.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes(self):
    # Tests splitting a NoteSequence on time changes skipping splits that occur
    # inside notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}
        tempos: {
          time: 4.25
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0)])
    expected_subsequence_1.total_time = 4.01
    expected_subsequence_1.subsequence_info.end_time_offset = 0.99

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0, [(52, 99, 0.5, 0.75)])
    testing_lib.add_chords_to_sequence(expected_subsequence_2, [
        (&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.55)])
    expected_subsequence_2.total_time = 0.75
    expected_subsequence_2.subsequence_info.start_time_offset = 4.25

    subsequences = sequences_lib.split_note_sequence_on_time_changes(
        sequence, skip_splits_inside_notes=True)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testSplitNoteSequenceMultipleTimeChanges(self):
    # Tests splitting a NoteSequence on time changes, truncating notes on splits
    # that occur inside notes.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        time_signatures: {
          time: 2.0
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}
        tempos: {
          time: 4.25
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 2.0), (11, 55, 0.22, 0.50)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_1, [(&#39;C&#39;, 1.5)])
    expected_subsequence_1.total_time = 2.0
    expected_subsequence_1.subsequence_info.end_time_offset = 8.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(40, 45, 0.50, 1.50), (55, 120, 2.0, 2.01)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_2, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 1.0)])
    expected_subsequence_2.total_time = 2.01
    expected_subsequence_2.subsequence_info.start_time_offset = 2.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.99

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 3
          denominator: 4}
        tempos: {
          qpm: 80}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(52, 99, 0.5, 0.75)])
    testing_lib.add_chords_to_sequence(
        expected_subsequence_3, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.55)])
    expected_subsequence_3.total_time = 0.75
    expected_subsequence_3.subsequence_info.start_time_offset = 4.25
    expected_subsequence_3.subsequence_info.end_time_offset = 5.0

    subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceWithStatelessEvents(self):
    # Tests splitting a NoteSequence at specified times with stateless events.
    sequence = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_beats_to_sequence(sequence, [1.0, 2.0, 4.0])

    expected_subsequence_1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
    testing_lib.add_beats_to_sequence(expected_subsequence_1, [1.0, 2.0])
    expected_subsequence_1.total_time = 3.0
    expected_subsequence_1.subsequence_info.end_time_offset = 5.0

    expected_subsequence_2 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    expected_subsequence_2.total_time = 0.0
    expected_subsequence_2.subsequence_info.start_time_offset = 3.0
    expected_subsequence_2.subsequence_info.end_time_offset = 5.0

    expected_subsequence_3 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4}
        tempos: {
          qpm: 60}&#34;&#34;&#34;)
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
    testing_lib.add_beats_to_sequence(expected_subsequence_3, [0.0])
    expected_subsequence_3.total_time = 1.0
    expected_subsequence_3.subsequence_info.start_time_offset = 4.0
    expected_subsequence_3.subsequence_info.end_time_offset = 3.0

    subsequences = sequences_lib.split_note_sequence(
        sequence, hop_size_seconds=[3.0, 4.0])
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceOnSilence(self):
    sequence = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 1.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

    expected_subsequence_1 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_1, 0,
        [(12, 100, 0.01, 1.0), (11, 55, 0.22, 0.50)])
    expected_subsequence_1.total_time = 1.0
    expected_subsequence_1.subsequence_info.end_time_offset = 4.0

    expected_subsequence_2 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(40, 45, 0.0, 1.0), (55, 120, 1.50, 1.51)])
    expected_subsequence_2.total_time = 1.51
    expected_subsequence_2.subsequence_info.start_time_offset = 2.50
    expected_subsequence_2.subsequence_info.end_time_offset = 0.99

    expected_subsequence_3 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_3, 0,
        [(52, 99, 0.0, 0.25)])
    expected_subsequence_3.total_time = 0.25
    expected_subsequence_3.subsequence_info.start_time_offset = 4.75

    subsequences = sequences_lib.split_note_sequence_on_silence(
        sequence, gap_seconds=0.5)
    self.assertLen(subsequences, 3)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])
    self.assertProtoEquals(expected_subsequence_3, subsequences[2])

  def testSplitNoteSequenceOnSilenceInitialGap(self):
    sequence = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 1.5, 2.0), (11, 55, 1.5, 3.0), (40, 45, 2.5, 3.5)])

    expected_subsequence_1 = music_pb2.NoteSequence()
    expected_subsequence_1.total_time = 0.0
    expected_subsequence_1.subsequence_info.end_time_offset = 3.5

    expected_subsequence_2 = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        expected_subsequence_2, 0,
        [(12, 100, 0.0, 0.5), (11, 55, 0.0, 1.5), (40, 45, 1.0, 2.0)])
    expected_subsequence_2.total_time = 2.0
    expected_subsequence_2.subsequence_info.start_time_offset = 1.5

    subsequences = sequences_lib.split_note_sequence_on_silence(
        sequence, gap_seconds=1.0)
    self.assertLen(subsequences, 2)
    self.assertProtoEquals(expected_subsequence_1, subsequences[0])
    self.assertProtoEquals(expected_subsequence_2, subsequences[1])

  def testQuantizeNoteSequence(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        self.note_sequence,
        [(&#39;B7&#39;, 0.22), (&#39;Em9&#39;, 4.0)])
    testing_lib.add_control_changes_to_sequence(
        self.note_sequence, 0,
        [(2.0, 64, 127), (4.0, 64, 0)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_quarter = (
        self.steps_per_quarter)
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(0, 40), (1, 2), (10, 14), (16, 17), (19, 20)])
    testing_lib.add_quantized_chord_steps_to_sequence(
        expected_quantized_sequence, [1, 16])
    testing_lib.add_quantized_control_steps_to_sequence(
        expected_quantized_sequence, [8, 16])

    quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, steps_per_quarter=self.steps_per_quarter)

    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testQuantizeNoteSequenceAbsolute(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        self.note_sequence,
        [(&#39;B7&#39;, 0.22), (&#39;Em9&#39;, 4.0)])
    testing_lib.add_control_changes_to_sequence(
        self.note_sequence, 0,
        [(2.0, 64, 127), (4.0, 64, 0)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_second = 4
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(0, 40), (1, 2), (10, 14), (16, 17), (19, 20)])
    testing_lib.add_quantized_chord_steps_to_sequence(
        expected_quantized_sequence, [1, 16])
    testing_lib.add_quantized_control_steps_to_sequence(
        expected_quantized_sequence, [8, 16])

    quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
        self.note_sequence, steps_per_second=4)

    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testAssertIsQuantizedNoteSequence(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

    relative_quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, steps_per_quarter=self.steps_per_quarter)
    absolute_quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
        self.note_sequence, steps_per_second=4)

    sequences_lib.assert_is_quantized_sequence(relative_quantized_sequence)
    sequences_lib.assert_is_quantized_sequence(absolute_quantized_sequence)
    with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
      sequences_lib.assert_is_quantized_sequence(self.note_sequence)

  def testAssertIsRelativeQuantizedNoteSequence(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

    relative_quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, steps_per_quarter=self.steps_per_quarter)
    absolute_quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
        self.note_sequence, steps_per_second=4)

    sequences_lib.assert_is_relative_quantized_sequence(
        relative_quantized_sequence)
    with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
      sequences_lib.assert_is_relative_quantized_sequence(
          absolute_quantized_sequence)
    with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
      sequences_lib.assert_is_relative_quantized_sequence(self.note_sequence)

  def testQuantizeNoteSequence_TimeSignatureChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.time_signatures[:]
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Single time signature.
    self.note_sequence.time_signatures.add(numerator=4, denominator=4, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Multiple time signatures with no change.
    self.note_sequence.time_signatures.add(numerator=4, denominator=4, time=1)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Time signature change.
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
    with self.assertRaises(sequences_lib.MultipleTimeSignatureError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testQuantizeNoteSequence_ImplicitTimeSignatureChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.time_signatures[:]

    # No time signature.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Implicit time signature change.
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
    with self.assertRaises(sequences_lib.MultipleTimeSignatureError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.time_signatures[:]

    # No time signature.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # No implicit time signature change, but time signatures are added out of
    # order.
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
    self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

  def testStepsPerQuarterToStepsPerSecond(self):
    self.assertEqual(
        4.0, sequences_lib.steps_per_quarter_to_steps_per_second(4, 60.0))

  def testQuantizeToStep(self):
    self.assertEqual(
        32, sequences_lib.quantize_to_step(8.0001, 4))
    self.assertEqual(
        34, sequences_lib.quantize_to_step(8.4999, 4))
    self.assertEqual(
        33, sequences_lib.quantize_to_step(8.4999, 4, quantize_cutoff=1.0))

  def testFromNoteSequence_TempoChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.tempos[:]

    # No tempos.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Single tempo.
    self.note_sequence.tempos.add(qpm=60, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Multiple tempos with no change.
    self.note_sequence.tempos.add(qpm=60, time=1)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Tempo change.
    self.note_sequence.tempos.add(qpm=120, time=2)
    with self.assertRaises(sequences_lib.MultipleTempoError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testFromNoteSequence_ImplicitTempoChange(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.tempos[:]

    # No tempo.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # Implicit tempo change.
    self.note_sequence.tempos.add(qpm=60, time=2)
    with self.assertRaises(sequences_lib.MultipleTempoError):
      sequences_lib.quantize_note_sequence(
          self.note_sequence, self.steps_per_quarter)

  def testFromNoteSequence_NoImplicitTempoChangeOutOfOrder(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    del self.note_sequence.tempos[:]

    # No tempo.
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

    # No implicit tempo change, but tempos are added out of order.
    self.note_sequence.tempos.add(qpm=60, time=2)
    self.note_sequence.tempos.add(qpm=60, time=0)
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)

  def testRounding(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 1,
        [(12, 100, 0.01, 0.24), (11, 100, 0.22, 0.55), (40, 100, 0.50, 0.75),
         (41, 100, 0.689, 1.18), (44, 100, 1.19, 1.69), (55, 100, 4.0, 4.01)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_quarter = (
        self.steps_per_quarter)
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(0, 1), (1, 2), (2, 3), (3, 5), (5, 7), (16, 17)])
    quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testMultiTrack(self):
    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 1.0, 4.0), (19, 100, 0.95, 3.0)])
    testing_lib.add_track_to_sequence(
        self.note_sequence, 3,
        [(12, 100, 1.0, 4.0), (19, 100, 2.0, 5.0)])
    testing_lib.add_track_to_sequence(
        self.note_sequence, 7,
        [(12, 100, 1.0, 5.0), (19, 100, 2.0, 4.0), (24, 100, 3.0, 3.5)])

    expected_quantized_sequence = copy.deepcopy(self.note_sequence)
    expected_quantized_sequence.quantization_info.steps_per_quarter = (
        self.steps_per_quarter)
    testing_lib.add_quantized_steps_to_sequence(
        expected_quantized_sequence,
        [(4, 16), (4, 12), (4, 16), (8, 20), (4, 20), (8, 16), (12, 14)])
    quantized_sequence = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)

  def testStepsPerBar(self):
    qns = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertEqual(16, sequences_lib.steps_per_bar_in_quantized_sequence(qns))

    self.note_sequence.time_signatures[0].numerator = 6
    self.note_sequence.time_signatures[0].denominator = 8
    qns = sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)
    self.assertEqual(12.0,
                     sequences_lib.steps_per_bar_in_quantized_sequence(qns))

  def testStretchNoteSequence(self):
    expected_stretched_sequence = copy.deepcopy(self.note_sequence)
    expected_stretched_sequence.tempos[0].qpm = 40

    testing_lib.add_track_to_sequence(
        self.note_sequence, 0,
        [(12, 100, 0.0, 10.0), (11, 55, 0.2, 0.5), (40, 45, 2.5, 3.5)])
    testing_lib.add_track_to_sequence(
        expected_stretched_sequence, 0,
        [(12, 100, 0.0, 15.0), (11, 55, 0.3, 0.75), (40, 45, 3.75, 5.25)])

    testing_lib.add_chords_to_sequence(
        self.note_sequence, [(&#39;B7&#39;, 0.5), (&#39;Em9&#39;, 2.0)])
    testing_lib.add_chords_to_sequence(
        expected_stretched_sequence, [(&#39;B7&#39;, 0.75), (&#39;Em9&#39;, 3.0)])

    prestretched_sequence = copy.deepcopy(self.note_sequence)

    stretched_sequence = sequences_lib.stretch_note_sequence(
        self.note_sequence, stretch_factor=1.5, in_place=False)
    self.assertProtoEquals(expected_stretched_sequence, stretched_sequence)

    # Make sure the proto was not modified
    self.assertProtoEquals(prestretched_sequence, self.note_sequence)

    sequences_lib.stretch_note_sequence(
        self.note_sequence, stretch_factor=1.5, in_place=True)
    self.assertProtoEquals(stretched_sequence, self.note_sequence)

  def testAdjustNoteSequenceTimes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.control_changes.add(control_number=1, time=2.0)
    sequence.pitch_bends.add(bend=5, time=2.0)
    sequence.total_time = 7.0

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, lambda t: t - 1)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.notes.add(pitch=60, start_time=0.0, end_time=4.0)
    expected_sequence.notes.add(pitch=61, start_time=5.0, end_time=6.0)
    expected_sequence.control_changes.add(control_number=1, time=1.0)
    expected_sequence.pitch_bends.add(bend=5, time=1.0)
    expected_sequence.total_time = 6.0

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(0, skipped_notes)

  def testAdjustNoteSequenceTimesWithSkippedNotes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
    sequence.total_time = 8.0

    def time_func(time):
      if time &gt; 5:
        return 5
      else:
        return time

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, time_func)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    expected_sequence.total_time = 5.0

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(2, skipped_notes)

  def testAdjustNoteSequenceTimesWithNotesBeforeTimeZero(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
    sequence.total_time = 8.0

    def time_func(time):
      return time - 5

    with self.assertRaises(sequences_lib.InvalidTimeAdjustmentError):
      sequences_lib.adjust_notesequence_times(sequence, time_func)

  def testAdjustNoteSequenceTimesWithZeroDurations(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
    sequence.notes.add(pitch=61, start_time=3.0, end_time=4.0)
    sequence.notes.add(pitch=62, start_time=5.0, end_time=6.0)
    sequence.total_time = 8.0

    def time_func(time):
      if time % 2 == 0:
        return time - 1
      else:
        return time

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, time_func)

    expected_sequence = music_pb2.NoteSequence()

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(3, skipped_notes)

    adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
        sequence, time_func, minimum_duration=.1)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.notes.add(pitch=60, start_time=1.0, end_time=1.1)
    expected_sequence.notes.add(pitch=61, start_time=3.0, end_time=3.1)
    expected_sequence.notes.add(pitch=62, start_time=5.0, end_time=5.1)
    expected_sequence.total_time = 5.1

    self.assertEqual(expected_sequence, adjusted_ns)
    self.assertEqual(0, skipped_notes)

  def testAdjustNoteSequenceTimesEndBeforeStart(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
    sequence.notes.add(pitch=61, start_time=3.0, end_time=4.0)
    sequence.notes.add(pitch=62, start_time=5.0, end_time=6.0)
    sequence.total_time = 8.0

    def time_func(time):
      if time % 2 == 0:
        return time - 2
      else:
        return time

    with self.assertRaises(sequences_lib.InvalidTimeAdjustmentError):
      sequences_lib.adjust_notesequence_times(sequence, time_func)

  def testRectifyBeats(self):
    sequence = music_pb2.NoteSequence()
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.25, 0.5), (62, 100, 0.5, 0.75), (64, 100, 0.75, 2.5),
         (65, 100, 1.0, 1.5), (67, 100, 1.5, 2.0)])
    testing_lib.add_beats_to_sequence(sequence, [0.5, 1.0, 2.0])

    rectified_sequence, alignment = sequences_lib.rectify_beats(
        sequence, 120)

    expected_sequence = music_pb2.NoteSequence()
    expected_sequence.tempos.add(qpm=120)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.25, 0.5), (62, 100, 0.5, 0.75), (64, 100, 0.75, 2.0),
         (65, 100, 1.0, 1.25), (67, 100, 1.25, 1.5)])
    testing_lib.add_beats_to_sequence(expected_sequence, [0.5, 1.0, 1.5])

    self.assertEqual(expected_sequence, rectified_sequence)

    expected_alignment = [
        [0.0, 0.5, 1.0, 2.0, 2.5],
        [0.0, 0.5, 1.0, 1.5, 2.0]
    ]
    self.assertEqual(expected_alignment, alignment.T.tolist())

  def testApplySustainControlChanges(self):
    &#34;&#34;&#34;Verify sustain controls extend notes until the end of the control.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (0.75, 64, 0), (2.0, 64, 127), (3.0, 64, 0),
         (3.75, 64, 127), (4.5, 64, 127), (4.8, 64, 0), (4.9, 64, 127),
         (6.0, 64, 0)])
    testing_lib.add_track_to_sequence(
        sequence, 1,
        [(12, 100, 0.01, 10.0), (52, 99, 4.75, 5.0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.8)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithRepeatedNotes(self):
    &#34;&#34;&#34;Verify that sustain control handles repeated notes correctly.

    For example, a single pitch played before sustain:
    x-- x-- x--
    After sustain:
    x---x---x--

    Notes should be extended until either the end of the sustain control or the
    beginning of another note of the same pitch.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.25, 1.50), (60, 100, 1.25, 1.50), (72, 100, 2.00, 3.50),
         (60, 100, 2.0, 3.00), (60, 100, 3.50, 4.50)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.25, 1.25), (60, 100, 1.25, 2.00), (72, 100, 2.00, 4.00),
         (60, 100, 2.0, 3.50), (60, 100, 3.50, 4.50)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithRepeatedNotesBeforeSustain(self):
    &#34;&#34;&#34;Repeated notes before sustain can overlap and should not be modified.

    Once a repeat happens within the sustain, any active notes should end
    before the next one starts.

    This is kind of an edge case because a note overlapping a note of the same
    pitch may not make sense, but apply_sustain_control_changes tries not to
    modify events that happen outside of a sustain.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.25, 1.50), (60, 100, .50, 1.50), (60, 100, 1.25, 2.0)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.25, 1.25), (60, 100, 0.50, 1.25), (60, 100, 1.25, 4.00)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesSimultaneousOnOff(self):
    &#34;&#34;&#34;Test sustain on and off events happening at the same time.

    The off event should be processed last, so this should be a no-op.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0, [(1.0, 64, 127), (1.0, 64, 0)])
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.50, 1.50), (60, 100, 2.0, 3.0)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(sequence, sus_sequence)

  def testApplySustainControlChangesExtendNotesToEnd(self):
    &#34;&#34;&#34;Test sustain control extending the duration of the final note.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0, [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.50, 4.00), (72, 100, 2.0, 4.0)])
    expected_sequence.total_time = 4.0

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesExtraneousSustain(self):
    &#34;&#34;&#34;Test applying extraneous sustain control at the end of the sequence.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0, [(4.0, 64, 127), (5.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
    # The total_time field only takes *notes* into account, and should not be
    # affected by a sustain-on event beyond the last note.
    expected_sequence.total_time = 3.0

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithIdenticalNotes(self):
    &#34;&#34;&#34;In the case of identical notes, one should be dropped.

    This is an edge case because in most cases, the same pitch should not sound
    twice at the same time on one instrument.
    &#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 2.00, 2.50), (60, 100, 2.00, 2.50)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 2.00, 4.00)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesWithDrumNotes(self):
    &#34;&#34;&#34;Drum notes should not be modified when applying sustain changes.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(1.0, 64, 127), (4.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 2.00, 2.50)])
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(38, 100, 2.00, 2.50)], is_drum=True)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 2.00, 4.00)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(38, 100, 2.0, 2.5)], is_drum=True)

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testApplySustainControlChangesProcessSustainBeforeNotes(self):
    &#34;&#34;&#34;Verify sustain controls extend notes until the end of the control.&#34;&#34;&#34;
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (0.75, 64, 0), (2.0, 64, 127), (3.0, 64, 0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50)])
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50)])

    sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
    self.assertProtoEquals(expected_sequence, sus_sequence)

  def testInferDenseChordsForSequence(self):
    # Test non-quantized sequence.
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 1.0, 3.0), (64, 100, 1.0, 2.0), (67, 100, 1.0, 2.0),
         (65, 100, 2.0, 3.0), (69, 100, 2.0, 3.0),
         (62, 100, 3.0, 5.0), (65, 100, 3.0, 4.0), (69, 100, 3.0, 4.0)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_chords_to_sequence(
        expected_sequence, [(&#39;C&#39;, 1.0), (&#39;F/C&#39;, 2.0), (&#39;Dm&#39;, 3.0)])
    sequences_lib.infer_dense_chords_for_sequence(sequence)
    self.assertProtoEquals(expected_sequence, sequence)

    # Test quantized sequence.
    sequence = copy.copy(self.note_sequence)
    sequence.quantization_info.steps_per_quarter = 1
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 1.1, 3.0), (64, 100, 1.0, 1.9), (67, 100, 1.0, 2.0),
         (65, 100, 2.0, 3.2), (69, 100, 2.1, 3.1),
         (62, 100, 2.9, 4.8), (65, 100, 3.0, 4.0), (69, 100, 3.0, 4.1)])
    testing_lib.add_quantized_steps_to_sequence(
        sequence,
        [(1, 3), (1, 2), (1, 2), (2, 3), (2, 3), (3, 5), (3, 4), (3, 4)])
    expected_sequence = copy.copy(sequence)
    testing_lib.add_chords_to_sequence(
        expected_sequence, [(&#39;C&#39;, 1.0), (&#39;F/C&#39;, 2.0), (&#39;Dm&#39;, 3.0)])
    testing_lib.add_quantized_chord_steps_to_sequence(
        expected_sequence, [1, 2, 3])
    sequences_lib.infer_dense_chords_for_sequence(sequence)
    self.assertProtoEquals(expected_sequence, sequence)

  def testShiftSequenceTimes(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
         (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
    testing_lib.add_chords_to_sequence(
        sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 0,
        [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        sequence, 1, [(2.0, 64, 127)])
    testing_lib.add_pitch_bends_to_sequence(
        sequence, 1, 1, [(2.0, 100), (3.0, 0)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(12, 100, 1.01, 11.0), (11, 55, 1.22, 1.50), (40, 45, 3.50, 4.50),
         (55, 120, 5.0, 5.01), (52, 99, 5.75, 6.0)])
    testing_lib.add_chords_to_sequence(
        expected_sequence, [(&#39;C&#39;, 2.5), (&#39;G7&#39;, 4.0), (&#39;F&#39;, 5.8)])
    testing_lib.add_control_changes_to_sequence(
        expected_sequence, 0,
        [(1.0, 64, 127), (3.0, 64, 0), (5.0, 64, 127), (6.0, 64, 0)])
    testing_lib.add_control_changes_to_sequence(
        expected_sequence, 1, [(3.0, 64, 127)])
    testing_lib.add_pitch_bends_to_sequence(
        expected_sequence, 1, 1, [(3.0, 100), (4.0, 0)])

    expected_sequence.time_signatures[0].time = 1
    expected_sequence.tempos[0].time = 1

    shifted_sequence = sequences_lib.shift_sequence_times(sequence, 1.0)
    self.assertProtoEquals(expected_sequence, shifted_sequence)

  def testConcatenateSequences(self):
    sequence1 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence1, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])
    sequence2 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence2, 0,
        [(59, 100, 0.0, 1.0), (71, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (59, 100, 1.5, 2.5), (71, 100, 2.0, 3.0)])

    cat_seq = sequences_lib.concatenate_sequences([sequence1, sequence2])
    self.assertProtoEquals(expected_sequence, cat_seq)

  def testConcatenateSequencesWithSpecifiedDurations(self):
    sequence1 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence1, 0, [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])
    sequence2 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence2, 0,
        [(59, 100, 0.0, 1.0)])
    sequence3 = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence3, 0,
        [(72, 100, 0.0, 1.0), (73, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (59, 100, 2.0, 3.0),
         (72, 100, 3.5, 4.5), (73, 100, 4.0, 5.0)])

    cat_seq = sequences_lib.concatenate_sequences(
        [sequence1, sequence2, sequence3],
        sequence_durations=[2, 1.5, 2])
    self.assertProtoEquals(expected_sequence, cat_seq)

  def testRepeatSequenceToDuration(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (60, 100, 1.5, 2.5), (72, 100, 2.0, 3.0)])

    repeated_seq = sequences_lib.repeat_sequence_to_duration(
        sequence, duration=3)
    self.assertProtoEquals(expected_sequence, repeated_seq)

  def testRepeatSequenceToDurationProvidedDuration(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])

    expected_sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected_sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
         (60, 100, 2.0, 3.0), (72, 100, 2.5, 3.0)])

    repeated_seq = sequences_lib.repeat_sequence_to_duration(
        sequence, duration=3, sequence_duration=2)
    self.assertProtoEquals(expected_sequence, repeated_seq)

  def testRemoveRedundantData(self):
    sequence = copy.copy(self.note_sequence)
    redundant_tempo = sequence.tempos.add()
    redundant_tempo.CopyFrom(sequence.tempos[0])
    redundant_tempo.time = 5.0
    sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
    sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
    sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
    sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
    sequence.sequence_metadata.genre.append(&#39;Classical&#39;)
    sequence.sequence_metadata.genre.append(&#39;Classical&#39;)

    fixed_sequence = sequences_lib.remove_redundant_data(sequence)

    expected_sequence = copy.copy(self.note_sequence)
    expected_sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
    expected_sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
    expected_sequence.sequence_metadata.genre.append(&#39;Classical&#39;)

    self.assertProtoEquals(expected_sequence, fixed_sequence)

  def testRemoveRedundantDataOutOfOrder(self):
    sequence = copy.copy(self.note_sequence)
    meaningful_tempo = sequence.tempos.add()
    meaningful_tempo.time = 5.0
    meaningful_tempo.qpm = 50
    redundant_tempo = sequence.tempos.add()
    redundant_tempo.CopyFrom(sequence.tempos[0])

    expected_sequence = copy.copy(self.note_sequence)
    expected_meaningful_tempo = expected_sequence.tempos.add()
    expected_meaningful_tempo.time = 5.0
    expected_meaningful_tempo.qpm = 50

    fixed_sequence = sequences_lib.remove_redundant_data(sequence)
    self.assertProtoEquals(expected_sequence, fixed_sequence)

  def testExpandSectionGroups(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 1.0, 2.0),
         (59, 100, 2.0, 3.0), (71, 100, 3.0, 4.0)])
    sequence.section_annotations.add(time=0, section_id=0)
    sequence.section_annotations.add(time=1, section_id=1)
    sequence.section_annotations.add(time=2, section_id=2)
    sequence.section_annotations.add(time=3, section_id=3)

    # A((BC)2D)2
    sg = sequence.section_groups.add()
    sg.sections.add(section_id=0)
    sg.num_times = 1
    sg = sequence.section_groups.add()
    sg.sections.add(section_group=music_pb2.NoteSequence.SectionGroup(
        sections=[music_pb2.NoteSequence.Section(section_id=1),
                  music_pb2.NoteSequence.Section(section_id=2)],
        num_times=2))
    sg.sections.add(section_id=3)
    sg.num_times = 2

    expanded = sequences_lib.expand_section_groups(sequence)

    expected = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        expected, 0,
        [(60, 100, 0.0, 1.0),
         (72, 100, 1.0, 2.0),
         (59, 100, 2.0, 3.0),
         (72, 100, 3.0, 4.0),
         (59, 100, 4.0, 5.0),
         (71, 100, 5.0, 6.0),
         (72, 100, 6.0, 7.0),
         (59, 100, 7.0, 8.0),
         (72, 100, 8.0, 9.0),
         (59, 100, 9.0, 10.0),
         (71, 100, 10.0, 11.0)])
    expected.section_annotations.add(time=0, section_id=0)
    expected.section_annotations.add(time=1, section_id=1)
    expected.section_annotations.add(time=2, section_id=2)
    expected.section_annotations.add(time=3, section_id=1)
    expected.section_annotations.add(time=4, section_id=2)
    expected.section_annotations.add(time=5, section_id=3)
    expected.section_annotations.add(time=6, section_id=1)
    expected.section_annotations.add(time=7, section_id=2)
    expected.section_annotations.add(time=8, section_id=1)
    expected.section_annotations.add(time=9, section_id=2)
    expected.section_annotations.add(time=10, section_id=3)
    self.assertProtoEquals(expected, expanded)

  def testExpandWithoutSectionGroups(self):
    sequence = copy.copy(self.note_sequence)
    testing_lib.add_track_to_sequence(
        sequence, 0,
        [(60, 100, 0.0, 1.0), (72, 100, 1.0, 2.0),
         (59, 100, 2.0, 3.0), (71, 100, 3.0, 4.0)])
    sequence.section_annotations.add(time=0, section_id=0)
    sequence.section_annotations.add(time=1, section_id=1)
    sequence.section_annotations.add(time=2, section_id=2)
    sequence.section_annotations.add(time=3, section_id=3)

    expanded = sequences_lib.expand_section_groups(sequence)

    self.assertEqual(sequence, expanded)

  def testSequenceToPianoroll(self):
    sequence = music_pb2.NoteSequence(total_time=1.21)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.11, 1.01),
                                                    (2, 55, 0.22, 0.50),
                                                    (3, 100, 0.3, 0.8),
                                                    (2, 45, 1.0, 1.21)])

    pianoroll_tuple = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=1, max_pitch=2)
    output = pianoroll_tuple.active
    offset = pianoroll_tuple.offsets

    expected_pianoroll = [[0, 0],
                          [1, 0],
                          [1, 1],
                          [1, 1],
                          [1, 1],
                          [1, 0],
                          [1, 0],
                          [1, 0],
                          [1, 0],
                          [1, 0],
                          [1, 1],
                          [0, 1],
                          [0, 1]]

    expected_offsets = [[0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 1],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [0, 0],
                        [1, 0],
                        [0, 0],
                        [0, 1]]

    np.testing.assert_allclose(expected_pianoroll, output)
    np.testing.assert_allclose(expected_offsets, offset)

  def testSequenceToPianorollWithBlankFrameBeforeOffset(self):
    sequence = music_pb2.NoteSequence(total_time=1.5)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.00, 1.00),
                                                    (2, 100, 0.20, 0.50),
                                                    (1, 100, 1.20, 1.50),
                                                    (2, 100, 0.50, 1.50)])

    expected_pianoroll = [
        [1, 0],
        [1, 0],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 1],
        [0, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 0],
    ]

    output = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=1, max_pitch=2).active

    np.testing.assert_allclose(expected_pianoroll, output)

    expected_pianoroll_with_blank_frame = [
        [1, 0],
        [1, 0],
        [1, 1],
        [1, 1],
        [1, 0],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 1],
        [0, 1],
        [1, 1],
        [1, 1],
        [1, 1],
        [0, 0],
    ]

    output_with_blank_frame = sequences_lib.sequence_to_pianoroll(
        sequence,
        frames_per_second=10,
        min_pitch=1,
        max_pitch=2,
        add_blank_frame_before_onset=True).active

    np.testing.assert_allclose(expected_pianoroll_with_blank_frame,
                               output_with_blank_frame)

  def testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder(self):
    sequence = music_pb2.NoteSequence(total_time=.5)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.20, 0.50),
                                                    (1, 100, 0.00, 0.20)])

    expected_pianoroll = [
        [1],
        [0],
        [1],
        [1],
        [1],
        [0],
    ]

    output = sequences_lib.sequence_to_pianoroll(
        sequence,
        frames_per_second=10,
        min_pitch=1,
        max_pitch=1,
        add_blank_frame_before_onset=True).active

    np.testing.assert_allclose(expected_pianoroll, output)

  def testSequenceToPianorollWeightedRoll(self):
    sequence = music_pb2.NoteSequence(total_time=2.0)
    testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.00, 1.00),
                                                    (2, 100, 0.20, 0.50),
                                                    (3, 100, 1.20, 1.50),
                                                    (4, 100, 0.40, 2.00),
                                                    (6, 100, 0.10, 0.60)])

    onset_upweight = 5.0
    expected_roll_weights = [
        [onset_upweight, onset_upweight, 1, onset_upweight],
        [onset_upweight, onset_upweight, onset_upweight, onset_upweight],
        [1, 1, onset_upweight, onset_upweight / 1],
        [1, 1, onset_upweight, onset_upweight / 2],
        [1, 1, 1, 1],
    ]

    expected_onsets = [
        [1, 1, 0, 1],
        [1, 1, 1, 1],
        [0, 0, 1, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 0],
    ]
    roll = sequences_lib.sequence_to_pianoroll(
        sequence,
        frames_per_second=2,
        min_pitch=1,
        max_pitch=4,
        onset_upweight=onset_upweight)

    np.testing.assert_allclose(expected_roll_weights, roll.weights)
    np.testing.assert_allclose(expected_onsets, roll.onsets)

  def testSequenceToPianorollOnsets(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=2.0, end_time=5.0)
    sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
    sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
    sequence.total_time = 8.0

    onsets = sequences_lib.sequence_to_pianoroll(
        sequence,
        100,
        60,
        62,
        onset_mode=&#39;length_ms&#39;,
        onset_length_ms=100.0,
        onset_delay_ms=10.0,
        min_frame_occupancy_for_label=.999).onsets

    expected_roll = np.zeros([801, 3])
    expected_roll[201:211, 0] = 1.
    expected_roll[601:611, 1] = 1.
    expected_roll[701:711, 2] = 1.

    np.testing.assert_equal(expected_roll, onsets)

  def testSequenceToPianorollFrameOccupancy(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=1.7)
    sequence.notes.add(pitch=61, start_time=6.2, end_time=6.55)
    sequence.notes.add(pitch=62, start_time=3.4, end_time=4.3)
    sequence.total_time = 6.55

    active = sequences_lib.sequence_to_pianoroll(
        sequence, 2, 60, 62, min_frame_occupancy_for_label=0.5).active

    expected_roll = np.zeros([14, 3])
    expected_roll[2:3, 0] = 1.
    expected_roll[12:13, 1] = 1.
    expected_roll[7:9, 2] = 1.

    np.testing.assert_equal(expected_roll, active)

  def testSequenceToPianorollOnsetVelocities(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=0.0, end_time=2.0, velocity=16)
    sequence.notes.add(pitch=61, start_time=0.0, end_time=2.0, velocity=32)
    sequence.notes.add(pitch=62, start_time=0.0, end_time=2.0, velocity=64)
    sequence.total_time = 2.0

    roll = sequences_lib.sequence_to_pianoroll(
        sequence, 1, 60, 62, max_velocity=64, onset_window=0)
    onset_velocities = roll.onset_velocities

    self.assertEqual(onset_velocities[0, 0], 0.25)
    self.assertEqual(onset_velocities[0, 1], 0.5)
    self.assertEqual(onset_velocities[0, 2], 1.)
    self.assertEqual(np.all(onset_velocities[1:] == 0), True)

  def testSequenceToPianorollActiveVelocities(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=0.0, end_time=2.0, velocity=16)
    sequence.notes.add(pitch=61, start_time=0.0, end_time=2.0, velocity=32)
    sequence.notes.add(pitch=62, start_time=0.0, end_time=2.0, velocity=64)
    sequence.total_time = 2.0

    roll = sequences_lib.sequence_to_pianoroll(
        sequence, 1, 60, 62, max_velocity=64)
    active_velocities = roll.active_velocities

    self.assertEqual(np.all(active_velocities[0:2, 0] == 0.25), True)
    self.assertEqual(np.all(active_velocities[0:2, 1] == 0.5), True)
    self.assertEqual(np.all(active_velocities[0:2, 2] == 1.), True)
    self.assertEqual(np.all(active_velocities[2:] == 0), True)

  def testPianorollToNoteSequence(self):
    # 100 frames of notes.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames.
    frames[25:75, 39] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames, frames_per_second=DEFAULT_FRAMES_PER_SECOND, min_duration_ms=0)

    self.assertLen(sequence.notes, 1)
    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[0].start_time)
    self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

  def testPianorollToNoteSequenceAllNotes(self):
    # Test all 128 notes
    frames = np.eye(MIDI_PITCHES, dtype=np.bool)  # diagonal identity matrix
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames, frames_per_second=DEFAULT_FRAMES_PER_SECOND, min_duration_ms=0)

    self.assertLen(sequence.notes, MIDI_PITCHES)
    for i in range(MIDI_PITCHES):
      self.assertEqual(i, sequence.notes[i].pitch)
      self.assertAlmostEqual(i / DEFAULT_FRAMES_PER_SECOND,
                             sequence.notes[i].start_time)
      self.assertAlmostEqual((i+1) / DEFAULT_FRAMES_PER_SECOND,
                             sequence.notes[i].end_time)

  def testPianorollToNoteSequenceWithOnsets(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    # Add an onset for the first occurrence.
    onsets[25, 39] = True
    # Add an onset for a note that doesn&#39;t have an active frame.
    onsets[80, 49] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[0].start_time)
    self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

    self.assertEqual(49, sequence.notes[1].pitch)
    self.assertEqual(80 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[1].start_time)
    self.assertEqual(81 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[1].end_time)

  def testPianorollToNoteSequenceWithOnsetsAndVelocity(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    velocity_values = np.zeros((100, MIDI_PITCHES), np.float32)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    # Add an onset for the first occurrence with a valid velocity.
    onsets[25, 39] = True
    velocity_values[25, 39] = 0.5
    # Add an onset for the second occurrence with a NaN velocity.
    onsets[90, 39] = True
    velocity_values[90, 39] = float(&#39;nan&#39;)
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets,
        velocity_values=velocity_values)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(50, sequence.notes[0].velocity)
    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(0, sequence.notes[1].velocity)

  def testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    velocity_values = np.zeros((100, MIDI_PITCHES), np.float32)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    onsets[25, 39] = True
    velocity_values[25, 39] = 0.5
    onsets[90, 39] = True
    velocity_values[90, 39] = 1.0
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets,
        velocity_values=velocity_values,
        velocity_scale=127,
        velocity_bias=0)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(63, sequence.notes[0].velocity)
    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(127, sequence.notes[1].velocity)

  def testPianorollToNoteSequenceWithOnsetsDefaultVelocity(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames and last 10 frames.
    frames[25:75, 39] = True
    frames[90:100, 39] = True
    onsets[25, 39] = True
    onsets[90, 39] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets,
        velocity=100)
    self.assertLen(sequence.notes, 2)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(100, sequence.notes[0].velocity)
    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(100, sequence.notes[1].velocity)

  def testPianorollToNoteSequenceWithOnsetsOverlappingFrames(self):
    # 100 frames of notes and onsets.
    frames = np.zeros((100, MIDI_PITCHES), np.bool)
    onsets = np.zeros((100, MIDI_PITCHES), np.bool)
    # Activate key 39 for the middle 50 frames.
    frames[25:75, 39] = True
    # Add multiple onsets within those frames.
    onsets[25, 39] = True
    onsets[30, 39] = True
    # If an onset lasts for multiple frames, it should create only 1 note.
    onsets[35, 39] = True
    onsets[36, 39] = True
    sequence = sequences_lib.pianoroll_to_note_sequence(
        frames,
        frames_per_second=DEFAULT_FRAMES_PER_SECOND,
        min_duration_ms=0,
        onset_predictions=onsets)
    self.assertLen(sequence.notes, 3)

    self.assertEqual(39, sequence.notes[0].pitch)
    self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[0].start_time)
    self.assertEqual(30 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

    self.assertEqual(39, sequence.notes[1].pitch)
    self.assertEqual(30 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[1].start_time)
    self.assertEqual(35 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[1].end_time)

    self.assertEqual(39, sequence.notes[2].pitch)
    self.assertEqual(35 / DEFAULT_FRAMES_PER_SECOND,
                     sequence.notes[2].start_time)
    self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[2].end_time)

  def testPianorollOnsetsToNoteSequence(self):
    onsets = np.zeros((10, 2), np.bool)
    velocity_values = np.zeros_like(onsets, np.float32)
    onsets[0:2, 0] = True
    velocity_values[0:2, 0] = .5
    onsets[1:2, 1] = True
    velocity_values[1:2, 1] = 1
    sequence = sequences_lib.pianoroll_onsets_to_note_sequence(
        onsets, frames_per_second=10, note_duration_seconds=0.05,
        min_midi_pitch=60, velocity_values=velocity_values)

    self.assertLen(sequence.notes, 3)

    self.assertEqual(60, sequence.notes[0].pitch)
    self.assertEqual(0, sequence.notes[0].start_time)
    self.assertAlmostEqual(0.05, sequence.notes[0].end_time)
    self.assertEqual(50, sequence.notes[0].velocity)

    self.assertEqual(60, sequence.notes[1].pitch)
    self.assertEqual(0.1, sequence.notes[1].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[1].end_time)
    self.assertEqual(50, sequence.notes[1].velocity)

    self.assertEqual(61, sequence.notes[2].pitch)
    self.assertEqual(0.1, sequence.notes[2].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[2].end_time)
    self.assertEqual(90, sequence.notes[2].velocity)

  def testPianorollOnsetsToNoteSequenceFullVelocityScale(self):
    onsets = np.zeros((10, 2), np.bool)
    velocity_values = np.zeros_like(onsets, np.float32)
    onsets[0:2, 0] = True
    velocity_values[0:2, 0] = .5
    onsets[1:2, 1] = True
    velocity_values[1:2, 1] = 1
    sequence = sequences_lib.pianoroll_onsets_to_note_sequence(
        onsets, frames_per_second=10, note_duration_seconds=0.05,
        min_midi_pitch=60, velocity_values=velocity_values,
        velocity_scale=127, velocity_bias=0)

    self.assertLen(sequence.notes, 3)

    self.assertEqual(60, sequence.notes[0].pitch)
    self.assertEqual(0, sequence.notes[0].start_time)
    self.assertAlmostEqual(0.05, sequence.notes[0].end_time)
    self.assertEqual(63, sequence.notes[0].velocity)

    self.assertEqual(60, sequence.notes[1].pitch)
    self.assertEqual(0.1, sequence.notes[1].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[1].end_time)
    self.assertEqual(63, sequence.notes[1].velocity)

    self.assertEqual(61, sequence.notes[2].pitch)
    self.assertEqual(0.1, sequence.notes[2].start_time)
    self.assertAlmostEqual(0.15, sequence.notes[2].end_time)
    self.assertEqual(127, sequence.notes[2].velocity)

  def testSequenceToPianorollControlChanges(self):
    sequence = music_pb2.NoteSequence(total_time=2.0)
    cc = music_pb2.NoteSequence.ControlChange
    sequence.control_changes.extend([
        cc(time=0.7, control_number=3, control_value=16),
        cc(time=0.0, control_number=4, control_value=32),
        cc(time=0.5, control_number=4, control_value=32),
        cc(time=1.6, control_number=3, control_value=64),
    ])

    expected_cc_roll = np.zeros((5, 128), dtype=np.int32)
    expected_cc_roll[0:2, 4] = 33
    expected_cc_roll[1, 3] = 17
    expected_cc_roll[3, 3] = 65

    cc_roll = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=2, min_pitch=1, max_pitch=4).control_changes

    np.testing.assert_allclose(expected_cc_roll, cc_roll)

  def testSequenceToPianorollOverlappingNotes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
    sequence.notes.add(pitch=60, start_time=1.2, end_time=2.0)
    sequence.notes.add(pitch=60, start_time=1.0, end_time=2.5)
    sequence.total_time = 2.5

    rolls = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=60, max_pitch=60,
        onset_mode=&#39;length_ms&#39;, onset_length_ms=10)

    expected_onsets = np.zeros([26, 1])
    expected_onsets[10, 0] = 1
    expected_onsets[12, 0] = 1
    np.testing.assert_equal(expected_onsets, rolls.onsets)

    expected_offsets = np.zeros([26, 1])
    expected_offsets[20, 0] = 1
    expected_offsets[25, 0] = 1
    np.testing.assert_equal(expected_offsets, rolls.offsets)

    expected_active = np.zeros([26, 1])
    expected_active[10:25, 0] = 1
    np.testing.assert_equal(expected_active, rolls.active)

  def testSequenceToPianorollShortNotes(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=60, start_time=1.0, end_time=1.0001)
    sequence.notes.add(pitch=60, start_time=1.2, end_time=1.2001)
    sequence.total_time = 2.5

    rolls = sequences_lib.sequence_to_pianoroll(
        sequence, frames_per_second=10, min_pitch=60, max_pitch=60,
        onset_mode=&#39;length_ms&#39;, onset_length_ms=0)

    expected_onsets = np.zeros([26, 1])
    expected_onsets[10, 0] = 1
    expected_onsets[12, 0] = 1
    np.testing.assert_equal(expected_onsets, rolls.onsets)

    expected_offsets = np.zeros([26, 1])
    expected_offsets[10, 0] = 1
    expected_offsets[12, 0] = 1
    np.testing.assert_equal(expected_offsets, rolls.offsets)

    expected_active = np.zeros([26, 1])
    expected_active[10:11, 0] = 1
    expected_active[12:13, 0] = 1
    np.testing.assert_equal(expected_active, rolls.active)

  def testSequenceToValuedIntervals(self):
    sequence = music_pb2.NoteSequence()
    sequence.notes.add(pitch=69, start_time=1.0, end_time=2.0, velocity=80)
    # Should be dropped because it is 0 duration.
    sequence.notes.add(pitch=60, start_time=3.0, end_time=3.0, velocity=90)

    intervals, pitches, velocities = sequences_lib.sequence_to_valued_intervals(
        sequence)
    np.testing.assert_array_equal([[1., 2.]], intervals)
    np.testing.assert_array_equal([440.0], pitches)
    np.testing.assert_array_equal([80], velocities)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.testing_lib.ProtoTestCase" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase">ProtoTestCase</a></li>
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimes"><code class="name flex">
<span>def <span class="ident">testAdjustNoteSequenceTimes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAdjustNoteSequenceTimes(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
  sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
  sequence.control_changes.add(control_number=1, time=2.0)
  sequence.pitch_bends.add(bend=5, time=2.0)
  sequence.total_time = 7.0

  adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
      sequence, lambda t: t - 1)

  expected_sequence = music_pb2.NoteSequence()
  expected_sequence.notes.add(pitch=60, start_time=0.0, end_time=4.0)
  expected_sequence.notes.add(pitch=61, start_time=5.0, end_time=6.0)
  expected_sequence.control_changes.add(control_number=1, time=1.0)
  expected_sequence.pitch_bends.add(bend=5, time=1.0)
  expected_sequence.total_time = 6.0

  self.assertEqual(expected_sequence, adjusted_ns)
  self.assertEqual(0, skipped_notes)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesEndBeforeStart"><code class="name flex">
<span>def <span class="ident">testAdjustNoteSequenceTimesEndBeforeStart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAdjustNoteSequenceTimesEndBeforeStart(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
  sequence.notes.add(pitch=61, start_time=3.0, end_time=4.0)
  sequence.notes.add(pitch=62, start_time=5.0, end_time=6.0)
  sequence.total_time = 8.0

  def time_func(time):
    if time % 2 == 0:
      return time - 2
    else:
      return time

  with self.assertRaises(sequences_lib.InvalidTimeAdjustmentError):
    sequences_lib.adjust_notesequence_times(sequence, time_func)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithNotesBeforeTimeZero"><code class="name flex">
<span>def <span class="ident">testAdjustNoteSequenceTimesWithNotesBeforeTimeZero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAdjustNoteSequenceTimesWithNotesBeforeTimeZero(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
  sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
  sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
  sequence.total_time = 8.0

  def time_func(time):
    return time - 5

  with self.assertRaises(sequences_lib.InvalidTimeAdjustmentError):
    sequences_lib.adjust_notesequence_times(sequence, time_func)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithSkippedNotes"><code class="name flex">
<span>def <span class="ident">testAdjustNoteSequenceTimesWithSkippedNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAdjustNoteSequenceTimesWithSkippedNotes(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
  sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
  sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
  sequence.total_time = 8.0

  def time_func(time):
    if time &gt; 5:
      return 5
    else:
      return time

  adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
      sequence, time_func)

  expected_sequence = music_pb2.NoteSequence()
  expected_sequence.notes.add(pitch=60, start_time=1.0, end_time=5.0)
  expected_sequence.total_time = 5.0

  self.assertEqual(expected_sequence, adjusted_ns)
  self.assertEqual(2, skipped_notes)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithZeroDurations"><code class="name flex">
<span>def <span class="ident">testAdjustNoteSequenceTimesWithZeroDurations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAdjustNoteSequenceTimesWithZeroDurations(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
  sequence.notes.add(pitch=61, start_time=3.0, end_time=4.0)
  sequence.notes.add(pitch=62, start_time=5.0, end_time=6.0)
  sequence.total_time = 8.0

  def time_func(time):
    if time % 2 == 0:
      return time - 1
    else:
      return time

  adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
      sequence, time_func)

  expected_sequence = music_pb2.NoteSequence()

  self.assertEqual(expected_sequence, adjusted_ns)
  self.assertEqual(3, skipped_notes)

  adjusted_ns, skipped_notes = sequences_lib.adjust_notesequence_times(
      sequence, time_func, minimum_duration=.1)

  expected_sequence = music_pb2.NoteSequence()
  expected_sequence.notes.add(pitch=60, start_time=1.0, end_time=1.1)
  expected_sequence.notes.add(pitch=61, start_time=3.0, end_time=3.1)
  expected_sequence.notes.add(pitch=62, start_time=5.0, end_time=5.1)
  expected_sequence.total_time = 5.1

  self.assertEqual(expected_sequence, adjusted_ns)
  self.assertEqual(0, skipped_notes)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChanges"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify sustain controls extend notes until the end of the control.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChanges(self):
  &#34;&#34;&#34;Verify sustain controls extend notes until the end of the control.&#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 64, 127), (0.75, 64, 0), (2.0, 64, 127), (3.0, 64, 0),
       (3.75, 64, 127), (4.5, 64, 127), (4.8, 64, 0), (4.9, 64, 127),
       (6.0, 64, 0)])
  testing_lib.add_track_to_sequence(
      sequence, 1,
      [(12, 100, 0.01, 10.0), (52, 99, 4.75, 5.0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.8)])

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesExtendNotesToEnd"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesExtendNotesToEnd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test sustain control extending the duration of the final note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesExtendNotesToEnd(self):
  &#34;&#34;&#34;Test sustain control extending the duration of the final note.&#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0, [(1.0, 64, 127), (4.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.50, 4.00), (72, 100, 2.0, 4.0)])
  expected_sequence.total_time = 4.0

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesExtraneousSustain"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesExtraneousSustain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test applying extraneous sustain control at the end of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesExtraneousSustain(self):
  &#34;&#34;&#34;Test applying extraneous sustain control at the end of the sequence.&#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0, [(4.0, 64, 127), (5.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.50, 1.50), (72, 100, 2.0, 3.0)])
  # The total_time field only takes *notes* into account, and should not be
  # affected by a sustain-on event beyond the last note.
  expected_sequence.total_time = 3.0

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesProcessSustainBeforeNotes"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesProcessSustainBeforeNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify sustain controls extend notes until the end of the control.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesProcessSustainBeforeNotes(self):
  &#34;&#34;&#34;Verify sustain controls extend notes until the end of the control.&#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 64, 127), (0.75, 64, 0), (2.0, 64, 127), (3.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(11, 55, 0.22, 0.75), (40, 45, 2.50, 3.50)])

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesSimultaneousOnOff"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesSimultaneousOnOff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test sustain on and off events happening at the same time.</p>
<p>The off event should be processed last, so this should be a no-op.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesSimultaneousOnOff(self):
  &#34;&#34;&#34;Test sustain on and off events happening at the same time.

  The off event should be processed last, so this should be a no-op.
  &#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0, [(1.0, 64, 127), (1.0, 64, 0)])
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.50, 1.50), (60, 100, 2.0, 3.0)])

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithDrumNotes"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesWithDrumNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Drum notes should not be modified when applying sustain changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesWithDrumNotes(self):
  &#34;&#34;&#34;Drum notes should not be modified when applying sustain changes.&#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(1.0, 64, 127), (4.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 2.00, 2.50)])
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(38, 100, 2.00, 2.50)], is_drum=True)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 2.00, 4.00)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(38, 100, 2.0, 2.5)], is_drum=True)

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithIdenticalNotes"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesWithIdenticalNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>In the case of identical notes, one should be dropped.</p>
<p>This is an edge case because in most cases, the same pitch should not sound
twice at the same time on one instrument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesWithIdenticalNotes(self):
  &#34;&#34;&#34;In the case of identical notes, one should be dropped.

  This is an edge case because in most cases, the same pitch should not sound
  twice at the same time on one instrument.
  &#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(1.0, 64, 127), (4.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 2.00, 2.50), (60, 100, 2.00, 2.50)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 2.00, 4.00)])

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithRepeatedNotes"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesWithRepeatedNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify that sustain control handles repeated notes correctly.</p>
<p>For example, a single pitch played before sustain:
x&ndash; x&ndash; x&ndash;
After sustain:
x&mdash;x&mdash;x&ndash;</p>
<p>Notes should be extended until either the end of the sustain control or the
beginning of another note of the same pitch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesWithRepeatedNotes(self):
  &#34;&#34;&#34;Verify that sustain control handles repeated notes correctly.

  For example, a single pitch played before sustain:
  x-- x-- x--
  After sustain:
  x---x---x--

  Notes should be extended until either the end of the sustain control or the
  beginning of another note of the same pitch.
  &#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(1.0, 64, 127), (4.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.25, 1.50), (60, 100, 1.25, 1.50), (72, 100, 2.00, 3.50),
       (60, 100, 2.0, 3.00), (60, 100, 3.50, 4.50)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.25, 1.25), (60, 100, 1.25, 2.00), (72, 100, 2.00, 4.00),
       (60, 100, 2.0, 3.50), (60, 100, 3.50, 4.50)])

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithRepeatedNotesBeforeSustain"><code class="name flex">
<span>def <span class="ident">testApplySustainControlChangesWithRepeatedNotesBeforeSustain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Repeated notes before sustain can overlap and should not be modified.</p>
<p>Once a repeat happens within the sustain, any active notes should end
before the next one starts.</p>
<p>This is kind of an edge case because a note overlapping a note of the same
pitch may not make sense, but apply_sustain_control_changes tries not to
modify events that happen outside of a sustain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testApplySustainControlChangesWithRepeatedNotesBeforeSustain(self):
  &#34;&#34;&#34;Repeated notes before sustain can overlap and should not be modified.

  Once a repeat happens within the sustain, any active notes should end
  before the next one starts.

  This is kind of an edge case because a note overlapping a note of the same
  pitch may not make sense, but apply_sustain_control_changes tries not to
  modify events that happen outside of a sustain.
  &#34;&#34;&#34;
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(1.0, 64, 127), (4.0, 64, 0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.25, 1.50), (60, 100, .50, 1.50), (60, 100, 1.25, 2.0)])
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.25, 1.25), (60, 100, 0.50, 1.25), (60, 100, 1.25, 4.00)])

  sus_sequence = sequences_lib.apply_sustain_control_changes(sequence)
  self.assertProtoEquals(expected_sequence, sus_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAssertIsQuantizedNoteSequence"><code class="name flex">
<span>def <span class="ident">testAssertIsQuantizedNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssertIsQuantizedNoteSequence(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

  relative_quantized_sequence = sequences_lib.quantize_note_sequence(
      self.note_sequence, steps_per_quarter=self.steps_per_quarter)
  absolute_quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
      self.note_sequence, steps_per_second=4)

  sequences_lib.assert_is_quantized_sequence(relative_quantized_sequence)
  sequences_lib.assert_is_quantized_sequence(absolute_quantized_sequence)
  with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
    sequences_lib.assert_is_quantized_sequence(self.note_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAssertIsRelativeQuantizedNoteSequence"><code class="name flex">
<span>def <span class="ident">testAssertIsRelativeQuantizedNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssertIsRelativeQuantizedNoteSequence(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

  relative_quantized_sequence = sequences_lib.quantize_note_sequence(
      self.note_sequence, steps_per_quarter=self.steps_per_quarter)
  absolute_quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
      self.note_sequence, steps_per_second=4)

  sequences_lib.assert_is_relative_quantized_sequence(
      relative_quantized_sequence)
  with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
    sequences_lib.assert_is_relative_quantized_sequence(
        absolute_quantized_sequence)
  with self.assertRaises(sequences_lib.QuantizationStatusError):  # pylint:disable=g-error-prone-assert-raises
    sequences_lib.assert_is_relative_quantized_sequence(self.note_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceDeleteFalse"><code class="name flex">
<span>def <span class="ident">testAugmentNoteSequenceDeleteFalse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAugmentNoteSequenceDeleteFalse(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                    (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                    (52, 99, 4.75, 5.0)])

  augmented_sequence = sequences_lib.augment_note_sequence(
      sequence,
      min_stretch_factor=2,
      max_stretch_factor=2,
      min_transpose=-15,
      max_transpose=-10,
      min_allowed_pitch=10,
      max_allowed_pitch=127,
      delete_out_of_range_notes=False)

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0, [(10, 100, 0.02, 20.0), (11, 55, 0.44, 1.0),
                             (38, 45, 5., 7.), (53, 120, 8.0, 8.02),
                             (50, 99, 9.5, 10.0)])
  expected_sequence.tempos[0].qpm = 30.

  self.assertProtoEquals(augmented_sequence, expected_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceDeleteTrue"><code class="name flex">
<span>def <span class="ident">testAugmentNoteSequenceDeleteTrue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAugmentNoteSequenceDeleteTrue(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                    (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                    (52, 99, 4.75, 5.0)])

  augmented_sequence = sequences_lib.augment_note_sequence(
      sequence,
      min_stretch_factor=2,
      max_stretch_factor=2,
      min_transpose=-15,
      max_transpose=-15,
      min_allowed_pitch=10,
      max_allowed_pitch=127,
      delete_out_of_range_notes=True)

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0, [(25, 45, 5., 7.), (40, 120, 8.0, 8.02),
                             (37, 99, 9.5, 10.0)])
  expected_sequence.tempos[0].qpm = 30.

  self.assertProtoEquals(augmented_sequence, expected_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceNoStretch"><code class="name flex">
<span>def <span class="ident">testAugmentNoteSequenceNoStretch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAugmentNoteSequenceNoStretch(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                    (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                    (52, 99, 4.75, 5.0)])

  augmented_sequence = sequences_lib.augment_note_sequence(
      sequence,
      min_stretch_factor=1,
      max_stretch_factor=1.,
      min_transpose=-15,
      max_transpose=-15,
      min_allowed_pitch=10,
      max_allowed_pitch=127,
      delete_out_of_range_notes=True)

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0, [(25, 45, 2.5, 3.50), (40, 120, 4.0, 4.01),
                             (37, 99, 4.75, 5.0)])

  self.assertProtoEquals(augmented_sequence, expected_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceNoTranspose"><code class="name flex">
<span>def <span class="ident">testAugmentNoteSequenceNoTranspose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAugmentNoteSequenceNoTranspose(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0, [(12, 100, 0.01, 10.0), (13, 55, 0.22, 0.50),
                    (40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01),
                    (52, 99, 4.75, 5.0)])

  augmented_sequence = sequences_lib.augment_note_sequence(
      sequence,
      min_stretch_factor=2,
      max_stretch_factor=2.,
      min_transpose=0,
      max_transpose=0,
      min_allowed_pitch=10,
      max_allowed_pitch=127,
      delete_out_of_range_notes=True)

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0, [(12, 100, 0.02, 20.0), (13, 55, 0.44, 1.0),
                             (40, 45, 5., 7.), (55, 120, 8.0, 8.02),
                             (52, 99, 9.5, 10.0)])
  expected_sequence.tempos[0].qpm = 30.

  self.assertProtoEquals(augmented_sequence, expected_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testClampTranspose"><code class="name flex">
<span>def <span class="ident">testClampTranspose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testClampTranspose(self):
  clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
      5, 20, 60, 10, 70)
  self.assertEqual(clamped, 5)

  clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
      15, 20, 60, 10, 65)
  self.assertEqual(clamped, 5)

  clamped = sequences_lib._clamp_transpose(  # pylint:disable=protected-access
      -16, 20, 60, 10, 70)
  self.assertEqual(clamped, -10)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testConcatenateSequences"><code class="name flex">
<span>def <span class="ident">testConcatenateSequences</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testConcatenateSequences(self):
  sequence1 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence1, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])
  sequence2 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence2, 0,
      [(59, 100, 0.0, 1.0), (71, 100, 0.5, 1.5)])

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
       (59, 100, 1.5, 2.5), (71, 100, 2.0, 3.0)])

  cat_seq = sequences_lib.concatenate_sequences([sequence1, sequence2])
  self.assertProtoEquals(expected_sequence, cat_seq)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testConcatenateSequencesWithSpecifiedDurations"><code class="name flex">
<span>def <span class="ident">testConcatenateSequencesWithSpecifiedDurations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testConcatenateSequencesWithSpecifiedDurations(self):
  sequence1 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence1, 0, [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])
  sequence2 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence2, 0,
      [(59, 100, 0.0, 1.0)])
  sequence3 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence3, 0,
      [(72, 100, 0.0, 1.0), (73, 100, 0.5, 1.5)])

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
       (59, 100, 2.0, 3.0),
       (72, 100, 3.5, 4.5), (73, 100, 4.0, 5.0)])

  cat_seq = sequences_lib.concatenate_sequences(
      [sequence1, sequence2, sequence3],
      sequence_durations=[2, 1.5, 2])
  self.assertProtoEquals(expected_sequence, cat_seq)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testExpandSectionGroups"><code class="name flex">
<span>def <span class="ident">testExpandSectionGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExpandSectionGroups(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 1.0, 2.0),
       (59, 100, 2.0, 3.0), (71, 100, 3.0, 4.0)])
  sequence.section_annotations.add(time=0, section_id=0)
  sequence.section_annotations.add(time=1, section_id=1)
  sequence.section_annotations.add(time=2, section_id=2)
  sequence.section_annotations.add(time=3, section_id=3)

  # A((BC)2D)2
  sg = sequence.section_groups.add()
  sg.sections.add(section_id=0)
  sg.num_times = 1
  sg = sequence.section_groups.add()
  sg.sections.add(section_group=music_pb2.NoteSequence.SectionGroup(
      sections=[music_pb2.NoteSequence.Section(section_id=1),
                music_pb2.NoteSequence.Section(section_id=2)],
      num_times=2))
  sg.sections.add(section_id=3)
  sg.num_times = 2

  expanded = sequences_lib.expand_section_groups(sequence)

  expected = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected, 0,
      [(60, 100, 0.0, 1.0),
       (72, 100, 1.0, 2.0),
       (59, 100, 2.0, 3.0),
       (72, 100, 3.0, 4.0),
       (59, 100, 4.0, 5.0),
       (71, 100, 5.0, 6.0),
       (72, 100, 6.0, 7.0),
       (59, 100, 7.0, 8.0),
       (72, 100, 8.0, 9.0),
       (59, 100, 9.0, 10.0),
       (71, 100, 10.0, 11.0)])
  expected.section_annotations.add(time=0, section_id=0)
  expected.section_annotations.add(time=1, section_id=1)
  expected.section_annotations.add(time=2, section_id=2)
  expected.section_annotations.add(time=3, section_id=1)
  expected.section_annotations.add(time=4, section_id=2)
  expected.section_annotations.add(time=5, section_id=3)
  expected.section_annotations.add(time=6, section_id=1)
  expected.section_annotations.add(time=7, section_id=2)
  expected.section_annotations.add(time=8, section_id=1)
  expected.section_annotations.add(time=9, section_id=2)
  expected.section_annotations.add(time=10, section_id=3)
  self.assertProtoEquals(expected, expanded)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testExpandWithoutSectionGroups"><code class="name flex">
<span>def <span class="ident">testExpandWithoutSectionGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExpandWithoutSectionGroups(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 1.0, 2.0),
       (59, 100, 2.0, 3.0), (71, 100, 3.0, 4.0)])
  sequence.section_annotations.add(time=0, section_id=0)
  sequence.section_annotations.add(time=1, section_id=1)
  sequence.section_annotations.add(time=2, section_id=2)
  sequence.section_annotations.add(time=3, section_id=3)

  expanded = sequences_lib.expand_section_groups(sequence)

  self.assertEqual(sequence, expanded)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequence"><code class="name flex">
<span>def <span class="ident">testExtractSubsequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtractSubsequence(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 1, [(2.0, 64, 127)])
  expected_subsequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_subsequence, 0,
      [(40, 45, 0.0, 1.0), (55, 120, 1.5, 1.51)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 0.5)])
  testing_lib.add_control_changes_to_sequence(
      expected_subsequence, 0, [(0.0, 64, 0), (1.5, 64, 127)])
  testing_lib.add_control_changes_to_sequence(
      expected_subsequence, 1, [(0.0, 64, 127)])
  expected_subsequence.total_time = 1.51
  expected_subsequence.subsequence_info.start_time_offset = 2.5
  expected_subsequence.subsequence_info.end_time_offset = 5.99

  subsequence = sequences_lib.extract_subsequence(sequence, 2.5, 4.75)
  subsequence.control_changes.sort(
      key=lambda cc: (cc.instrument, cc.time))
  self.assertProtoEquals(expected_subsequence, subsequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequencePastEnd"><code class="name flex">
<span>def <span class="ident">testExtractSubsequencePastEnd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtractSubsequencePastEnd(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 18.0)])

  with self.assertRaises(ValueError):
    sequences_lib.extract_subsequence(sequence, 15.0, 16.0)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequencePedalEvents"><code class="name flex">
<span>def <span class="ident">testExtractSubsequencePedalEvents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtractSubsequencePedalEvents(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0, [(60, 80, 2.5, 5.0)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 1, [(2.0, 64, 127)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 66, 0), (2.0, 66, 127), (4.0, 66, 0), (5.0, 66, 127)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 67, 10), (2.0, 67, 20), (4.0, 67, 30), (5.0, 67, 40)])
  expected_subsequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_subsequence, 0, [(60, 80, 0, 2.25)])
  testing_lib.add_control_changes_to_sequence(
      expected_subsequence, 0, [(0.0, 64, 0), (1.5, 64, 127)])
  testing_lib.add_control_changes_to_sequence(
      expected_subsequence, 1, [(0.0, 64, 127)])
  testing_lib.add_control_changes_to_sequence(
      expected_subsequence, 0, [(0.0, 66, 127), (1.5, 66, 0)])
  testing_lib.add_control_changes_to_sequence(
      expected_subsequence, 0, [(0.0, 67, 20), (1.5, 67, 30)])
  expected_subsequence.control_changes.sort(
      key=lambda cc: (cc.instrument, cc.control_number, cc.time))
  expected_subsequence.total_time = 2.25
  expected_subsequence.subsequence_info.start_time_offset = 2.5
  expected_subsequence.subsequence_info.end_time_offset = .25

  subsequence = sequences_lib.extract_subsequence(sequence, 2.5, 4.75)
  subsequence.control_changes.sort(
      key=lambda cc: (cc.instrument, cc.control_number, cc.time))
  self.assertProtoEquals(expected_subsequence, subsequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_ImplicitTempoChange"><code class="name flex">
<span>def <span class="ident">testFromNoteSequence_ImplicitTempoChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFromNoteSequence_ImplicitTempoChange(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  del self.note_sequence.tempos[:]

  # No tempo.
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Implicit tempo change.
  self.note_sequence.tempos.add(qpm=60, time=2)
  with self.assertRaises(sequences_lib.MultipleTempoError):
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_NoImplicitTempoChangeOutOfOrder"><code class="name flex">
<span>def <span class="ident">testFromNoteSequence_NoImplicitTempoChangeOutOfOrder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFromNoteSequence_NoImplicitTempoChangeOutOfOrder(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  del self.note_sequence.tempos[:]

  # No tempo.
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # No implicit tempo change, but tempos are added out of order.
  self.note_sequence.tempos.add(qpm=60, time=2)
  self.note_sequence.tempos.add(qpm=60, time=0)
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_TempoChange"><code class="name flex">
<span>def <span class="ident">testFromNoteSequence_TempoChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFromNoteSequence_TempoChange(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  del self.note_sequence.tempos[:]

  # No tempos.
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Single tempo.
  self.note_sequence.tempos.add(qpm=60, time=0)
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Multiple tempos with no change.
  self.note_sequence.tempos.add(qpm=60, time=1)
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Tempo change.
  self.note_sequence.tempos.add(qpm=120, time=2)
  with self.assertRaises(sequences_lib.MultipleTempoError):
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testInferDenseChordsForSequence"><code class="name flex">
<span>def <span class="ident">testInferDenseChordsForSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInferDenseChordsForSequence(self):
  # Test non-quantized sequence.
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 1.0, 3.0), (64, 100, 1.0, 2.0), (67, 100, 1.0, 2.0),
       (65, 100, 2.0, 3.0), (69, 100, 2.0, 3.0),
       (62, 100, 3.0, 5.0), (65, 100, 3.0, 4.0), (69, 100, 3.0, 4.0)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_chords_to_sequence(
      expected_sequence, [(&#39;C&#39;, 1.0), (&#39;F/C&#39;, 2.0), (&#39;Dm&#39;, 3.0)])
  sequences_lib.infer_dense_chords_for_sequence(sequence)
  self.assertProtoEquals(expected_sequence, sequence)

  # Test quantized sequence.
  sequence = copy.copy(self.note_sequence)
  sequence.quantization_info.steps_per_quarter = 1
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 1.1, 3.0), (64, 100, 1.0, 1.9), (67, 100, 1.0, 2.0),
       (65, 100, 2.0, 3.2), (69, 100, 2.1, 3.1),
       (62, 100, 2.9, 4.8), (65, 100, 3.0, 4.0), (69, 100, 3.0, 4.1)])
  testing_lib.add_quantized_steps_to_sequence(
      sequence,
      [(1, 3), (1, 2), (1, 2), (2, 3), (2, 3), (3, 5), (3, 4), (3, 4)])
  expected_sequence = copy.copy(sequence)
  testing_lib.add_chords_to_sequence(
      expected_sequence, [(&#39;C&#39;, 1.0), (&#39;F/C&#39;, 2.0), (&#39;Dm&#39;, 3.0)])
  testing_lib.add_quantized_chord_steps_to_sequence(
      expected_sequence, [1, 2, 3])
  sequences_lib.infer_dense_chords_for_sequence(sequence)
  self.assertProtoEquals(expected_sequence, sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testMultiTrack"><code class="name flex">
<span>def <span class="ident">testMultiTrack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMultiTrack(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 1.0, 4.0), (19, 100, 0.95, 3.0)])
  testing_lib.add_track_to_sequence(
      self.note_sequence, 3,
      [(12, 100, 1.0, 4.0), (19, 100, 2.0, 5.0)])
  testing_lib.add_track_to_sequence(
      self.note_sequence, 7,
      [(12, 100, 1.0, 5.0), (19, 100, 2.0, 4.0), (24, 100, 3.0, 3.5)])

  expected_quantized_sequence = copy.deepcopy(self.note_sequence)
  expected_quantized_sequence.quantization_info.steps_per_quarter = (
      self.steps_per_quarter)
  testing_lib.add_quantized_steps_to_sequence(
      expected_quantized_sequence,
      [(4, 16), (4, 12), (4, 16), (8, 20), (4, 20), (8, 16), (12, 14)])
  quantized_sequence = sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)
  self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollOnsetsToNoteSequence"><code class="name flex">
<span>def <span class="ident">testPianorollOnsetsToNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollOnsetsToNoteSequence(self):
  onsets = np.zeros((10, 2), np.bool)
  velocity_values = np.zeros_like(onsets, np.float32)
  onsets[0:2, 0] = True
  velocity_values[0:2, 0] = .5
  onsets[1:2, 1] = True
  velocity_values[1:2, 1] = 1
  sequence = sequences_lib.pianoroll_onsets_to_note_sequence(
      onsets, frames_per_second=10, note_duration_seconds=0.05,
      min_midi_pitch=60, velocity_values=velocity_values)

  self.assertLen(sequence.notes, 3)

  self.assertEqual(60, sequence.notes[0].pitch)
  self.assertEqual(0, sequence.notes[0].start_time)
  self.assertAlmostEqual(0.05, sequence.notes[0].end_time)
  self.assertEqual(50, sequence.notes[0].velocity)

  self.assertEqual(60, sequence.notes[1].pitch)
  self.assertEqual(0.1, sequence.notes[1].start_time)
  self.assertAlmostEqual(0.15, sequence.notes[1].end_time)
  self.assertEqual(50, sequence.notes[1].velocity)

  self.assertEqual(61, sequence.notes[2].pitch)
  self.assertEqual(0.1, sequence.notes[2].start_time)
  self.assertAlmostEqual(0.15, sequence.notes[2].end_time)
  self.assertEqual(90, sequence.notes[2].velocity)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollOnsetsToNoteSequenceFullVelocityScale"><code class="name flex">
<span>def <span class="ident">testPianorollOnsetsToNoteSequenceFullVelocityScale</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollOnsetsToNoteSequenceFullVelocityScale(self):
  onsets = np.zeros((10, 2), np.bool)
  velocity_values = np.zeros_like(onsets, np.float32)
  onsets[0:2, 0] = True
  velocity_values[0:2, 0] = .5
  onsets[1:2, 1] = True
  velocity_values[1:2, 1] = 1
  sequence = sequences_lib.pianoroll_onsets_to_note_sequence(
      onsets, frames_per_second=10, note_duration_seconds=0.05,
      min_midi_pitch=60, velocity_values=velocity_values,
      velocity_scale=127, velocity_bias=0)

  self.assertLen(sequence.notes, 3)

  self.assertEqual(60, sequence.notes[0].pitch)
  self.assertEqual(0, sequence.notes[0].start_time)
  self.assertAlmostEqual(0.05, sequence.notes[0].end_time)
  self.assertEqual(63, sequence.notes[0].velocity)

  self.assertEqual(60, sequence.notes[1].pitch)
  self.assertEqual(0.1, sequence.notes[1].start_time)
  self.assertAlmostEqual(0.15, sequence.notes[1].end_time)
  self.assertEqual(63, sequence.notes[1].velocity)

  self.assertEqual(61, sequence.notes[2].pitch)
  self.assertEqual(0.1, sequence.notes[2].start_time)
  self.assertAlmostEqual(0.15, sequence.notes[2].end_time)
  self.assertEqual(127, sequence.notes[2].velocity)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequence"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequence(self):
  # 100 frames of notes.
  frames = np.zeros((100, MIDI_PITCHES), np.bool)
  # Activate key 39 for the middle 50 frames.
  frames[25:75, 39] = True
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames, frames_per_second=DEFAULT_FRAMES_PER_SECOND, min_duration_ms=0)

  self.assertLen(sequence.notes, 1)
  self.assertEqual(39, sequence.notes[0].pitch)
  self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                   sequence.notes[0].start_time)
  self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceAllNotes"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequenceAllNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequenceAllNotes(self):
  # Test all 128 notes
  frames = np.eye(MIDI_PITCHES, dtype=np.bool)  # diagonal identity matrix
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames, frames_per_second=DEFAULT_FRAMES_PER_SECOND, min_duration_ms=0)

  self.assertLen(sequence.notes, MIDI_PITCHES)
  for i in range(MIDI_PITCHES):
    self.assertEqual(i, sequence.notes[i].pitch)
    self.assertAlmostEqual(i / DEFAULT_FRAMES_PER_SECOND,
                           sequence.notes[i].start_time)
    self.assertAlmostEqual((i+1) / DEFAULT_FRAMES_PER_SECOND,
                           sequence.notes[i].end_time)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsets"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequenceWithOnsets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequenceWithOnsets(self):
  # 100 frames of notes and onsets.
  frames = np.zeros((100, MIDI_PITCHES), np.bool)
  onsets = np.zeros((100, MIDI_PITCHES), np.bool)
  # Activate key 39 for the middle 50 frames and last 10 frames.
  frames[25:75, 39] = True
  frames[90:100, 39] = True
  # Add an onset for the first occurrence.
  onsets[25, 39] = True
  # Add an onset for a note that doesn&#39;t have an active frame.
  onsets[80, 49] = True
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames,
      frames_per_second=DEFAULT_FRAMES_PER_SECOND,
      min_duration_ms=0,
      onset_predictions=onsets)
  self.assertLen(sequence.notes, 2)

  self.assertEqual(39, sequence.notes[0].pitch)
  self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                   sequence.notes[0].start_time)
  self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

  self.assertEqual(49, sequence.notes[1].pitch)
  self.assertEqual(80 / DEFAULT_FRAMES_PER_SECOND,
                   sequence.notes[1].start_time)
  self.assertEqual(81 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[1].end_time)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity(self):
  # 100 frames of notes and onsets.
  frames = np.zeros((100, MIDI_PITCHES), np.bool)
  onsets = np.zeros((100, MIDI_PITCHES), np.bool)
  velocity_values = np.zeros((100, MIDI_PITCHES), np.float32)
  # Activate key 39 for the middle 50 frames and last 10 frames.
  frames[25:75, 39] = True
  frames[90:100, 39] = True
  onsets[25, 39] = True
  velocity_values[25, 39] = 0.5
  onsets[90, 39] = True
  velocity_values[90, 39] = 1.0
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames,
      frames_per_second=DEFAULT_FRAMES_PER_SECOND,
      min_duration_ms=0,
      onset_predictions=onsets,
      velocity_values=velocity_values,
      velocity_scale=127,
      velocity_bias=0)
  self.assertLen(sequence.notes, 2)

  self.assertEqual(39, sequence.notes[0].pitch)
  self.assertEqual(63, sequence.notes[0].velocity)
  self.assertEqual(39, sequence.notes[1].pitch)
  self.assertEqual(127, sequence.notes[1].velocity)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsAndVelocity"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequenceWithOnsetsAndVelocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequenceWithOnsetsAndVelocity(self):
  # 100 frames of notes and onsets.
  frames = np.zeros((100, MIDI_PITCHES), np.bool)
  onsets = np.zeros((100, MIDI_PITCHES), np.bool)
  velocity_values = np.zeros((100, MIDI_PITCHES), np.float32)
  # Activate key 39 for the middle 50 frames and last 10 frames.
  frames[25:75, 39] = True
  frames[90:100, 39] = True
  # Add an onset for the first occurrence with a valid velocity.
  onsets[25, 39] = True
  velocity_values[25, 39] = 0.5
  # Add an onset for the second occurrence with a NaN velocity.
  onsets[90, 39] = True
  velocity_values[90, 39] = float(&#39;nan&#39;)
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames,
      frames_per_second=DEFAULT_FRAMES_PER_SECOND,
      min_duration_ms=0,
      onset_predictions=onsets,
      velocity_values=velocity_values)
  self.assertLen(sequence.notes, 2)

  self.assertEqual(39, sequence.notes[0].pitch)
  self.assertEqual(50, sequence.notes[0].velocity)
  self.assertEqual(39, sequence.notes[1].pitch)
  self.assertEqual(0, sequence.notes[1].velocity)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsDefaultVelocity"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequenceWithOnsetsDefaultVelocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequenceWithOnsetsDefaultVelocity(self):
  # 100 frames of notes and onsets.
  frames = np.zeros((100, MIDI_PITCHES), np.bool)
  onsets = np.zeros((100, MIDI_PITCHES), np.bool)
  # Activate key 39 for the middle 50 frames and last 10 frames.
  frames[25:75, 39] = True
  frames[90:100, 39] = True
  onsets[25, 39] = True
  onsets[90, 39] = True
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames,
      frames_per_second=DEFAULT_FRAMES_PER_SECOND,
      min_duration_ms=0,
      onset_predictions=onsets,
      velocity=100)
  self.assertLen(sequence.notes, 2)

  self.assertEqual(39, sequence.notes[0].pitch)
  self.assertEqual(100, sequence.notes[0].velocity)
  self.assertEqual(39, sequence.notes[1].pitch)
  self.assertEqual(100, sequence.notes[1].velocity)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsOverlappingFrames"><code class="name flex">
<span>def <span class="ident">testPianorollToNoteSequenceWithOnsetsOverlappingFrames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPianorollToNoteSequenceWithOnsetsOverlappingFrames(self):
  # 100 frames of notes and onsets.
  frames = np.zeros((100, MIDI_PITCHES), np.bool)
  onsets = np.zeros((100, MIDI_PITCHES), np.bool)
  # Activate key 39 for the middle 50 frames.
  frames[25:75, 39] = True
  # Add multiple onsets within those frames.
  onsets[25, 39] = True
  onsets[30, 39] = True
  # If an onset lasts for multiple frames, it should create only 1 note.
  onsets[35, 39] = True
  onsets[36, 39] = True
  sequence = sequences_lib.pianoroll_to_note_sequence(
      frames,
      frames_per_second=DEFAULT_FRAMES_PER_SECOND,
      min_duration_ms=0,
      onset_predictions=onsets)
  self.assertLen(sequence.notes, 3)

  self.assertEqual(39, sequence.notes[0].pitch)
  self.assertEqual(25 / DEFAULT_FRAMES_PER_SECOND,
                   sequence.notes[0].start_time)
  self.assertEqual(30 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[0].end_time)

  self.assertEqual(39, sequence.notes[1].pitch)
  self.assertEqual(30 / DEFAULT_FRAMES_PER_SECOND,
                   sequence.notes[1].start_time)
  self.assertEqual(35 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[1].end_time)

  self.assertEqual(39, sequence.notes[2].pitch)
  self.assertEqual(35 / DEFAULT_FRAMES_PER_SECOND,
                   sequence.notes[2].start_time)
  self.assertEqual(75 / DEFAULT_FRAMES_PER_SECOND, sequence.notes[2].end_time)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence"><code class="name flex">
<span>def <span class="ident">testQuantizeNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testQuantizeNoteSequence(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      self.note_sequence,
      [(&#39;B7&#39;, 0.22), (&#39;Em9&#39;, 4.0)])
  testing_lib.add_control_changes_to_sequence(
      self.note_sequence, 0,
      [(2.0, 64, 127), (4.0, 64, 0)])

  expected_quantized_sequence = copy.deepcopy(self.note_sequence)
  expected_quantized_sequence.quantization_info.steps_per_quarter = (
      self.steps_per_quarter)
  testing_lib.add_quantized_steps_to_sequence(
      expected_quantized_sequence,
      [(0, 40), (1, 2), (10, 14), (16, 17), (19, 20)])
  testing_lib.add_quantized_chord_steps_to_sequence(
      expected_quantized_sequence, [1, 16])
  testing_lib.add_quantized_control_steps_to_sequence(
      expected_quantized_sequence, [8, 16])

  quantized_sequence = sequences_lib.quantize_note_sequence(
      self.note_sequence, steps_per_quarter=self.steps_per_quarter)

  self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequenceAbsolute"><code class="name flex">
<span>def <span class="ident">testQuantizeNoteSequenceAbsolute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testQuantizeNoteSequenceAbsolute(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      self.note_sequence,
      [(&#39;B7&#39;, 0.22), (&#39;Em9&#39;, 4.0)])
  testing_lib.add_control_changes_to_sequence(
      self.note_sequence, 0,
      [(2.0, 64, 127), (4.0, 64, 0)])

  expected_quantized_sequence = copy.deepcopy(self.note_sequence)
  expected_quantized_sequence.quantization_info.steps_per_second = 4
  testing_lib.add_quantized_steps_to_sequence(
      expected_quantized_sequence,
      [(0, 40), (1, 2), (10, 14), (16, 17), (19, 20)])
  testing_lib.add_quantized_chord_steps_to_sequence(
      expected_quantized_sequence, [1, 16])
  testing_lib.add_quantized_control_steps_to_sequence(
      expected_quantized_sequence, [8, 16])

  quantized_sequence = sequences_lib.quantize_note_sequence_absolute(
      self.note_sequence, steps_per_second=4)

  self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_ImplicitTimeSignatureChange"><code class="name flex">
<span>def <span class="ident">testQuantizeNoteSequence_ImplicitTimeSignatureChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testQuantizeNoteSequence_ImplicitTimeSignatureChange(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  del self.note_sequence.time_signatures[:]

  # No time signature.
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Implicit time signature change.
  self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
  with self.assertRaises(sequences_lib.MultipleTimeSignatureError):
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder"><code class="name flex">
<span>def <span class="ident">testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  del self.note_sequence.time_signatures[:]

  # No time signature.
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # No implicit time signature change, but time signatures are added out of
  # order.
  self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
  self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=0)
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_TimeSignatureChange"><code class="name flex">
<span>def <span class="ident">testQuantizeNoteSequence_TimeSignatureChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testQuantizeNoteSequence_TimeSignatureChange(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  del self.note_sequence.time_signatures[:]
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Single time signature.
  self.note_sequence.time_signatures.add(numerator=4, denominator=4, time=0)
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Multiple time signatures with no change.
  self.note_sequence.time_signatures.add(numerator=4, denominator=4, time=1)
  sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)

  # Time signature change.
  self.note_sequence.time_signatures.add(numerator=2, denominator=4, time=2)
  with self.assertRaises(sequences_lib.MultipleTimeSignatureError):
    sequences_lib.quantize_note_sequence(
        self.note_sequence, self.steps_per_quarter)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeToStep"><code class="name flex">
<span>def <span class="ident">testQuantizeToStep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testQuantizeToStep(self):
  self.assertEqual(
      32, sequences_lib.quantize_to_step(8.0001, 4))
  self.assertEqual(
      34, sequences_lib.quantize_to_step(8.4999, 4))
  self.assertEqual(
      33, sequences_lib.quantize_to_step(8.4999, 4, quantize_cutoff=1.0))</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testRectifyBeats"><code class="name flex">
<span>def <span class="ident">testRectifyBeats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRectifyBeats(self):
  sequence = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.25, 0.5), (62, 100, 0.5, 0.75), (64, 100, 0.75, 2.5),
       (65, 100, 1.0, 1.5), (67, 100, 1.5, 2.0)])
  testing_lib.add_beats_to_sequence(sequence, [0.5, 1.0, 2.0])

  rectified_sequence, alignment = sequences_lib.rectify_beats(
      sequence, 120)

  expected_sequence = music_pb2.NoteSequence()
  expected_sequence.tempos.add(qpm=120)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.25, 0.5), (62, 100, 0.5, 0.75), (64, 100, 0.75, 2.0),
       (65, 100, 1.0, 1.25), (67, 100, 1.25, 1.5)])
  testing_lib.add_beats_to_sequence(expected_sequence, [0.5, 1.0, 1.5])

  self.assertEqual(expected_sequence, rectified_sequence)

  expected_alignment = [
      [0.0, 0.5, 1.0, 2.0, 2.5],
      [0.0, 0.5, 1.0, 1.5, 2.0]
  ]
  self.assertEqual(expected_alignment, alignment.T.tolist())</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testRemoveRedundantData"><code class="name flex">
<span>def <span class="ident">testRemoveRedundantData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRemoveRedundantData(self):
  sequence = copy.copy(self.note_sequence)
  redundant_tempo = sequence.tempos.add()
  redundant_tempo.CopyFrom(sequence.tempos[0])
  redundant_tempo.time = 5.0
  sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
  sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
  sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
  sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
  sequence.sequence_metadata.genre.append(&#39;Classical&#39;)
  sequence.sequence_metadata.genre.append(&#39;Classical&#39;)

  fixed_sequence = sequences_lib.remove_redundant_data(sequence)

  expected_sequence = copy.copy(self.note_sequence)
  expected_sequence.sequence_metadata.composers.append(&#39;Foo&#39;)
  expected_sequence.sequence_metadata.composers.append(&#39;Bar&#39;)
  expected_sequence.sequence_metadata.genre.append(&#39;Classical&#39;)

  self.assertProtoEquals(expected_sequence, fixed_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testRemoveRedundantDataOutOfOrder"><code class="name flex">
<span>def <span class="ident">testRemoveRedundantDataOutOfOrder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRemoveRedundantDataOutOfOrder(self):
  sequence = copy.copy(self.note_sequence)
  meaningful_tempo = sequence.tempos.add()
  meaningful_tempo.time = 5.0
  meaningful_tempo.qpm = 50
  redundant_tempo = sequence.tempos.add()
  redundant_tempo.CopyFrom(sequence.tempos[0])

  expected_sequence = copy.copy(self.note_sequence)
  expected_meaningful_tempo = expected_sequence.tempos.add()
  expected_meaningful_tempo.time = 5.0
  expected_meaningful_tempo.qpm = 50

  fixed_sequence = sequences_lib.remove_redundant_data(sequence)
  self.assertProtoEquals(expected_sequence, fixed_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testRepeatSequenceToDuration"><code class="name flex">
<span>def <span class="ident">testRepeatSequenceToDuration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatSequenceToDuration(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
       (60, 100, 1.5, 2.5), (72, 100, 2.0, 3.0)])

  repeated_seq = sequences_lib.repeat_sequence_to_duration(
      sequence, duration=3)
  self.assertProtoEquals(expected_sequence, repeated_seq)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testRepeatSequenceToDurationProvidedDuration"><code class="name flex">
<span>def <span class="ident">testRepeatSequenceToDurationProvidedDuration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatSequenceToDurationProvidedDuration(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5)])

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(60, 100, 0.0, 1.0), (72, 100, 0.5, 1.5),
       (60, 100, 2.0, 3.0), (72, 100, 2.5, 3.0)])

  repeated_seq = sequences_lib.repeat_sequence_to_duration(
      sequence, duration=3, sequence_duration=2)
  self.assertProtoEquals(expected_sequence, repeated_seq)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testRounding"><code class="name flex">
<span>def <span class="ident">testRounding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRounding(self):
  testing_lib.add_track_to_sequence(
      self.note_sequence, 1,
      [(12, 100, 0.01, 0.24), (11, 100, 0.22, 0.55), (40, 100, 0.50, 0.75),
       (41, 100, 0.689, 1.18), (44, 100, 1.19, 1.69), (55, 100, 4.0, 4.01)])

  expected_quantized_sequence = copy.deepcopy(self.note_sequence)
  expected_quantized_sequence.quantization_info.steps_per_quarter = (
      self.steps_per_quarter)
  testing_lib.add_quantized_steps_to_sequence(
      expected_quantized_sequence,
      [(0, 1), (1, 2), (2, 3), (3, 5), (5, 7), (16, 17)])
  quantized_sequence = sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)
  self.assertProtoEquals(expected_quantized_sequence, quantized_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianoroll"><code class="name flex">
<span>def <span class="ident">testSequenceToPianoroll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianoroll(self):
  sequence = music_pb2.NoteSequence(total_time=1.21)
  testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.11, 1.01),
                                                  (2, 55, 0.22, 0.50),
                                                  (3, 100, 0.3, 0.8),
                                                  (2, 45, 1.0, 1.21)])

  pianoroll_tuple = sequences_lib.sequence_to_pianoroll(
      sequence, frames_per_second=10, min_pitch=1, max_pitch=2)
  output = pianoroll_tuple.active
  offset = pianoroll_tuple.offsets

  expected_pianoroll = [[0, 0],
                        [1, 0],
                        [1, 1],
                        [1, 1],
                        [1, 1],
                        [1, 0],
                        [1, 0],
                        [1, 0],
                        [1, 0],
                        [1, 0],
                        [1, 1],
                        [0, 1],
                        [0, 1]]

  expected_offsets = [[0, 0],
                      [0, 0],
                      [0, 0],
                      [0, 0],
                      [0, 0],
                      [0, 1],
                      [0, 0],
                      [0, 0],
                      [0, 0],
                      [0, 0],
                      [1, 0],
                      [0, 0],
                      [0, 1]]

  np.testing.assert_allclose(expected_pianoroll, output)
  np.testing.assert_allclose(expected_offsets, offset)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollActiveVelocities"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollActiveVelocities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollActiveVelocities(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=0.0, end_time=2.0, velocity=16)
  sequence.notes.add(pitch=61, start_time=0.0, end_time=2.0, velocity=32)
  sequence.notes.add(pitch=62, start_time=0.0, end_time=2.0, velocity=64)
  sequence.total_time = 2.0

  roll = sequences_lib.sequence_to_pianoroll(
      sequence, 1, 60, 62, max_velocity=64)
  active_velocities = roll.active_velocities

  self.assertEqual(np.all(active_velocities[0:2, 0] == 0.25), True)
  self.assertEqual(np.all(active_velocities[0:2, 1] == 0.5), True)
  self.assertEqual(np.all(active_velocities[0:2, 2] == 1.), True)
  self.assertEqual(np.all(active_velocities[2:] == 0), True)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollControlChanges"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollControlChanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollControlChanges(self):
  sequence = music_pb2.NoteSequence(total_time=2.0)
  cc = music_pb2.NoteSequence.ControlChange
  sequence.control_changes.extend([
      cc(time=0.7, control_number=3, control_value=16),
      cc(time=0.0, control_number=4, control_value=32),
      cc(time=0.5, control_number=4, control_value=32),
      cc(time=1.6, control_number=3, control_value=64),
  ])

  expected_cc_roll = np.zeros((5, 128), dtype=np.int32)
  expected_cc_roll[0:2, 4] = 33
  expected_cc_roll[1, 3] = 17
  expected_cc_roll[3, 3] = 65

  cc_roll = sequences_lib.sequence_to_pianoroll(
      sequence, frames_per_second=2, min_pitch=1, max_pitch=4).control_changes

  np.testing.assert_allclose(expected_cc_roll, cc_roll)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollFrameOccupancy"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollFrameOccupancy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollFrameOccupancy(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=1.7)
  sequence.notes.add(pitch=61, start_time=6.2, end_time=6.55)
  sequence.notes.add(pitch=62, start_time=3.4, end_time=4.3)
  sequence.total_time = 6.55

  active = sequences_lib.sequence_to_pianoroll(
      sequence, 2, 60, 62, min_frame_occupancy_for_label=0.5).active

  expected_roll = np.zeros([14, 3])
  expected_roll[2:3, 0] = 1.
  expected_roll[12:13, 1] = 1.
  expected_roll[7:9, 2] = 1.

  np.testing.assert_equal(expected_roll, active)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOnsetVelocities"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollOnsetVelocities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollOnsetVelocities(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=0.0, end_time=2.0, velocity=16)
  sequence.notes.add(pitch=61, start_time=0.0, end_time=2.0, velocity=32)
  sequence.notes.add(pitch=62, start_time=0.0, end_time=2.0, velocity=64)
  sequence.total_time = 2.0

  roll = sequences_lib.sequence_to_pianoroll(
      sequence, 1, 60, 62, max_velocity=64, onset_window=0)
  onset_velocities = roll.onset_velocities

  self.assertEqual(onset_velocities[0, 0], 0.25)
  self.assertEqual(onset_velocities[0, 1], 0.5)
  self.assertEqual(onset_velocities[0, 2], 1.)
  self.assertEqual(np.all(onset_velocities[1:] == 0), True)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOnsets"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollOnsets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollOnsets(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=2.0, end_time=5.0)
  sequence.notes.add(pitch=61, start_time=6.0, end_time=7.0)
  sequence.notes.add(pitch=62, start_time=7.0, end_time=8.0)
  sequence.total_time = 8.0

  onsets = sequences_lib.sequence_to_pianoroll(
      sequence,
      100,
      60,
      62,
      onset_mode=&#39;length_ms&#39;,
      onset_length_ms=100.0,
      onset_delay_ms=10.0,
      min_frame_occupancy_for_label=.999).onsets

  expected_roll = np.zeros([801, 3])
  expected_roll[201:211, 0] = 1.
  expected_roll[601:611, 1] = 1.
  expected_roll[701:711, 2] = 1.

  np.testing.assert_equal(expected_roll, onsets)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOverlappingNotes"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollOverlappingNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollOverlappingNotes(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=2.0)
  sequence.notes.add(pitch=60, start_time=1.2, end_time=2.0)
  sequence.notes.add(pitch=60, start_time=1.0, end_time=2.5)
  sequence.total_time = 2.5

  rolls = sequences_lib.sequence_to_pianoroll(
      sequence, frames_per_second=10, min_pitch=60, max_pitch=60,
      onset_mode=&#39;length_ms&#39;, onset_length_ms=10)

  expected_onsets = np.zeros([26, 1])
  expected_onsets[10, 0] = 1
  expected_onsets[12, 0] = 1
  np.testing.assert_equal(expected_onsets, rolls.onsets)

  expected_offsets = np.zeros([26, 1])
  expected_offsets[20, 0] = 1
  expected_offsets[25, 0] = 1
  np.testing.assert_equal(expected_offsets, rolls.offsets)

  expected_active = np.zeros([26, 1])
  expected_active[10:25, 0] = 1
  np.testing.assert_equal(expected_active, rolls.active)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollShortNotes"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollShortNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollShortNotes(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=60, start_time=1.0, end_time=1.0001)
  sequence.notes.add(pitch=60, start_time=1.2, end_time=1.2001)
  sequence.total_time = 2.5

  rolls = sequences_lib.sequence_to_pianoroll(
      sequence, frames_per_second=10, min_pitch=60, max_pitch=60,
      onset_mode=&#39;length_ms&#39;, onset_length_ms=0)

  expected_onsets = np.zeros([26, 1])
  expected_onsets[10, 0] = 1
  expected_onsets[12, 0] = 1
  np.testing.assert_equal(expected_onsets, rolls.onsets)

  expected_offsets = np.zeros([26, 1])
  expected_offsets[10, 0] = 1
  expected_offsets[12, 0] = 1
  np.testing.assert_equal(expected_offsets, rolls.offsets)

  expected_active = np.zeros([26, 1])
  expected_active[10:11, 0] = 1
  expected_active[12:13, 0] = 1
  np.testing.assert_equal(expected_active, rolls.active)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWeightedRoll"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollWeightedRoll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollWeightedRoll(self):
  sequence = music_pb2.NoteSequence(total_time=2.0)
  testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.00, 1.00),
                                                  (2, 100, 0.20, 0.50),
                                                  (3, 100, 1.20, 1.50),
                                                  (4, 100, 0.40, 2.00),
                                                  (6, 100, 0.10, 0.60)])

  onset_upweight = 5.0
  expected_roll_weights = [
      [onset_upweight, onset_upweight, 1, onset_upweight],
      [onset_upweight, onset_upweight, onset_upweight, onset_upweight],
      [1, 1, onset_upweight, onset_upweight / 1],
      [1, 1, onset_upweight, onset_upweight / 2],
      [1, 1, 1, 1],
  ]

  expected_onsets = [
      [1, 1, 0, 1],
      [1, 1, 1, 1],
      [0, 0, 1, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 0],
  ]
  roll = sequences_lib.sequence_to_pianoroll(
      sequence,
      frames_per_second=2,
      min_pitch=1,
      max_pitch=4,
      onset_upweight=onset_upweight)

  np.testing.assert_allclose(expected_roll_weights, roll.weights)
  np.testing.assert_allclose(expected_onsets, roll.onsets)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWithBlankFrameBeforeOffset"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollWithBlankFrameBeforeOffset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollWithBlankFrameBeforeOffset(self):
  sequence = music_pb2.NoteSequence(total_time=1.5)
  testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.00, 1.00),
                                                  (2, 100, 0.20, 0.50),
                                                  (1, 100, 1.20, 1.50),
                                                  (2, 100, 0.50, 1.50)])

  expected_pianoroll = [
      [1, 0],
      [1, 0],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [0, 1],
      [0, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [0, 0],
  ]

  output = sequences_lib.sequence_to_pianoroll(
      sequence, frames_per_second=10, min_pitch=1, max_pitch=2).active

  np.testing.assert_allclose(expected_pianoroll, output)

  expected_pianoroll_with_blank_frame = [
      [1, 0],
      [1, 0],
      [1, 1],
      [1, 1],
      [1, 0],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [0, 1],
      [0, 1],
      [1, 1],
      [1, 1],
      [1, 1],
      [0, 0],
  ]

  output_with_blank_frame = sequences_lib.sequence_to_pianoroll(
      sequence,
      frames_per_second=10,
      min_pitch=1,
      max_pitch=2,
      add_blank_frame_before_onset=True).active

  np.testing.assert_allclose(expected_pianoroll_with_blank_frame,
                             output_with_blank_frame)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder"><code class="name flex">
<span>def <span class="ident">testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder(self):
  sequence = music_pb2.NoteSequence(total_time=.5)
  testing_lib.add_track_to_sequence(sequence, 0, [(1, 100, 0.20, 0.50),
                                                  (1, 100, 0.00, 0.20)])

  expected_pianoroll = [
      [1],
      [0],
      [1],
      [1],
      [1],
      [0],
  ]

  output = sequences_lib.sequence_to_pianoroll(
      sequence,
      frames_per_second=10,
      min_pitch=1,
      max_pitch=1,
      add_blank_frame_before_onset=True).active

  np.testing.assert_allclose(expected_pianoroll, output)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToValuedIntervals"><code class="name flex">
<span>def <span class="ident">testSequenceToValuedIntervals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSequenceToValuedIntervals(self):
  sequence = music_pb2.NoteSequence()
  sequence.notes.add(pitch=69, start_time=1.0, end_time=2.0, velocity=80)
  # Should be dropped because it is 0 duration.
  sequence.notes.add(pitch=60, start_time=3.0, end_time=3.0, velocity=90)

  intervals, pitches, velocities = sequences_lib.sequence_to_valued_intervals(
      sequence)
  np.testing.assert_array_equal([[1., 2.]], intervals)
  np.testing.assert_array_equal([440.0], pitches)
  np.testing.assert_array_equal([80], velocities)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testShiftSequenceTimes"><code class="name flex">
<span>def <span class="ident">testShiftSequenceTimes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testShiftSequenceTimes(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 0,
      [(0.0, 64, 127), (2.0, 64, 0), (4.0, 64, 127), (5.0, 64, 0)])
  testing_lib.add_control_changes_to_sequence(
      sequence, 1, [(2.0, 64, 127)])
  testing_lib.add_pitch_bends_to_sequence(
      sequence, 1, 1, [(2.0, 100), (3.0, 0)])

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(12, 100, 1.01, 11.0), (11, 55, 1.22, 1.50), (40, 45, 3.50, 4.50),
       (55, 120, 5.0, 5.01), (52, 99, 5.75, 6.0)])
  testing_lib.add_chords_to_sequence(
      expected_sequence, [(&#39;C&#39;, 2.5), (&#39;G7&#39;, 4.0), (&#39;F&#39;, 5.8)])
  testing_lib.add_control_changes_to_sequence(
      expected_sequence, 0,
      [(1.0, 64, 127), (3.0, 64, 0), (5.0, 64, 127), (6.0, 64, 0)])
  testing_lib.add_control_changes_to_sequence(
      expected_sequence, 1, [(3.0, 64, 127)])
  testing_lib.add_pitch_bends_to_sequence(
      expected_sequence, 1, 1, [(3.0, 100), (4.0, 0)])

  expected_sequence.time_signatures[0].time = 1
  expected_sequence.tempos[0].time = 1

  shifted_sequence = sequences_lib.shift_sequence_times(sequence, 1.0)
  self.assertProtoEquals(expected_sequence, shifted_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceAtTimes"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceAtTimes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceAtTimes(self):
  # Tests splitting a NoteSequence at specified times, truncating notes.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0), (&#39;F&#39;, 4.0)])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_1, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0)])
  expected_subsequence_1.total_time = 3.0
  expected_subsequence_1.subsequence_info.end_time_offset = 5.0

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_chords_to_sequence(
      expected_subsequence_2, [(&#39;G7&#39;, 0.0)])
  expected_subsequence_2.total_time = 0.0
  expected_subsequence_2.subsequence_info.start_time_offset = 3.0
  expected_subsequence_2.subsequence_info.end_time_offset = 5.0

  expected_subsequence_3 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_3, 0,
      [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_3, [(&#39;F&#39;, 0.0)])
  expected_subsequence_3.total_time = 1.0
  expected_subsequence_3.subsequence_info.start_time_offset = 4.0
  expected_subsequence_3.subsequence_info.end_time_offset = 3.0

  subsequences = sequences_lib.split_note_sequence(
      sequence, hop_size_seconds=[3.0, 4.0])
  self.assertLen(subsequences, 3)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])
  self.assertProtoEquals(expected_subsequence_3, subsequences[2])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceCoincidentTimeChanges"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceCoincidentTimeChanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceCoincidentTimeChanges(self):
  # Tests splitting a NoteSequence on time changes for a NoteSequence that has
  # two time changes occurring simultaneously.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      time_signatures: {
        time: 2.0
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 60}
      tempos: {
        time: 2.0
        qpm: 80}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 2.0), (11, 55, 0.22, 0.50)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_1, [(&#39;C&#39;, 1.5)])
  expected_subsequence_1.total_time = 2.0
  expected_subsequence_1.subsequence_info.end_time_offset = 8.0

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 80}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0,
      [(40, 45, 0.50, 1.50), (55, 120, 2.0, 2.01), (52, 99, 2.75, 3.0)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_2, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 1.0), (&#39;F&#39;, 2.8)])
  expected_subsequence_2.total_time = 3.0
  expected_subsequence_2.subsequence_info.start_time_offset = 2.0
  expected_subsequence_2.subsequence_info.end_time_offset = 5.0

  subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
  self.assertLen(subsequences, 2)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceDuplicateTimeChanges"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceDuplicateTimeChanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceDuplicateTimeChanges(self):
  # Tests splitting a NoteSequence on time changes for a NoteSequence that has
  # duplicate time changes.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      time_signatures: {
        time: 2.0
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

  expected_subsequence = music_pb2.NoteSequence()
  expected_subsequence.CopyFrom(sequence)
  expected_subsequence.subsequence_info.start_time_offset = 0.0
  expected_subsequence.subsequence_info.end_time_offset = 0.0

  subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
  self.assertLen(subsequences, 1)
  self.assertProtoEquals(expected_subsequence, subsequences[0])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceMultipleTimeChanges"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceMultipleTimeChanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceMultipleTimeChanges(self):
  # Tests splitting a NoteSequence on time changes, truncating notes on splits
  # that occur inside notes.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      time_signatures: {
        time: 2.0
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 60}
      tempos: {
        time: 4.25
        qpm: 80}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 2.0), (11, 55, 0.22, 0.50)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_1, [(&#39;C&#39;, 1.5)])
  expected_subsequence_1.total_time = 2.0
  expected_subsequence_1.subsequence_info.end_time_offset = 8.0

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0,
      [(40, 45, 0.50, 1.50), (55, 120, 2.0, 2.01)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_2, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 1.0)])
  expected_subsequence_2.total_time = 2.01
  expected_subsequence_2.subsequence_info.start_time_offset = 2.0
  expected_subsequence_2.subsequence_info.end_time_offset = 5.99

  expected_subsequence_3 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 80}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_3, 0,
      [(52, 99, 0.5, 0.75)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_3, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.55)])
  expected_subsequence_3.total_time = 0.75
  expected_subsequence_3.subsequence_info.start_time_offset = 4.25
  expected_subsequence_3.subsequence_info.end_time_offset = 5.0

  subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
  self.assertLen(subsequences, 3)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])
  self.assertProtoEquals(expected_subsequence_3, subsequences[2])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes(self):
  # Tests splitting a NoteSequence on time changes skipping splits that occur
  # inside notes.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      time_signatures: {
        time: 2.0
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 60}
      tempos: {
        time: 4.25
        qpm: 80}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      time_signatures: {
        time: 2.0
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_1, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0)])
  expected_subsequence_1.total_time = 4.01
  expected_subsequence_1.subsequence_info.end_time_offset = 0.99

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 3
        denominator: 4}
      tempos: {
        qpm: 80}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0, [(52, 99, 0.5, 0.75)])
  testing_lib.add_chords_to_sequence(expected_subsequence_2, [
      (&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.55)])
  expected_subsequence_2.total_time = 0.75
  expected_subsequence_2.subsequence_info.start_time_offset = 4.25

  subsequences = sequences_lib.split_note_sequence_on_time_changes(
      sequence, skip_splits_inside_notes=True)
  self.assertLen(subsequences, 2)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceNoTimeChanges"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceNoTimeChanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceNoTimeChanges(self):
  # Tests splitting a NoteSequence on time changes for a NoteSequence that has
  # no time changes (time signature and tempo changes).
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.5), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.8)])

  expected_subsequence = music_pb2.NoteSequence()
  expected_subsequence.CopyFrom(sequence)
  expected_subsequence.subsequence_info.start_time_offset = 0.0
  expected_subsequence.subsequence_info.end_time_offset = 0.0

  subsequences = sequences_lib.split_note_sequence_on_time_changes(sequence)
  self.assertLen(subsequences, 1)
  self.assertProtoEquals(expected_subsequence, subsequences[0])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceOnSilence"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceOnSilence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceOnSilence(self):
  sequence = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 1.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])

  expected_subsequence_1 = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 1.0), (11, 55, 0.22, 0.50)])
  expected_subsequence_1.total_time = 1.0
  expected_subsequence_1.subsequence_info.end_time_offset = 4.0

  expected_subsequence_2 = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0,
      [(40, 45, 0.0, 1.0), (55, 120, 1.50, 1.51)])
  expected_subsequence_2.total_time = 1.51
  expected_subsequence_2.subsequence_info.start_time_offset = 2.50
  expected_subsequence_2.subsequence_info.end_time_offset = 0.99

  expected_subsequence_3 = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      expected_subsequence_3, 0,
      [(52, 99, 0.0, 0.25)])
  expected_subsequence_3.total_time = 0.25
  expected_subsequence_3.subsequence_info.start_time_offset = 4.75

  subsequences = sequences_lib.split_note_sequence_on_silence(
      sequence, gap_seconds=0.5)
  self.assertLen(subsequences, 3)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])
  self.assertProtoEquals(expected_subsequence_3, subsequences[2])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceOnSilenceInitialGap"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceOnSilenceInitialGap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceOnSilenceInitialGap(self):
  sequence = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 1.5, 2.0), (11, 55, 1.5, 3.0), (40, 45, 2.5, 3.5)])

  expected_subsequence_1 = music_pb2.NoteSequence()
  expected_subsequence_1.total_time = 0.0
  expected_subsequence_1.subsequence_info.end_time_offset = 3.5

  expected_subsequence_2 = music_pb2.NoteSequence()
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0,
      [(12, 100, 0.0, 0.5), (11, 55, 0.0, 1.5), (40, 45, 1.0, 2.0)])
  expected_subsequence_2.total_time = 2.0
  expected_subsequence_2.subsequence_info.start_time_offset = 1.5

  subsequences = sequences_lib.split_note_sequence_on_silence(
      sequence, gap_seconds=1.0)
  self.assertLen(subsequences, 2)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceSkipSplitsInsideNotes"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceSkipSplitsInsideNotes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceSkipSplitsInsideNotes(self):
  # Tests splitting a NoteSequence at regular hop size, skipping splits that
  # would have occurred inside a note.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 3.0), (&#39;F&#39;, 4.5)])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_1, [(&#39;C&#39;, 0.0), (&#39;G7&#39;, 3.0)])
  expected_subsequence_1.total_time = 3.50
  expected_subsequence_1.subsequence_info.end_time_offset = 1.5

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0,
      [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_2, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 0.5)])
  expected_subsequence_2.total_time = 1.0
  expected_subsequence_2.subsequence_info.start_time_offset = 4.0

  subsequences = sequences_lib.split_note_sequence(
      sequence, hop_size_seconds=2.0, skip_splits_inside_notes=True)
  self.assertLen(subsequences, 2)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceWithHopSize"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceWithHopSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceWithHopSize(self):
  # Tests splitting a NoteSequence at regular hop size, truncating notes.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_chords_to_sequence(
      sequence, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0), (&#39;F&#39;, 4.0)])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_1, [(&#39;C&#39;, 1.0), (&#39;G7&#39;, 2.0)])
  expected_subsequence_1.total_time = 3.0
  expected_subsequence_1.subsequence_info.end_time_offset = 5.0

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_2, 0,
      [(55, 120, 1.0, 1.01), (52, 99, 1.75, 2.0)])
  testing_lib.add_chords_to_sequence(
      expected_subsequence_2, [(&#39;G7&#39;, 0.0), (&#39;F&#39;, 1.0)])
  expected_subsequence_2.total_time = 2.0
  expected_subsequence_2.subsequence_info.start_time_offset = 3.0
  expected_subsequence_2.subsequence_info.end_time_offset = 3.0

  expected_subsequence_3 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_chords_to_sequence(
      expected_subsequence_3, [(&#39;F&#39;, 0.0)])
  expected_subsequence_3.total_time = 0.0
  expected_subsequence_3.subsequence_info.start_time_offset = 6.0
  expected_subsequence_3.subsequence_info.end_time_offset = 2.0

  subsequences = sequences_lib.split_note_sequence(
      sequence, hop_size_seconds=3.0)
  self.assertLen(subsequences, 3)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])
  self.assertProtoEquals(expected_subsequence_3, subsequences[2])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceWithStatelessEvents"><code class="name flex">
<span>def <span class="ident">testSplitNoteSequenceWithStatelessEvents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSplitNoteSequenceWithStatelessEvents(self):
  # Tests splitting a NoteSequence at specified times with stateless events.
  sequence = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 8.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  testing_lib.add_beats_to_sequence(sequence, [1.0, 2.0, 4.0])

  expected_subsequence_1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_1, 0,
      [(12, 100, 0.01, 3.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.0)])
  testing_lib.add_beats_to_sequence(expected_subsequence_1, [1.0, 2.0])
  expected_subsequence_1.total_time = 3.0
  expected_subsequence_1.subsequence_info.end_time_offset = 5.0

  expected_subsequence_2 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  expected_subsequence_2.total_time = 0.0
  expected_subsequence_2.subsequence_info.start_time_offset = 3.0
  expected_subsequence_2.subsequence_info.end_time_offset = 5.0

  expected_subsequence_3 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4}
      tempos: {
        qpm: 60}&#34;&#34;&#34;)
  testing_lib.add_track_to_sequence(
      expected_subsequence_3, 0,
      [(55, 120, 0.0, 0.01), (52, 99, 0.75, 1.0)])
  testing_lib.add_beats_to_sequence(expected_subsequence_3, [0.0])
  expected_subsequence_3.total_time = 1.0
  expected_subsequence_3.subsequence_info.start_time_offset = 4.0
  expected_subsequence_3.subsequence_info.end_time_offset = 3.0

  subsequences = sequences_lib.split_note_sequence(
      sequence, hop_size_seconds=[3.0, 4.0])
  self.assertLen(subsequences, 3)
  self.assertProtoEquals(expected_subsequence_1, subsequences[0])
  self.assertProtoEquals(expected_subsequence_2, subsequences[1])
  self.assertProtoEquals(expected_subsequence_3, subsequences[2])</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testStepsPerBar"><code class="name flex">
<span>def <span class="ident">testStepsPerBar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testStepsPerBar(self):
  qns = sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)
  self.assertEqual(16, sequences_lib.steps_per_bar_in_quantized_sequence(qns))

  self.note_sequence.time_signatures[0].numerator = 6
  self.note_sequence.time_signatures[0].denominator = 8
  qns = sequences_lib.quantize_note_sequence(
      self.note_sequence, self.steps_per_quarter)
  self.assertEqual(12.0,
                   sequences_lib.steps_per_bar_in_quantized_sequence(qns))</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testStepsPerQuarterToStepsPerSecond"><code class="name flex">
<span>def <span class="ident">testStepsPerQuarterToStepsPerSecond</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testStepsPerQuarterToStepsPerSecond(self):
  self.assertEqual(
      4.0, sequences_lib.steps_per_quarter_to_steps_per_second(4, 60.0))</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testStretchNoteSequence"><code class="name flex">
<span>def <span class="ident">testStretchNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testStretchNoteSequence(self):
  expected_stretched_sequence = copy.deepcopy(self.note_sequence)
  expected_stretched_sequence.tempos[0].qpm = 40

  testing_lib.add_track_to_sequence(
      self.note_sequence, 0,
      [(12, 100, 0.0, 10.0), (11, 55, 0.2, 0.5), (40, 45, 2.5, 3.5)])
  testing_lib.add_track_to_sequence(
      expected_stretched_sequence, 0,
      [(12, 100, 0.0, 15.0), (11, 55, 0.3, 0.75), (40, 45, 3.75, 5.25)])

  testing_lib.add_chords_to_sequence(
      self.note_sequence, [(&#39;B7&#39;, 0.5), (&#39;Em9&#39;, 2.0)])
  testing_lib.add_chords_to_sequence(
      expected_stretched_sequence, [(&#39;B7&#39;, 0.75), (&#39;Em9&#39;, 3.0)])

  prestretched_sequence = copy.deepcopy(self.note_sequence)

  stretched_sequence = sequences_lib.stretch_note_sequence(
      self.note_sequence, stretch_factor=1.5, in_place=False)
  self.assertProtoEquals(expected_stretched_sequence, stretched_sequence)

  # Make sure the proto was not modified
  self.assertProtoEquals(prestretched_sequence, self.note_sequence)

  sequences_lib.stretch_note_sequence(
      self.note_sequence, stretch_factor=1.5, in_place=True)
  self.assertProtoEquals(stretched_sequence, self.note_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testTransposeNoteSequence"><code class="name flex">
<span>def <span class="ident">testTransposeNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTransposeNoteSequence(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  sequence.text_annotations.add(
      time=1, annotation_type=CHORD_SYMBOL, text=&#39;N.C.&#39;)
  sequence.text_annotations.add(
      time=2, annotation_type=CHORD_SYMBOL, text=&#39;E7&#39;)
  sequence.key_signatures.add(
      time=0, key=music_pb2.NoteSequence.KeySignature.E,
      mode=music_pb2.NoteSequence.KeySignature.MIXOLYDIAN)

  expected_sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence, 0,
      [(13, 100, 0.01, 10.0), (12, 55, 0.22, 0.50), (41, 45, 2.50, 3.50),
       (56, 120, 4.0, 4.01), (53, 99, 4.75, 5.0)])
  expected_sequence.text_annotations.add(
      time=1, annotation_type=CHORD_SYMBOL, text=&#39;N.C.&#39;)
  expected_sequence.text_annotations.add(
      time=2, annotation_type=CHORD_SYMBOL, text=&#39;F7&#39;)
  expected_sequence.key_signatures.add(
      time=0, key=music_pb2.NoteSequence.KeySignature.F,
      mode=music_pb2.NoteSequence.KeySignature.MIXOLYDIAN)

  transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
      sequence, 1)
  self.assertProtoEquals(expected_sequence, transposed_sequence)
  self.assertEqual(delete_count, 0)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testTransposeNoteSequenceOutOfRange"><code class="name flex">
<span>def <span class="ident">testTransposeNoteSequenceOutOfRange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTransposeNoteSequenceOutOfRange(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(35, 100, 0.01, 10.0), (36, 55, 0.22, 0.50), (37, 45, 2.50, 3.50),
       (38, 120, 4.0, 4.01), (39, 99, 4.75, 5.0)])

  expected_sequence_1 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence_1, 0,
      [(39, 100, 0.01, 10.0), (40, 55, 0.22, 0.50)])

  expected_sequence_2 = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_sequence_2, 0,
      [(30, 120, 4.0, 4.01), (31, 99, 4.75, 5.0)])

  sequence_copy = copy.copy(sequence)
  transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
      sequence_copy, 4, 30, 40)
  self.assertProtoEquals(expected_sequence_1, transposed_sequence)
  self.assertEqual(delete_count, 3)

  sequence_copy = copy.copy(sequence)
  transposed_sequence, delete_count = sequences_lib.transpose_note_sequence(
      sequence_copy, -8, 30, 40)
  self.assertProtoEquals(expected_sequence_2, transposed_sequence)
  self.assertEqual(delete_count, 3)</code></pre>
</details>
</dd>
<dt id="note_seq.sequences_lib_test.SequencesLibTest.testTrimNoteSequence"><code class="name flex">
<span>def <span class="ident">testTrimNoteSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTrimNoteSequence(self):
  sequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      sequence, 0,
      [(12, 100, 0.01, 10.0), (11, 55, 0.22, 0.50), (40, 45, 2.50, 3.50),
       (55, 120, 4.0, 4.01), (52, 99, 4.75, 5.0)])
  expected_subsequence = copy.copy(self.note_sequence)
  testing_lib.add_track_to_sequence(
      expected_subsequence, 0,
      [(40, 45, 2.50, 3.50), (55, 120, 4.0, 4.01)])
  expected_subsequence.total_time = 4.75

  subsequence = sequences_lib.trim_note_sequence(sequence, 2.5, 4.75)
  self.assertProtoEquals(expected_subsequence, subsequence)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="note_seq.testing_lib.ProtoTestCase" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase">ProtoTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="note_seq.testing_lib.ProtoTestCase.assertProtoEquals" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase.assertProtoEquals">assertProtoEquals</a></code></li>
<li><code><a title="note_seq.testing_lib.ProtoTestCase.setUp" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase.setUp">setUp</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.sequences_lib_test.SequencesLibTest" href="#note_seq.sequences_lib_test.SequencesLibTest">SequencesLibTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimes" href="#note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimes">testAdjustNoteSequenceTimes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesEndBeforeStart" href="#note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesEndBeforeStart">testAdjustNoteSequenceTimesEndBeforeStart</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithNotesBeforeTimeZero" href="#note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithNotesBeforeTimeZero">testAdjustNoteSequenceTimesWithNotesBeforeTimeZero</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithSkippedNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithSkippedNotes">testAdjustNoteSequenceTimesWithSkippedNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithZeroDurations" href="#note_seq.sequences_lib_test.SequencesLibTest.testAdjustNoteSequenceTimesWithZeroDurations">testAdjustNoteSequenceTimesWithZeroDurations</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChanges" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChanges">testApplySustainControlChanges</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesExtendNotesToEnd" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesExtendNotesToEnd">testApplySustainControlChangesExtendNotesToEnd</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesExtraneousSustain" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesExtraneousSustain">testApplySustainControlChangesExtraneousSustain</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesProcessSustainBeforeNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesProcessSustainBeforeNotes">testApplySustainControlChangesProcessSustainBeforeNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesSimultaneousOnOff" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesSimultaneousOnOff">testApplySustainControlChangesSimultaneousOnOff</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithDrumNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithDrumNotes">testApplySustainControlChangesWithDrumNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithIdenticalNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithIdenticalNotes">testApplySustainControlChangesWithIdenticalNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithRepeatedNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithRepeatedNotes">testApplySustainControlChangesWithRepeatedNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithRepeatedNotesBeforeSustain" href="#note_seq.sequences_lib_test.SequencesLibTest.testApplySustainControlChangesWithRepeatedNotesBeforeSustain">testApplySustainControlChangesWithRepeatedNotesBeforeSustain</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAssertIsQuantizedNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testAssertIsQuantizedNoteSequence">testAssertIsQuantizedNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAssertIsRelativeQuantizedNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testAssertIsRelativeQuantizedNoteSequence">testAssertIsRelativeQuantizedNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceDeleteFalse" href="#note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceDeleteFalse">testAugmentNoteSequenceDeleteFalse</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceDeleteTrue" href="#note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceDeleteTrue">testAugmentNoteSequenceDeleteTrue</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceNoStretch" href="#note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceNoStretch">testAugmentNoteSequenceNoStretch</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceNoTranspose" href="#note_seq.sequences_lib_test.SequencesLibTest.testAugmentNoteSequenceNoTranspose">testAugmentNoteSequenceNoTranspose</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testClampTranspose" href="#note_seq.sequences_lib_test.SequencesLibTest.testClampTranspose">testClampTranspose</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testConcatenateSequences" href="#note_seq.sequences_lib_test.SequencesLibTest.testConcatenateSequences">testConcatenateSequences</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testConcatenateSequencesWithSpecifiedDurations" href="#note_seq.sequences_lib_test.SequencesLibTest.testConcatenateSequencesWithSpecifiedDurations">testConcatenateSequencesWithSpecifiedDurations</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testExpandSectionGroups" href="#note_seq.sequences_lib_test.SequencesLibTest.testExpandSectionGroups">testExpandSectionGroups</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testExpandWithoutSectionGroups" href="#note_seq.sequences_lib_test.SequencesLibTest.testExpandWithoutSectionGroups">testExpandWithoutSectionGroups</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequence">testExtractSubsequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequencePastEnd" href="#note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequencePastEnd">testExtractSubsequencePastEnd</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequencePedalEvents" href="#note_seq.sequences_lib_test.SequencesLibTest.testExtractSubsequencePedalEvents">testExtractSubsequencePedalEvents</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_ImplicitTempoChange" href="#note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_ImplicitTempoChange">testFromNoteSequence_ImplicitTempoChange</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_NoImplicitTempoChangeOutOfOrder" href="#note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_NoImplicitTempoChangeOutOfOrder">testFromNoteSequence_NoImplicitTempoChangeOutOfOrder</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_TempoChange" href="#note_seq.sequences_lib_test.SequencesLibTest.testFromNoteSequence_TempoChange">testFromNoteSequence_TempoChange</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testInferDenseChordsForSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testInferDenseChordsForSequence">testInferDenseChordsForSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testMultiTrack" href="#note_seq.sequences_lib_test.SequencesLibTest.testMultiTrack">testMultiTrack</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollOnsetsToNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollOnsetsToNoteSequence">testPianorollOnsetsToNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollOnsetsToNoteSequenceFullVelocityScale" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollOnsetsToNoteSequenceFullVelocityScale">testPianorollOnsetsToNoteSequenceFullVelocityScale</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequence">testPianorollToNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceAllNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceAllNotes">testPianorollToNoteSequenceAllNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsets" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsets">testPianorollToNoteSequenceWithOnsets</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity">testPianorollToNoteSequenceWithOnsetsAndFullScaleVelocity</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsAndVelocity" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsAndVelocity">testPianorollToNoteSequenceWithOnsetsAndVelocity</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsDefaultVelocity" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsDefaultVelocity">testPianorollToNoteSequenceWithOnsetsDefaultVelocity</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsOverlappingFrames" href="#note_seq.sequences_lib_test.SequencesLibTest.testPianorollToNoteSequenceWithOnsetsOverlappingFrames">testPianorollToNoteSequenceWithOnsetsOverlappingFrames</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence">testQuantizeNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequenceAbsolute" href="#note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequenceAbsolute">testQuantizeNoteSequenceAbsolute</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_ImplicitTimeSignatureChange" href="#note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_ImplicitTimeSignatureChange">testQuantizeNoteSequence_ImplicitTimeSignatureChange</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder" href="#note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder">testQuantizeNoteSequence_NoImplicitTimeSignatureChangeOutOfOrder</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_TimeSignatureChange" href="#note_seq.sequences_lib_test.SequencesLibTest.testQuantizeNoteSequence_TimeSignatureChange">testQuantizeNoteSequence_TimeSignatureChange</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testQuantizeToStep" href="#note_seq.sequences_lib_test.SequencesLibTest.testQuantizeToStep">testQuantizeToStep</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testRectifyBeats" href="#note_seq.sequences_lib_test.SequencesLibTest.testRectifyBeats">testRectifyBeats</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testRemoveRedundantData" href="#note_seq.sequences_lib_test.SequencesLibTest.testRemoveRedundantData">testRemoveRedundantData</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testRemoveRedundantDataOutOfOrder" href="#note_seq.sequences_lib_test.SequencesLibTest.testRemoveRedundantDataOutOfOrder">testRemoveRedundantDataOutOfOrder</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testRepeatSequenceToDuration" href="#note_seq.sequences_lib_test.SequencesLibTest.testRepeatSequenceToDuration">testRepeatSequenceToDuration</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testRepeatSequenceToDurationProvidedDuration" href="#note_seq.sequences_lib_test.SequencesLibTest.testRepeatSequenceToDurationProvidedDuration">testRepeatSequenceToDurationProvidedDuration</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testRounding" href="#note_seq.sequences_lib_test.SequencesLibTest.testRounding">testRounding</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianoroll" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianoroll">testSequenceToPianoroll</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollActiveVelocities" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollActiveVelocities">testSequenceToPianorollActiveVelocities</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollControlChanges" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollControlChanges">testSequenceToPianorollControlChanges</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollFrameOccupancy" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollFrameOccupancy">testSequenceToPianorollFrameOccupancy</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOnsetVelocities" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOnsetVelocities">testSequenceToPianorollOnsetVelocities</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOnsets" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOnsets">testSequenceToPianorollOnsets</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOverlappingNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollOverlappingNotes">testSequenceToPianorollOverlappingNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollShortNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollShortNotes">testSequenceToPianorollShortNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWeightedRoll" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWeightedRoll">testSequenceToPianorollWeightedRoll</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWithBlankFrameBeforeOffset" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWithBlankFrameBeforeOffset">testSequenceToPianorollWithBlankFrameBeforeOffset</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder">testSequenceToPianorollWithBlankFrameBeforeOffsetOutOfOrder</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSequenceToValuedIntervals" href="#note_seq.sequences_lib_test.SequencesLibTest.testSequenceToValuedIntervals">testSequenceToValuedIntervals</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testShiftSequenceTimes" href="#note_seq.sequences_lib_test.SequencesLibTest.testShiftSequenceTimes">testShiftSequenceTimes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceAtTimes" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceAtTimes">testSplitNoteSequenceAtTimes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceCoincidentTimeChanges" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceCoincidentTimeChanges">testSplitNoteSequenceCoincidentTimeChanges</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceDuplicateTimeChanges" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceDuplicateTimeChanges">testSplitNoteSequenceDuplicateTimeChanges</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceMultipleTimeChanges" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceMultipleTimeChanges">testSplitNoteSequenceMultipleTimeChanges</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes">testSplitNoteSequenceMultipleTimeChangesSkipSplitsInsideNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceNoTimeChanges" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceNoTimeChanges">testSplitNoteSequenceNoTimeChanges</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceOnSilence" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceOnSilence">testSplitNoteSequenceOnSilence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceOnSilenceInitialGap" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceOnSilenceInitialGap">testSplitNoteSequenceOnSilenceInitialGap</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceSkipSplitsInsideNotes" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceSkipSplitsInsideNotes">testSplitNoteSequenceSkipSplitsInsideNotes</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceWithHopSize" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceWithHopSize">testSplitNoteSequenceWithHopSize</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceWithStatelessEvents" href="#note_seq.sequences_lib_test.SequencesLibTest.testSplitNoteSequenceWithStatelessEvents">testSplitNoteSequenceWithStatelessEvents</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testStepsPerBar" href="#note_seq.sequences_lib_test.SequencesLibTest.testStepsPerBar">testStepsPerBar</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testStepsPerQuarterToStepsPerSecond" href="#note_seq.sequences_lib_test.SequencesLibTest.testStepsPerQuarterToStepsPerSecond">testStepsPerQuarterToStepsPerSecond</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testStretchNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testStretchNoteSequence">testStretchNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testTransposeNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testTransposeNoteSequence">testTransposeNoteSequence</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testTransposeNoteSequenceOutOfRange" href="#note_seq.sequences_lib_test.SequencesLibTest.testTransposeNoteSequenceOutOfRange">testTransposeNoteSequenceOutOfRange</a></code></li>
<li><code><a title="note_seq.sequences_lib_test.SequencesLibTest.testTrimNoteSequence" href="#note_seq.sequences_lib_test.SequencesLibTest.testTrimNoteSequence">testTrimNoteSequence</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>