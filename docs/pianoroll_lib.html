<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.pianoroll_lib API documentation</title>
<meta name="description" content="Utility functions for working with pianoroll sequences." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.pianoroll_lib</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for working with pianoroll sequences.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Utility functions for working with pianoroll sequences.&#34;&#34;&#34;

import copy

from note_seq import constants
from note_seq import events_lib
from note_seq import sequences_lib
from note_seq.protobuf import music_pb2
import numpy as np

DEFAULT_STEPS_PER_QUARTER = constants.DEFAULT_STEPS_PER_QUARTER
MAX_MIDI_PITCH = 108  # Max piano pitch.
MIN_MIDI_PITCH = 21  # Min piano pitch.
STANDARD_PPQ = constants.STANDARD_PPQ


class PianorollSequence(events_lib.EventSequence):
  &#34;&#34;&#34;Stores a polyphonic sequence as a pianoroll.

  Events are collections of active pitches at each step, offset from
  `min_pitch`.
  &#34;&#34;&#34;

  def __init__(self, quantized_sequence=None, events_list=None,
               steps_per_quarter=None, start_step=0, min_pitch=MIN_MIDI_PITCH,
               max_pitch=MAX_MIDI_PITCH, split_repeats=True, shift_range=False):
    &#34;&#34;&#34;Construct a PianorollSequence.

    Exactly one of `quantized_sequence` or `steps_per_quarter` must be supplied.
    At most one of `quantized_sequence` and `events_list` may be supplied.

    Args:
      quantized_sequence: an optional quantized NoteSequence proto to base
          PianorollSequence on.
      events_list: an optional list of Pianoroll events to base
          PianorollSequence on.
      steps_per_quarter: how many steps a quarter note represents. Must be
          provided if `quanitzed_sequence` not given.
      start_step: The offset of this sequence relative to the
          beginning of the source sequence. If a quantized sequence is used as
          input, only notes starting after this step will be considered.
      min_pitch: The minimum valid pitch value, inclusive.
      max_pitch: The maximum valid pitch value, inclusive.
      split_repeats: Whether to force repeated notes to have a 0-state step
          between them when initializing from a quantized NoteSequence.
      shift_range: If True, assume that the given events_list is in the full
         MIDI pitch range and needs to be shifted and filtered based on
         `min_pitch` and `max_pitch`.
    &#34;&#34;&#34;
    assert (quantized_sequence, steps_per_quarter).count(None) == 1
    assert (quantized_sequence, events_list).count(None) &gt;= 1

    self._min_pitch = min_pitch
    self._max_pitch = max_pitch

    if quantized_sequence:
      sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)
      self._events = self._from_quantized_sequence(quantized_sequence,
                                                   start_step, min_pitch,
                                                   max_pitch, split_repeats)
      self._steps_per_quarter = (
          quantized_sequence.quantization_info.steps_per_quarter)
    else:
      self._events = []
      self._steps_per_quarter = steps_per_quarter
      if events_list:
        for e in events_list:
          self.append(e, shift_range)
    self._start_step = start_step

  @property
  def start_step(self):
    return self._start_step

  @property
  def steps_per_quarter(self):
    return self._steps_per_quarter

  def set_length(self, steps, from_left=False):
    &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

    If the event sequence is not long enough, pads with silence to make the
    sequence the specified length. If it is too long, it will be truncated to
    the requested length.

    Note that this will append a STEP_END event to the end of the sequence if
    there is an unfinished step.

    Args:
      steps: How many quantized steps long the event sequence should be.
      from_left: Whether to add/remove from the left instead of right.
    &#34;&#34;&#34;
    if from_left:
      raise NotImplementedError(&#39;from_left is not supported&#39;)

    # Then trim or pad as needed.
    if self.num_steps &lt; steps:
      self._events += [()] * (steps - self.num_steps)
    elif self.num_steps &gt; steps:
      del self._events[steps:]
    assert self.num_steps == steps

  def append(self, event, shift_range=False):
    &#34;&#34;&#34;Appends the event to the end of the sequence.

    Args:
      event: The polyphonic event to append to the end.
      shift_range: If True, assume that the given event is in the full MIDI
         pitch range and needs to be shifted and filtered based on `min_pitch`
         and `max_pitch`.
    Raises:
      ValueError: If `event` is not a valid polyphonic event.
    &#34;&#34;&#34;
    if shift_range:
      event = tuple(p - self._min_pitch for p in event
                    if self._min_pitch &lt;= p &lt;= self._max_pitch)
    self._events.append(event)

  def __len__(self):
    &#34;&#34;&#34;How many events are in this sequence.

    Returns:
      Number of events as an integer.
    &#34;&#34;&#34;
    return len(self._events)

  def __getitem__(self, i):
    &#34;&#34;&#34;Returns the event at the given index.&#34;&#34;&#34;
    return self._events[i]

  def __iter__(self):
    &#34;&#34;&#34;Return an iterator over the events in this sequence.&#34;&#34;&#34;
    return iter(self._events)

  @property
  def end_step(self):
    return self.start_step + self.num_steps

  @property
  def num_steps(self):
    &#34;&#34;&#34;Returns how many steps long this sequence is.

    Returns:
      Length of the sequence in quantized steps.
    &#34;&#34;&#34;
    return len(self)

  @property
  def steps(self):
    &#34;&#34;&#34;Returns a Python list of the time step at each event in this sequence.&#34;&#34;&#34;
    return list(range(self.start_step, self.end_step))

  @staticmethod
  def _from_quantized_sequence(
      quantized_sequence, start_step, min_pitch, max_pitch, split_repeats):
    &#34;&#34;&#34;Populate self with events from the given quantized NoteSequence object.

    Args:
      quantized_sequence: A quantized NoteSequence instance.
      start_step: Start converting the sequence at this time step.
          Assumed to be the beginning of a bar.
      min_pitch: The minimum valid pitch value, inclusive.
      max_pitch: The maximum valid pitch value, inclusive.
      split_repeats: Whether to force repeated notes to have a 0-state step
          between them.

    Returns:
      A list of events.
    &#34;&#34;&#34;
    piano_roll = np.zeros(
        (quantized_sequence.total_quantized_steps - start_step,
         max_pitch - min_pitch + 1), np.bool)

    for note in quantized_sequence.notes:
      if note.quantized_start_step &lt; start_step:
        continue
      if not min_pitch &lt;= note.pitch &lt;= max_pitch:
        continue
      note_pitch_offset = note.pitch - min_pitch
      note_start_offset = note.quantized_start_step - start_step
      note_end_offset = note.quantized_end_step - start_step

      if split_repeats:
        piano_roll[note_start_offset - 1, note_pitch_offset] = 0
      piano_roll[note_start_offset:note_end_offset, note_pitch_offset] = 1

    events = [tuple(np.where(frame)[0]) for frame in piano_roll]

    return events

  def to_sequence(self,
                  velocity=100,
                  instrument=0,
                  program=0,
                  qpm=constants.DEFAULT_QUARTERS_PER_MINUTE,
                  base_note_sequence=None):
    &#34;&#34;&#34;Converts the PianorollSequence to NoteSequence proto.

    Args:
      velocity: Midi velocity to give each note. Between 1 and 127 (inclusive).
      instrument: Midi instrument to give each note.
      program: Midi program to give each note.
      qpm: Quarter notes per minute (float).
      base_note_sequence: A NoteSequence to use a starting point. Must match the
          specified qpm.

    Raises:
      ValueError: if an unknown event is encountered.

    Returns:
      A NoteSequence proto.
    &#34;&#34;&#34;
    seconds_per_step = 60.0 / qpm / self._steps_per_quarter

    sequence_start_time = self.start_step * seconds_per_step

    if base_note_sequence:
      sequence = copy.deepcopy(base_note_sequence)
      if sequence.tempos[0].qpm != qpm:
        raise ValueError(
            &#39;Supplied QPM (%d) does not match QPM of base_note_sequence (%d)&#39;
            % (qpm, sequence.tempos[0].qpm))
    else:
      sequence = music_pb2.NoteSequence()
      sequence.tempos.add().qpm = qpm
      sequence.ticks_per_quarter = STANDARD_PPQ

    step = 0
    # Keep a dictionary of open notes for each pitch.
    open_notes = {}
    for step, event in enumerate(self):
      frame_pitches = set(event)
      open_pitches = set(open_notes)

      for pitch_to_close in open_pitches - frame_pitches:
        note_to_close = open_notes[pitch_to_close]
        note_to_close.end_time = step * seconds_per_step + sequence_start_time
        del open_notes[pitch_to_close]

      for pitch_to_open in frame_pitches - open_pitches:
        new_note = sequence.notes.add()
        new_note.start_time = step * seconds_per_step + sequence_start_time
        new_note.pitch = pitch_to_open + self._min_pitch
        new_note.velocity = velocity
        new_note.instrument = instrument
        new_note.program = program
        open_notes[pitch_to_open] = new_note

    final_step = step + (len(open_notes) &gt; 0)  # pylint: disable=g-explicit-length-test
    for note_to_close in open_notes.values():
      note_to_close.end_time = (
          final_step * seconds_per_step + sequence_start_time)

    sequence.total_time = seconds_per_step * final_step + sequence_start_time
    if sequence.notes:
      assert sequence.total_time &gt;= sequence.notes[-1].end_time

    return sequence</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.pianoroll_lib.PianorollSequence"><code class="flex name class">
<span>class <span class="ident">PianorollSequence</span></span>
<span>(</span><span>quantized_sequence=None, events_list=None, steps_per_quarter=None, start_step=0, min_pitch=21, max_pitch=108, split_repeats=True, shift_range=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores a polyphonic sequence as a pianoroll.</p>
<p>Events are collections of active pitches at each step, offset from
<code>min_pitch</code>.</p>
<p>Construct a PianorollSequence.</p>
<p>Exactly one of <code>quantized_sequence</code> or <code>steps_per_quarter</code> must be supplied.
At most one of <code>quantized_sequence</code> and <code>events_list</code> may be supplied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantized_sequence</code></strong></dt>
<dd>an optional quantized NoteSequence proto to base
PianorollSequence on.</dd>
<dt><strong><code>events_list</code></strong></dt>
<dd>an optional list of Pianoroll events to base
PianorollSequence on.</dd>
<dt><strong><code>steps_per_quarter</code></strong></dt>
<dd>how many steps a quarter note represents. Must be
provided if <code>quanitzed_sequence</code> not given.</dd>
<dt><strong><code>start_step</code></strong></dt>
<dd>The offset of this sequence relative to the
beginning of the source sequence. If a quantized sequence is used as
input, only notes starting after this step will be considered.</dd>
<dt><strong><code>min_pitch</code></strong></dt>
<dd>The minimum valid pitch value, inclusive.</dd>
<dt><strong><code>max_pitch</code></strong></dt>
<dd>The maximum valid pitch value, inclusive.</dd>
<dt><strong><code>split_repeats</code></strong></dt>
<dd>Whether to force repeated notes to have a 0-state step
between them when initializing from a quantized NoteSequence.</dd>
<dt><strong><code>shift_range</code></strong></dt>
<dd>If True, assume that the given events_list is in the full
MIDI pitch range and needs to be shifted and filtered based on
<code>min_pitch</code> and <code>max_pitch</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PianorollSequence(events_lib.EventSequence):
  &#34;&#34;&#34;Stores a polyphonic sequence as a pianoroll.

  Events are collections of active pitches at each step, offset from
  `min_pitch`.
  &#34;&#34;&#34;

  def __init__(self, quantized_sequence=None, events_list=None,
               steps_per_quarter=None, start_step=0, min_pitch=MIN_MIDI_PITCH,
               max_pitch=MAX_MIDI_PITCH, split_repeats=True, shift_range=False):
    &#34;&#34;&#34;Construct a PianorollSequence.

    Exactly one of `quantized_sequence` or `steps_per_quarter` must be supplied.
    At most one of `quantized_sequence` and `events_list` may be supplied.

    Args:
      quantized_sequence: an optional quantized NoteSequence proto to base
          PianorollSequence on.
      events_list: an optional list of Pianoroll events to base
          PianorollSequence on.
      steps_per_quarter: how many steps a quarter note represents. Must be
          provided if `quanitzed_sequence` not given.
      start_step: The offset of this sequence relative to the
          beginning of the source sequence. If a quantized sequence is used as
          input, only notes starting after this step will be considered.
      min_pitch: The minimum valid pitch value, inclusive.
      max_pitch: The maximum valid pitch value, inclusive.
      split_repeats: Whether to force repeated notes to have a 0-state step
          between them when initializing from a quantized NoteSequence.
      shift_range: If True, assume that the given events_list is in the full
         MIDI pitch range and needs to be shifted and filtered based on
         `min_pitch` and `max_pitch`.
    &#34;&#34;&#34;
    assert (quantized_sequence, steps_per_quarter).count(None) == 1
    assert (quantized_sequence, events_list).count(None) &gt;= 1

    self._min_pitch = min_pitch
    self._max_pitch = max_pitch

    if quantized_sequence:
      sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)
      self._events = self._from_quantized_sequence(quantized_sequence,
                                                   start_step, min_pitch,
                                                   max_pitch, split_repeats)
      self._steps_per_quarter = (
          quantized_sequence.quantization_info.steps_per_quarter)
    else:
      self._events = []
      self._steps_per_quarter = steps_per_quarter
      if events_list:
        for e in events_list:
          self.append(e, shift_range)
    self._start_step = start_step

  @property
  def start_step(self):
    return self._start_step

  @property
  def steps_per_quarter(self):
    return self._steps_per_quarter

  def set_length(self, steps, from_left=False):
    &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

    If the event sequence is not long enough, pads with silence to make the
    sequence the specified length. If it is too long, it will be truncated to
    the requested length.

    Note that this will append a STEP_END event to the end of the sequence if
    there is an unfinished step.

    Args:
      steps: How many quantized steps long the event sequence should be.
      from_left: Whether to add/remove from the left instead of right.
    &#34;&#34;&#34;
    if from_left:
      raise NotImplementedError(&#39;from_left is not supported&#39;)

    # Then trim or pad as needed.
    if self.num_steps &lt; steps:
      self._events += [()] * (steps - self.num_steps)
    elif self.num_steps &gt; steps:
      del self._events[steps:]
    assert self.num_steps == steps

  def append(self, event, shift_range=False):
    &#34;&#34;&#34;Appends the event to the end of the sequence.

    Args:
      event: The polyphonic event to append to the end.
      shift_range: If True, assume that the given event is in the full MIDI
         pitch range and needs to be shifted and filtered based on `min_pitch`
         and `max_pitch`.
    Raises:
      ValueError: If `event` is not a valid polyphonic event.
    &#34;&#34;&#34;
    if shift_range:
      event = tuple(p - self._min_pitch for p in event
                    if self._min_pitch &lt;= p &lt;= self._max_pitch)
    self._events.append(event)

  def __len__(self):
    &#34;&#34;&#34;How many events are in this sequence.

    Returns:
      Number of events as an integer.
    &#34;&#34;&#34;
    return len(self._events)

  def __getitem__(self, i):
    &#34;&#34;&#34;Returns the event at the given index.&#34;&#34;&#34;
    return self._events[i]

  def __iter__(self):
    &#34;&#34;&#34;Return an iterator over the events in this sequence.&#34;&#34;&#34;
    return iter(self._events)

  @property
  def end_step(self):
    return self.start_step + self.num_steps

  @property
  def num_steps(self):
    &#34;&#34;&#34;Returns how many steps long this sequence is.

    Returns:
      Length of the sequence in quantized steps.
    &#34;&#34;&#34;
    return len(self)

  @property
  def steps(self):
    &#34;&#34;&#34;Returns a Python list of the time step at each event in this sequence.&#34;&#34;&#34;
    return list(range(self.start_step, self.end_step))

  @staticmethod
  def _from_quantized_sequence(
      quantized_sequence, start_step, min_pitch, max_pitch, split_repeats):
    &#34;&#34;&#34;Populate self with events from the given quantized NoteSequence object.

    Args:
      quantized_sequence: A quantized NoteSequence instance.
      start_step: Start converting the sequence at this time step.
          Assumed to be the beginning of a bar.
      min_pitch: The minimum valid pitch value, inclusive.
      max_pitch: The maximum valid pitch value, inclusive.
      split_repeats: Whether to force repeated notes to have a 0-state step
          between them.

    Returns:
      A list of events.
    &#34;&#34;&#34;
    piano_roll = np.zeros(
        (quantized_sequence.total_quantized_steps - start_step,
         max_pitch - min_pitch + 1), np.bool)

    for note in quantized_sequence.notes:
      if note.quantized_start_step &lt; start_step:
        continue
      if not min_pitch &lt;= note.pitch &lt;= max_pitch:
        continue
      note_pitch_offset = note.pitch - min_pitch
      note_start_offset = note.quantized_start_step - start_step
      note_end_offset = note.quantized_end_step - start_step

      if split_repeats:
        piano_roll[note_start_offset - 1, note_pitch_offset] = 0
      piano_roll[note_start_offset:note_end_offset, note_pitch_offset] = 1

    events = [tuple(np.where(frame)[0]) for frame in piano_roll]

    return events

  def to_sequence(self,
                  velocity=100,
                  instrument=0,
                  program=0,
                  qpm=constants.DEFAULT_QUARTERS_PER_MINUTE,
                  base_note_sequence=None):
    &#34;&#34;&#34;Converts the PianorollSequence to NoteSequence proto.

    Args:
      velocity: Midi velocity to give each note. Between 1 and 127 (inclusive).
      instrument: Midi instrument to give each note.
      program: Midi program to give each note.
      qpm: Quarter notes per minute (float).
      base_note_sequence: A NoteSequence to use a starting point. Must match the
          specified qpm.

    Raises:
      ValueError: if an unknown event is encountered.

    Returns:
      A NoteSequence proto.
    &#34;&#34;&#34;
    seconds_per_step = 60.0 / qpm / self._steps_per_quarter

    sequence_start_time = self.start_step * seconds_per_step

    if base_note_sequence:
      sequence = copy.deepcopy(base_note_sequence)
      if sequence.tempos[0].qpm != qpm:
        raise ValueError(
            &#39;Supplied QPM (%d) does not match QPM of base_note_sequence (%d)&#39;
            % (qpm, sequence.tempos[0].qpm))
    else:
      sequence = music_pb2.NoteSequence()
      sequence.tempos.add().qpm = qpm
      sequence.ticks_per_quarter = STANDARD_PPQ

    step = 0
    # Keep a dictionary of open notes for each pitch.
    open_notes = {}
    for step, event in enumerate(self):
      frame_pitches = set(event)
      open_pitches = set(open_notes)

      for pitch_to_close in open_pitches - frame_pitches:
        note_to_close = open_notes[pitch_to_close]
        note_to_close.end_time = step * seconds_per_step + sequence_start_time
        del open_notes[pitch_to_close]

      for pitch_to_open in frame_pitches - open_pitches:
        new_note = sequence.notes.add()
        new_note.start_time = step * seconds_per_step + sequence_start_time
        new_note.pitch = pitch_to_open + self._min_pitch
        new_note.velocity = velocity
        new_note.instrument = instrument
        new_note.program = program
        open_notes[pitch_to_open] = new_note

    final_step = step + (len(open_notes) &gt; 0)  # pylint: disable=g-explicit-length-test
    for note_to_close in open_notes.values():
      note_to_close.end_time = (
          final_step * seconds_per_step + sequence_start_time)

    sequence.total_time = seconds_per_step * final_step + sequence_start_time
    if sequence.notes:
      assert sequence.total_time &gt;= sequence.notes[-1].end_time

    return sequence</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.events_lib.EventSequence" href="events_lib.html#note_seq.events_lib.EventSequence">EventSequence</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="note_seq.pianoroll_lib.PianorollSequence.end_step"><code class="name">var <span class="ident">end_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_step(self):
  return self.start_step + self.num_steps</code></pre>
</details>
</dd>
<dt id="note_seq.pianoroll_lib.PianorollSequence.num_steps"><code class="name">var <span class="ident">num_steps</span></code></dt>
<dd>
<div class="desc"><p>Returns how many steps long this sequence is.</p>
<h2 id="returns">Returns</h2>
<p>Length of the sequence in quantized steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_steps(self):
  &#34;&#34;&#34;Returns how many steps long this sequence is.

  Returns:
    Length of the sequence in quantized steps.
  &#34;&#34;&#34;
  return len(self)</code></pre>
</details>
</dd>
<dt id="note_seq.pianoroll_lib.PianorollSequence.start_step"><code class="name">var <span class="ident">start_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_step(self):
  return self._start_step</code></pre>
</details>
</dd>
<dt id="note_seq.pianoroll_lib.PianorollSequence.steps"><code class="name">var <span class="ident">steps</span></code></dt>
<dd>
<div class="desc"><p>Returns a Python list of the time step at each event in this sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steps(self):
  &#34;&#34;&#34;Returns a Python list of the time step at each event in this sequence.&#34;&#34;&#34;
  return list(range(self.start_step, self.end_step))</code></pre>
</details>
</dd>
<dt id="note_seq.pianoroll_lib.PianorollSequence.steps_per_quarter"><code class="name">var <span class="ident">steps_per_quarter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steps_per_quarter(self):
  return self._steps_per_quarter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="note_seq.pianoroll_lib.PianorollSequence.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, event, shift_range=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends the event to the end of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The polyphonic event to append to the end.</dd>
<dt><strong><code>shift_range</code></strong></dt>
<dd>If True, assume that the given event is in the full MIDI
pitch range and needs to be shifted and filtered based on <code>min_pitch</code>
and <code>max_pitch</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>event</code> is not a valid polyphonic event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, event, shift_range=False):
  &#34;&#34;&#34;Appends the event to the end of the sequence.

  Args:
    event: The polyphonic event to append to the end.
    shift_range: If True, assume that the given event is in the full MIDI
       pitch range and needs to be shifted and filtered based on `min_pitch`
       and `max_pitch`.
  Raises:
    ValueError: If `event` is not a valid polyphonic event.
  &#34;&#34;&#34;
  if shift_range:
    event = tuple(p - self._min_pitch for p in event
                  if self._min_pitch &lt;= p &lt;= self._max_pitch)
  self._events.append(event)</code></pre>
</details>
</dd>
<dt id="note_seq.pianoroll_lib.PianorollSequence.set_length"><code class="name flex">
<span>def <span class="ident">set_length</span></span>(<span>self, steps, from_left=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the length of the sequence to the specified number of steps.</p>
<p>If the event sequence is not long enough, pads with silence to make the
sequence the specified length. If it is too long, it will be truncated to
the requested length.</p>
<p>Note that this will append a STEP_END event to the end of the sequence if
there is an unfinished step.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>steps</code></strong></dt>
<dd>How many quantized steps long the event sequence should be.</dd>
<dt><strong><code>from_left</code></strong></dt>
<dd>Whether to add/remove from the left instead of right.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_length(self, steps, from_left=False):
  &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

  If the event sequence is not long enough, pads with silence to make the
  sequence the specified length. If it is too long, it will be truncated to
  the requested length.

  Note that this will append a STEP_END event to the end of the sequence if
  there is an unfinished step.

  Args:
    steps: How many quantized steps long the event sequence should be.
    from_left: Whether to add/remove from the left instead of right.
  &#34;&#34;&#34;
  if from_left:
    raise NotImplementedError(&#39;from_left is not supported&#39;)

  # Then trim or pad as needed.
  if self.num_steps &lt; steps:
    self._events += [()] * (steps - self.num_steps)
  elif self.num_steps &gt; steps:
    del self._events[steps:]
  assert self.num_steps == steps</code></pre>
</details>
</dd>
<dt id="note_seq.pianoroll_lib.PianorollSequence.to_sequence"><code class="name flex">
<span>def <span class="ident">to_sequence</span></span>(<span>self, velocity=100, instrument=0, program=0, qpm=120.0, base_note_sequence=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the PianorollSequence to NoteSequence proto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>velocity</code></strong></dt>
<dd>Midi velocity to give each note. Between 1 and 127 (inclusive).</dd>
<dt><strong><code>instrument</code></strong></dt>
<dd>Midi instrument to give each note.</dd>
<dt><strong><code>program</code></strong></dt>
<dd>Midi program to give each note.</dd>
<dt><strong><code>qpm</code></strong></dt>
<dd>Quarter notes per minute (float).</dd>
<dt><strong><code>base_note_sequence</code></strong></dt>
<dd>A NoteSequence to use a starting point. Must match the
specified qpm.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if an unknown event is encountered.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A NoteSequence proto.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_sequence(self,
                velocity=100,
                instrument=0,
                program=0,
                qpm=constants.DEFAULT_QUARTERS_PER_MINUTE,
                base_note_sequence=None):
  &#34;&#34;&#34;Converts the PianorollSequence to NoteSequence proto.

  Args:
    velocity: Midi velocity to give each note. Between 1 and 127 (inclusive).
    instrument: Midi instrument to give each note.
    program: Midi program to give each note.
    qpm: Quarter notes per minute (float).
    base_note_sequence: A NoteSequence to use a starting point. Must match the
        specified qpm.

  Raises:
    ValueError: if an unknown event is encountered.

  Returns:
    A NoteSequence proto.
  &#34;&#34;&#34;
  seconds_per_step = 60.0 / qpm / self._steps_per_quarter

  sequence_start_time = self.start_step * seconds_per_step

  if base_note_sequence:
    sequence = copy.deepcopy(base_note_sequence)
    if sequence.tempos[0].qpm != qpm:
      raise ValueError(
          &#39;Supplied QPM (%d) does not match QPM of base_note_sequence (%d)&#39;
          % (qpm, sequence.tempos[0].qpm))
  else:
    sequence = music_pb2.NoteSequence()
    sequence.tempos.add().qpm = qpm
    sequence.ticks_per_quarter = STANDARD_PPQ

  step = 0
  # Keep a dictionary of open notes for each pitch.
  open_notes = {}
  for step, event in enumerate(self):
    frame_pitches = set(event)
    open_pitches = set(open_notes)

    for pitch_to_close in open_pitches - frame_pitches:
      note_to_close = open_notes[pitch_to_close]
      note_to_close.end_time = step * seconds_per_step + sequence_start_time
      del open_notes[pitch_to_close]

    for pitch_to_open in frame_pitches - open_pitches:
      new_note = sequence.notes.add()
      new_note.start_time = step * seconds_per_step + sequence_start_time
      new_note.pitch = pitch_to_open + self._min_pitch
      new_note.velocity = velocity
      new_note.instrument = instrument
      new_note.program = program
      open_notes[pitch_to_open] = new_note

  final_step = step + (len(open_notes) &gt; 0)  # pylint: disable=g-explicit-length-test
  for note_to_close in open_notes.values():
    note_to_close.end_time = (
        final_step * seconds_per_step + sequence_start_time)

  sequence.total_time = seconds_per_step * final_step + sequence_start_time
  if sequence.notes:
    assert sequence.total_time &gt;= sequence.notes[-1].end_time

  return sequence</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.pianoroll_lib.PianorollSequence" href="#note_seq.pianoroll_lib.PianorollSequence">PianorollSequence</a></code></h4>
<ul class="two-column">
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.append" href="#note_seq.pianoroll_lib.PianorollSequence.append">append</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.end_step" href="#note_seq.pianoroll_lib.PianorollSequence.end_step">end_step</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.num_steps" href="#note_seq.pianoroll_lib.PianorollSequence.num_steps">num_steps</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.set_length" href="#note_seq.pianoroll_lib.PianorollSequence.set_length">set_length</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.start_step" href="#note_seq.pianoroll_lib.PianorollSequence.start_step">start_step</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.steps" href="#note_seq.pianoroll_lib.PianorollSequence.steps">steps</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.steps_per_quarter" href="#note_seq.pianoroll_lib.PianorollSequence.steps_per_quarter">steps_per_quarter</a></code></li>
<li><code><a title="note_seq.pianoroll_lib.PianorollSequence.to_sequence" href="#note_seq.pianoroll_lib.PianorollSequence.to_sequence">to_sequence</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>