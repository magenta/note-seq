<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.abc_parser_test API documentation</title>
<meta name="description" content="Tests for abc_parser." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.abc_parser_test</code></h1>
</header>
<section id="section-intro">
<p>Tests for abc_parser.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Tests for abc_parser.&#34;&#34;&#34;

import copy
import os.path

from absl.testing import absltest
from note_seq import abc_parser
from note_seq import midi_io
from note_seq import sequences_lib
from note_seq import testing_lib
from note_seq.protobuf import music_pb2


class AbcParserTest(testing_lib.ProtoTestCase):

  def compare_accidentals(self, expected, accidentals):
    self.assertCountEqual(expected, accidentals.values())

  def compare_proto_list(self, expected, test):
    self.assertEqual(len(expected), len(test))
    for e, t in zip(expected, test):
      self.assertProtoEquals(e, t)

  def compare_to_abc2midi_and_metadata(
      self, midi_path, expected_metadata, expected_expanded_metadata, test):
    &#34;&#34;&#34;Compare parsing results to the abc2midi &#34;reference&#34; implementation.&#34;&#34;&#34;
    # Compare section annotations and groups before expanding.
    self.compare_proto_list(expected_metadata.section_annotations,
                            test.section_annotations)
    self.compare_proto_list(expected_metadata.section_groups,
                            test.section_groups)

    expanded_test = sequences_lib.expand_section_groups(test)

    abc2midi = midi_io.midi_file_to_sequence_proto(
        os.path.join(testing_lib.get_testdata_dir(), midi_path))

    # abc2midi adds a 1-tick delay to the start of every note, but we don&#39;t.
    tick_length = ((1 / (abc2midi.tempos[0].qpm / 60)) /
                   abc2midi.ticks_per_quarter)

    for note in abc2midi.notes:
      # For now, don&#39;t compare velocities.
      note.velocity = 90
      note.start_time -= tick_length

    self.compare_proto_list(abc2midi.notes, expanded_test.notes)

    self.assertEqual(abc2midi.total_time, expanded_test.total_time)

    self.compare_proto_list(abc2midi.time_signatures,
                            expanded_test.time_signatures)

    # We&#39;ve checked the notes and time signatures, now compare the rest of the
    # proto to the expected proto.
    expanded_test_copy = copy.deepcopy(expanded_test)
    del expanded_test_copy.notes[:]
    expanded_test_copy.ClearField(&#39;total_time&#39;)
    del expanded_test_copy.time_signatures[:]

    self.assertProtoEquals(expected_expanded_metadata, expanded_test_copy)

  def testParseKeyBasic(self):
    # Most examples taken from
    # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(&#39;C major&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.C, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(&#39;A minor&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.A, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;C ionian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.C, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;A aeolian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.A, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;G Mixolydian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.G, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D dorian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.DORIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;E phrygian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.E, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.PHRYGIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F Lydian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.LYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;B Locrian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.B, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.LOCRIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F# mixolydian&#39;)
    self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F#Mix&#39;)
    self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F#MIX&#39;)
    self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;Fm&#39;)
    self.compare_accidentals([-1, -1, 0, -1, -1, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

  def testParseKeyExplicit(self):
    # Most examples taken from
    # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D exp _b _e ^f&#39;)
    self.compare_accidentals([0, -1, 0, 0, -1, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  def testParseKeyAccidentals(self):
    # Most examples taken from
    # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D Phr ^f&#39;)
    self.compare_accidentals([0, -1, 0, 0, -1, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.PHRYGIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D maj =c&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D =c&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  def testParseEnglishAbc(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook_file(
        os.path.join(testing_lib.get_testdata_dir(), &#39;english.abc&#39;))
    self.assertLen(tunes, 1)
    self.assertLen(exceptions, 2)
    self.assertIsInstance(exceptions[0], abc_parser.VariantEndingError)
    self.assertIsInstance(exceptions[1], abc_parser.PartError)

    expected_metadata1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Dusty Miller, The; Binny&#39;s Jig&#34;
          artist: &#34;Trad.&#34;
          composers: &#34;Trad.&#34;
        }
        key_signatures {
          key: G
        }
        section_annotations {
          time: 0.0
          section_id: 0
        }
        section_annotations {
          time: 6.0
          section_id: 1
        }
        section_annotations {
          time: 12.0
          section_id: 2
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 2
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 2
        }
        section_groups {
          sections {
            section_id: 2
          }
          num_times: 2
        }
        &#34;&#34;&#34;)
    expected_expanded_metadata1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Dusty Miller, The; Binny&#39;s Jig&#34;
          artist: &#34;Trad.&#34;
          composers: &#34;Trad.&#34;
        }
        key_signatures {
          key: G
        }
        section_annotations {
          time: 0.0
          section_id: 0
        }
        section_annotations {
          time: 6.0
          section_id: 0
        }
        section_annotations {
          time: 12.0
          section_id: 1
        }
        section_annotations {
          time: 18.0
          section_id: 1
        }
        section_annotations {
          time: 24.0
          section_id: 2
        }
        section_annotations {
          time: 30.0
          section_id: 2
        }
        &#34;&#34;&#34;)
    self.compare_to_abc2midi_and_metadata(
        &#39;english1.mid&#39;, expected_metadata1,
        expected_expanded_metadata1, tunes[1])

    # TODO(fjord): re-enable once we support variant endings.
    # expected_ns2_metadata = testing_lib.parse_test_proto(
    #     music_pb2.NoteSequence,
    #     &#34;&#34;&#34;
    #     ticks_per_quarter: 220
    #     source_info: {
    #       source_type: SCORE_BASED
    #       encoding_type: ABC
    #       parser: MAGENTA_ABC
    #     }
    #     reference_number: 2
    #     sequence_metadata {
    #       title: &#34;Old Sir Simon the King&#34;
    #       artist: &#34;Trad.&#34;
    #       composers: &#34;Trad.&#34;
    #     }
    #     key_signatures {
    #       key: G
    #     }
    #     &#34;&#34;&#34;)
    # self.compare_to_abc2midi_and_metadata(
    #     &#39;english2.mid&#39;, expected_ns2_metadata, tunes[1])

    # TODO(fjord): re-enable once we support parts.
    # expected_ns3_metadata = testing_lib.parse_test_proto(
    #     music_pb2.NoteSequence,
    #     &#34;&#34;&#34;
    #     ticks_per_quarter: 220
    #     source_info: {
    #       source_type: SCORE_BASED
    #       encoding_type: ABC
    #       parser: MAGENTA_ABC
    #     }
    #     reference_number: 3
    #     sequence_metadata {
    #       title: &#34;William and Nancy; New Mown Hay; Legacy, The&#34;
    #       artist: &#34;Trad.&#34;
    #       composers: &#34;Trad.&#34;
    #     }
    #     key_signatures {
    #       key: G
    #     }
    #     &#34;&#34;&#34;)
    # # TODO(fjord): verify chord annotations
    # del tunes[3].text_annotations[:]
    # self.compare_to_abc2midi_and_metadata(
    #     &#39;english3.mid&#39;, expected_ns3_metadata, tunes[3])

  def testParseOctaves(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;X:1
        T:Test
        CC,&#39;,C,C&#39;c
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)

    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        notes {
          pitch: 60
          velocity: 90
          end_time: 0.25
        }
        notes {
          pitch: 48
          velocity: 90
          start_time: 0.25
          end_time: 0.5
        }
        notes {
          pitch: 48
          velocity: 90
          start_time: 0.5
          end_time: 0.75
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.75
          end_time: 1.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 1.0
          end_time: 1.25
        }
        total_time: 1.25
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testParseTempos(self):
    # Examples from http://abcnotation.com/wiki/abc:standard:v2.1#qtempo
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        L:1/4
        Q:60

        X:2
        L:1/4
        Q:C=100

        X:3
        Q:1/2=120

        X:4
        Q:1/4 3/8 1/4 3/8=40

        X:5
        Q:5/4=40

        X:6
        Q: &#34;Allegro&#34; 1/4=120

        X:7
        Q: 1/4=120 &#34;Allegro&#34;

        X:8
        Q: 3/8=50 &#34;Slowly&#34;

        X:9
        Q:&#34;Andante&#34;

        X:10
        Q:100  % define tempo using deprecated syntax
        % deprecated tempo syntax depends on unit note length. if it is
        % not defined, it is derived from the current meter.
        M:2/4  % define meter after tempo to verify that is supported.

        X:11
        Q:100  % define tempo using deprecated syntax
        % deprecated tempo syntax depends on unit note length.
        L:1/4  % define note length after tempo to verify that is supported.
        &#34;&#34;&#34;)
    self.assertLen(tunes, 11)
    self.assertEmpty(exceptions)

    self.assertEqual(60, tunes[1].tempos[0].qpm)
    self.assertEqual(100, tunes[2].tempos[0].qpm)
    self.assertEqual(240, tunes[3].tempos[0].qpm)
    self.assertEqual(200, tunes[4].tempos[0].qpm)
    self.assertEqual(200, tunes[5].tempos[0].qpm)
    self.assertEqual(120, tunes[6].tempos[0].qpm)
    self.assertEqual(120, tunes[7].tempos[0].qpm)
    self.assertEqual(75, tunes[8].tempos[0].qpm)
    self.assertEmpty(tunes[9].tempos, 0)
    self.assertEqual(25, tunes[10].tempos[0].qpm)
    self.assertEqual(100, tunes[11].tempos[0].qpm)

  def testParseBrokenRhythm(self):
    # These tunes should be equivalent.
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        M:3/4
        T:Test
        B&gt;cd B&lt;cd

        X:2
        Q:1/4=120
        L:1/4
        M:3/4
        T:Test
        B3/2c/2d B/2c3/2d

        X:3
        Q:1/4=120
        L:1/4
        M:3/4
        T:Test
        B3/c/d B/c3/d
        &#34;&#34;&#34;)
    self.assertLen(tunes, 3)
    self.assertEmpty(exceptions)

    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        time_signatures {
          numerator: 3
          denominator: 4
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.75
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.75
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 1.75
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 1.75
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        total_time: 3.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])
    expected_ns2 = copy.deepcopy(expected_ns1)
    expected_ns2.reference_number = 2
    self.assertProtoEquals(expected_ns2, tunes[2])
    expected_ns2.reference_number = 3
    self.assertProtoEquals(expected_ns2, tunes[3])

  def testSlashDuration(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;X:1
        Q:1/4=120
        L:1/4
        T:Test
        CC/C//C///C////
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)

    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.5
          end_time: 0.75
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.75
          end_time: 0.875
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.875
          end_time: 0.9375
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.9375
          end_time: 0.96875
        }
        total_time: 0.96875
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testMultiVoice(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook_file(
        os.path.join(testing_lib.get_testdata_dir(),
                     &#39;zocharti_loch.abc&#39;))
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.MultiVoiceError)

  def testRepeats(self):
    # Several equivalent versions of the same tune.
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        Bcd ::[]|[]:: Bcd ::|

        X:2
        Q:1/4=120
        L:1/4
        T:Test
        Bcd :::: Bcd ::|

        X:3
        Q:1/4=120
        L:1/4
        T:Test
        |::Bcd ::|:: Bcd ::|

        % This version contains mismatched repeat symbols.
        X:4
        Q:1/4=120
        L:1/4
        T:Test
        |::Bcd ::|: Bcd ::|

        % This version is missing a repeat symbol at the end.
        X:5
        Q:1/4=120
        L:1/4
        T:Test
        |:: Bcd ::|: Bcd |

        % Ambiguous repeat that should go to the last repeat symbol.
        X:6
        Q:1/4=120
        L:1/4
        T:Test
        |:: Bcd ::| Bcd :|

        % Ambiguous repeat that should go to the last double bar.
        X:7
        Q:1/4=120
        L:1/4
        T:Test
        |:: Bcd ::| Bcd || Bcd :|

        % Ambiguous repeat that should go to the last double bar.
        X:8
        Q:1/4=120
        L:1/4
        T:Test
        || Bcd ::| Bcd || Bcd :|

        % Ensure double bar doesn&#39;t confuse declared repeat.
        X:9
        Q:1/4=120
        L:1/4
        T:Test
        |:: B || cd ::| Bcd || |: Bcd :|

        % Mismatched repeat at the very beginning.
        X:10
        Q:1/4=120
        L:1/4
        T:Test
        :| Bcd |:: Bcd ::|
        &#34;&#34;&#34;)
    self.assertLen(tunes, 7)
    self.assertLen(exceptions, 3)
    self.assertIsInstance(exceptions[0], abc_parser.RepeatParseError)
    self.assertIsInstance(exceptions[1], abc_parser.RepeatParseError)
    self.assertIsInstance(exceptions[2], abc_parser.RepeatParseError)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        section_annotations {
          time: 0
          section_id: 0
        }
        section_annotations {
          time: 1.5
          section_id: 1
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 3
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 3
        }
        total_time: 3.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

    # Other versions are identical except for the reference number.
    expected_ns2 = copy.deepcopy(expected_ns1)
    expected_ns2.reference_number = 2
    self.assertProtoEquals(expected_ns2, tunes[2])

    expected_ns3 = copy.deepcopy(expected_ns1)
    expected_ns3.reference_number = 3
    self.assertProtoEquals(expected_ns3, tunes[3])

    # Also identical, except the last section is played only twice.
    expected_ns6 = copy.deepcopy(expected_ns1)
    expected_ns6.reference_number = 6
    expected_ns6.section_groups[-1].num_times = 2
    self.assertProtoEquals(expected_ns6, tunes[6])

    expected_ns7 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 7
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 3.0
          end_time: 3.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 3.5
          end_time: 4.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 4.0
          end_time: 4.5
        }
        section_annotations {
          time: 0
          section_id: 0
        }
        section_annotations {
          time: 1.5
          section_id: 1
        }
        section_annotations {
          time: 3.0
          section_id: 2
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 3
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 1
        }
        section_groups {
          sections {
            section_id: 2
          }
          num_times: 2
        }
        total_time: 4.5
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns7, tunes[7])

    expected_ns8 = copy.deepcopy(expected_ns7)
    expected_ns8.reference_number = 8
    self.assertProtoEquals(expected_ns8, tunes[8])

    expected_ns9 = copy.deepcopy(expected_ns7)
    expected_ns9.reference_number = 9
    self.assertProtoEquals(expected_ns9, tunes[9])

  def testInvalidCharacter(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        invalid notes!&#34;&#34;&#34;)
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.InvalidCharacterError)

  def testOneSidedRepeat(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        Bcd :| Bcd
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        section_annotations {
          time: 0
          section_id: 0
        }
        section_annotations {
          time: 1.5
          section_id: 1
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 2
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 1
        }
        total_time: 3.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testChords(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        [CEG]&#34;&#34;&#34;)
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.ChordError)

  def testChordAnnotations(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        &#34;G&#34;G
        % verify that an empty annotation doesn&#39;t cause problems.
        &#34;&#34;D
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 67
          velocity: 90
          end_time: 0.5
        }
        notes {
          pitch: 62
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        text_annotations {
          text: &#34;G&#34;
          annotation_type: CHORD_SYMBOL
        }
        text_annotations {
          time: 0.5
        }
        total_time: 1.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testNoteAccidentalsPerBar(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        GF^GGg|Gg
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 67
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 65
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 68
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 68
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 80
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 67
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        notes {
          pitch: 79
          velocity: 90
          start_time: 3.0
          end_time: 3.5
        }
        total_time: 3.5
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testDecorations(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        .a~bHcLdMeOfPgSATbucvd
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 11)

  def testSlur(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        (ABC) ( a b c ) (c (d e f) g a)
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 12)

  def testTie(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        abc-|cba c4-c4 C.-C
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 10)

  def testTuplet(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        (3abc
        &#34;&#34;&#34;)
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.TupletError)

  def testLineContinuation(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(r&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        abc \
        cba|
        abc\
         cba|
        abc cba|
        cdef|\
        \
        cedf:|
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 26)

if __name__ == &#39;__main__&#39;:
  absltest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.abc_parser_test.AbcParserTest"><code class="flex name class">
<span>class <span class="ident">AbcParserTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds assertProtoEquals from tf.test.TestCase.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbcParserTest(testing_lib.ProtoTestCase):

  def compare_accidentals(self, expected, accidentals):
    self.assertCountEqual(expected, accidentals.values())

  def compare_proto_list(self, expected, test):
    self.assertEqual(len(expected), len(test))
    for e, t in zip(expected, test):
      self.assertProtoEquals(e, t)

  def compare_to_abc2midi_and_metadata(
      self, midi_path, expected_metadata, expected_expanded_metadata, test):
    &#34;&#34;&#34;Compare parsing results to the abc2midi &#34;reference&#34; implementation.&#34;&#34;&#34;
    # Compare section annotations and groups before expanding.
    self.compare_proto_list(expected_metadata.section_annotations,
                            test.section_annotations)
    self.compare_proto_list(expected_metadata.section_groups,
                            test.section_groups)

    expanded_test = sequences_lib.expand_section_groups(test)

    abc2midi = midi_io.midi_file_to_sequence_proto(
        os.path.join(testing_lib.get_testdata_dir(), midi_path))

    # abc2midi adds a 1-tick delay to the start of every note, but we don&#39;t.
    tick_length = ((1 / (abc2midi.tempos[0].qpm / 60)) /
                   abc2midi.ticks_per_quarter)

    for note in abc2midi.notes:
      # For now, don&#39;t compare velocities.
      note.velocity = 90
      note.start_time -= tick_length

    self.compare_proto_list(abc2midi.notes, expanded_test.notes)

    self.assertEqual(abc2midi.total_time, expanded_test.total_time)

    self.compare_proto_list(abc2midi.time_signatures,
                            expanded_test.time_signatures)

    # We&#39;ve checked the notes and time signatures, now compare the rest of the
    # proto to the expected proto.
    expanded_test_copy = copy.deepcopy(expanded_test)
    del expanded_test_copy.notes[:]
    expanded_test_copy.ClearField(&#39;total_time&#39;)
    del expanded_test_copy.time_signatures[:]

    self.assertProtoEquals(expected_expanded_metadata, expanded_test_copy)

  def testParseKeyBasic(self):
    # Most examples taken from
    # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(&#39;C major&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.C, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(&#39;A minor&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.A, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;C ionian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.C, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;A aeolian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.A, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;G Mixolydian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.G, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D dorian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.DORIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;E phrygian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.E, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.PHRYGIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F Lydian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.LYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;B Locrian&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.B, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.LOCRIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F# mixolydian&#39;)
    self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F#Mix&#39;)
    self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;F#MIX&#39;)
    self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;Fm&#39;)
    self.compare_accidentals([-1, -1, 0, -1, -1, 0, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.F, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

  def testParseKeyExplicit(self):
    # Most examples taken from
    # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D exp _b _e ^f&#39;)
    self.compare_accidentals([0, -1, 0, 0, -1, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  def testParseKeyAccidentals(self):
    # Most examples taken from
    # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D Phr ^f&#39;)
    self.compare_accidentals([0, -1, 0, 0, -1, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.PHRYGIAN,
                     proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D maj =c&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

    accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
        &#39;D =c&#39;)
    self.compare_accidentals([0, 0, 0, 0, 0, 1, 0], accidentals)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
    self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  def testParseEnglishAbc(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook_file(
        os.path.join(testing_lib.get_testdata_dir(), &#39;english.abc&#39;))
    self.assertLen(tunes, 1)
    self.assertLen(exceptions, 2)
    self.assertIsInstance(exceptions[0], abc_parser.VariantEndingError)
    self.assertIsInstance(exceptions[1], abc_parser.PartError)

    expected_metadata1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Dusty Miller, The; Binny&#39;s Jig&#34;
          artist: &#34;Trad.&#34;
          composers: &#34;Trad.&#34;
        }
        key_signatures {
          key: G
        }
        section_annotations {
          time: 0.0
          section_id: 0
        }
        section_annotations {
          time: 6.0
          section_id: 1
        }
        section_annotations {
          time: 12.0
          section_id: 2
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 2
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 2
        }
        section_groups {
          sections {
            section_id: 2
          }
          num_times: 2
        }
        &#34;&#34;&#34;)
    expected_expanded_metadata1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Dusty Miller, The; Binny&#39;s Jig&#34;
          artist: &#34;Trad.&#34;
          composers: &#34;Trad.&#34;
        }
        key_signatures {
          key: G
        }
        section_annotations {
          time: 0.0
          section_id: 0
        }
        section_annotations {
          time: 6.0
          section_id: 0
        }
        section_annotations {
          time: 12.0
          section_id: 1
        }
        section_annotations {
          time: 18.0
          section_id: 1
        }
        section_annotations {
          time: 24.0
          section_id: 2
        }
        section_annotations {
          time: 30.0
          section_id: 2
        }
        &#34;&#34;&#34;)
    self.compare_to_abc2midi_and_metadata(
        &#39;english1.mid&#39;, expected_metadata1,
        expected_expanded_metadata1, tunes[1])

    # TODO(fjord): re-enable once we support variant endings.
    # expected_ns2_metadata = testing_lib.parse_test_proto(
    #     music_pb2.NoteSequence,
    #     &#34;&#34;&#34;
    #     ticks_per_quarter: 220
    #     source_info: {
    #       source_type: SCORE_BASED
    #       encoding_type: ABC
    #       parser: MAGENTA_ABC
    #     }
    #     reference_number: 2
    #     sequence_metadata {
    #       title: &#34;Old Sir Simon the King&#34;
    #       artist: &#34;Trad.&#34;
    #       composers: &#34;Trad.&#34;
    #     }
    #     key_signatures {
    #       key: G
    #     }
    #     &#34;&#34;&#34;)
    # self.compare_to_abc2midi_and_metadata(
    #     &#39;english2.mid&#39;, expected_ns2_metadata, tunes[1])

    # TODO(fjord): re-enable once we support parts.
    # expected_ns3_metadata = testing_lib.parse_test_proto(
    #     music_pb2.NoteSequence,
    #     &#34;&#34;&#34;
    #     ticks_per_quarter: 220
    #     source_info: {
    #       source_type: SCORE_BASED
    #       encoding_type: ABC
    #       parser: MAGENTA_ABC
    #     }
    #     reference_number: 3
    #     sequence_metadata {
    #       title: &#34;William and Nancy; New Mown Hay; Legacy, The&#34;
    #       artist: &#34;Trad.&#34;
    #       composers: &#34;Trad.&#34;
    #     }
    #     key_signatures {
    #       key: G
    #     }
    #     &#34;&#34;&#34;)
    # # TODO(fjord): verify chord annotations
    # del tunes[3].text_annotations[:]
    # self.compare_to_abc2midi_and_metadata(
    #     &#39;english3.mid&#39;, expected_ns3_metadata, tunes[3])

  def testParseOctaves(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;X:1
        T:Test
        CC,&#39;,C,C&#39;c
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)

    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        notes {
          pitch: 60
          velocity: 90
          end_time: 0.25
        }
        notes {
          pitch: 48
          velocity: 90
          start_time: 0.25
          end_time: 0.5
        }
        notes {
          pitch: 48
          velocity: 90
          start_time: 0.5
          end_time: 0.75
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.75
          end_time: 1.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 1.0
          end_time: 1.25
        }
        total_time: 1.25
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testParseTempos(self):
    # Examples from http://abcnotation.com/wiki/abc:standard:v2.1#qtempo
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        L:1/4
        Q:60

        X:2
        L:1/4
        Q:C=100

        X:3
        Q:1/2=120

        X:4
        Q:1/4 3/8 1/4 3/8=40

        X:5
        Q:5/4=40

        X:6
        Q: &#34;Allegro&#34; 1/4=120

        X:7
        Q: 1/4=120 &#34;Allegro&#34;

        X:8
        Q: 3/8=50 &#34;Slowly&#34;

        X:9
        Q:&#34;Andante&#34;

        X:10
        Q:100  % define tempo using deprecated syntax
        % deprecated tempo syntax depends on unit note length. if it is
        % not defined, it is derived from the current meter.
        M:2/4  % define meter after tempo to verify that is supported.

        X:11
        Q:100  % define tempo using deprecated syntax
        % deprecated tempo syntax depends on unit note length.
        L:1/4  % define note length after tempo to verify that is supported.
        &#34;&#34;&#34;)
    self.assertLen(tunes, 11)
    self.assertEmpty(exceptions)

    self.assertEqual(60, tunes[1].tempos[0].qpm)
    self.assertEqual(100, tunes[2].tempos[0].qpm)
    self.assertEqual(240, tunes[3].tempos[0].qpm)
    self.assertEqual(200, tunes[4].tempos[0].qpm)
    self.assertEqual(200, tunes[5].tempos[0].qpm)
    self.assertEqual(120, tunes[6].tempos[0].qpm)
    self.assertEqual(120, tunes[7].tempos[0].qpm)
    self.assertEqual(75, tunes[8].tempos[0].qpm)
    self.assertEmpty(tunes[9].tempos, 0)
    self.assertEqual(25, tunes[10].tempos[0].qpm)
    self.assertEqual(100, tunes[11].tempos[0].qpm)

  def testParseBrokenRhythm(self):
    # These tunes should be equivalent.
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        M:3/4
        T:Test
        B&gt;cd B&lt;cd

        X:2
        Q:1/4=120
        L:1/4
        M:3/4
        T:Test
        B3/2c/2d B/2c3/2d

        X:3
        Q:1/4=120
        L:1/4
        M:3/4
        T:Test
        B3/c/d B/c3/d
        &#34;&#34;&#34;)
    self.assertLen(tunes, 3)
    self.assertEmpty(exceptions)

    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        time_signatures {
          numerator: 3
          denominator: 4
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.75
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.75
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 1.75
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 1.75
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        total_time: 3.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])
    expected_ns2 = copy.deepcopy(expected_ns1)
    expected_ns2.reference_number = 2
    self.assertProtoEquals(expected_ns2, tunes[2])
    expected_ns2.reference_number = 3
    self.assertProtoEquals(expected_ns2, tunes[3])

  def testSlashDuration(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;X:1
        Q:1/4=120
        L:1/4
        T:Test
        CC/C//C///C////
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)

    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.5
          end_time: 0.75
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.75
          end_time: 0.875
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.875
          end_time: 0.9375
        }
        notes {
          pitch: 60
          velocity: 90
          start_time: 0.9375
          end_time: 0.96875
        }
        total_time: 0.96875
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testMultiVoice(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook_file(
        os.path.join(testing_lib.get_testdata_dir(),
                     &#39;zocharti_loch.abc&#39;))
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.MultiVoiceError)

  def testRepeats(self):
    # Several equivalent versions of the same tune.
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        Bcd ::[]|[]:: Bcd ::|

        X:2
        Q:1/4=120
        L:1/4
        T:Test
        Bcd :::: Bcd ::|

        X:3
        Q:1/4=120
        L:1/4
        T:Test
        |::Bcd ::|:: Bcd ::|

        % This version contains mismatched repeat symbols.
        X:4
        Q:1/4=120
        L:1/4
        T:Test
        |::Bcd ::|: Bcd ::|

        % This version is missing a repeat symbol at the end.
        X:5
        Q:1/4=120
        L:1/4
        T:Test
        |:: Bcd ::|: Bcd |

        % Ambiguous repeat that should go to the last repeat symbol.
        X:6
        Q:1/4=120
        L:1/4
        T:Test
        |:: Bcd ::| Bcd :|

        % Ambiguous repeat that should go to the last double bar.
        X:7
        Q:1/4=120
        L:1/4
        T:Test
        |:: Bcd ::| Bcd || Bcd :|

        % Ambiguous repeat that should go to the last double bar.
        X:8
        Q:1/4=120
        L:1/4
        T:Test
        || Bcd ::| Bcd || Bcd :|

        % Ensure double bar doesn&#39;t confuse declared repeat.
        X:9
        Q:1/4=120
        L:1/4
        T:Test
        |:: B || cd ::| Bcd || |: Bcd :|

        % Mismatched repeat at the very beginning.
        X:10
        Q:1/4=120
        L:1/4
        T:Test
        :| Bcd |:: Bcd ::|
        &#34;&#34;&#34;)
    self.assertLen(tunes, 7)
    self.assertLen(exceptions, 3)
    self.assertIsInstance(exceptions[0], abc_parser.RepeatParseError)
    self.assertIsInstance(exceptions[1], abc_parser.RepeatParseError)
    self.assertIsInstance(exceptions[2], abc_parser.RepeatParseError)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        section_annotations {
          time: 0
          section_id: 0
        }
        section_annotations {
          time: 1.5
          section_id: 1
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 3
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 3
        }
        total_time: 3.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

    # Other versions are identical except for the reference number.
    expected_ns2 = copy.deepcopy(expected_ns1)
    expected_ns2.reference_number = 2
    self.assertProtoEquals(expected_ns2, tunes[2])

    expected_ns3 = copy.deepcopy(expected_ns1)
    expected_ns3.reference_number = 3
    self.assertProtoEquals(expected_ns3, tunes[3])

    # Also identical, except the last section is played only twice.
    expected_ns6 = copy.deepcopy(expected_ns1)
    expected_ns6.reference_number = 6
    expected_ns6.section_groups[-1].num_times = 2
    self.assertProtoEquals(expected_ns6, tunes[6])

    expected_ns7 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 7
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 3.0
          end_time: 3.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 3.5
          end_time: 4.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 4.0
          end_time: 4.5
        }
        section_annotations {
          time: 0
          section_id: 0
        }
        section_annotations {
          time: 1.5
          section_id: 1
        }
        section_annotations {
          time: 3.0
          section_id: 2
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 3
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 1
        }
        section_groups {
          sections {
            section_id: 2
          }
          num_times: 2
        }
        total_time: 4.5
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns7, tunes[7])

    expected_ns8 = copy.deepcopy(expected_ns7)
    expected_ns8.reference_number = 8
    self.assertProtoEquals(expected_ns8, tunes[8])

    expected_ns9 = copy.deepcopy(expected_ns7)
    expected_ns9.reference_number = 9
    self.assertProtoEquals(expected_ns9, tunes[9])

  def testInvalidCharacter(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        invalid notes!&#34;&#34;&#34;)
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.InvalidCharacterError)

  def testOneSidedRepeat(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        Bcd :| Bcd
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 71
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 72
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 74
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        section_annotations {
          time: 0
          section_id: 0
        }
        section_annotations {
          time: 1.5
          section_id: 1
        }
        section_groups {
          sections {
            section_id: 0
          }
          num_times: 2
        }
        section_groups {
          sections {
            section_id: 1
          }
          num_times: 1
        }
        total_time: 3.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testChords(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        [CEG]&#34;&#34;&#34;)
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.ChordError)

  def testChordAnnotations(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        &#34;G&#34;G
        % verify that an empty annotation doesn&#39;t cause problems.
        &#34;&#34;D
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 67
          velocity: 90
          end_time: 0.5
        }
        notes {
          pitch: 62
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        text_annotations {
          text: &#34;G&#34;
          annotation_type: CHORD_SYMBOL
        }
        text_annotations {
          time: 0.5
        }
        total_time: 1.0
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testNoteAccidentalsPerBar(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        GF^GGg|Gg
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    expected_ns1 = testing_lib.parse_test_proto(
        music_pb2.NoteSequence,
        &#34;&#34;&#34;
        ticks_per_quarter: 220
        source_info: {
          source_type: SCORE_BASED
          encoding_type: ABC
          parser: MAGENTA_ABC
        }
        reference_number: 1
        sequence_metadata {
          title: &#34;Test&#34;
        }
        tempos {
          qpm: 120
        }
        notes {
          pitch: 67
          velocity: 90
          start_time: 0.0
          end_time: 0.5
        }
        notes {
          pitch: 65
          velocity: 90
          start_time: 0.5
          end_time: 1.0
        }
        notes {
          pitch: 68
          velocity: 90
          start_time: 1.0
          end_time: 1.5
        }
        notes {
          pitch: 68
          velocity: 90
          start_time: 1.5
          end_time: 2.0
        }
        notes {
          pitch: 80
          velocity: 90
          start_time: 2.0
          end_time: 2.5
        }
        notes {
          pitch: 67
          velocity: 90
          start_time: 2.5
          end_time: 3.0
        }
        notes {
          pitch: 79
          velocity: 90
          start_time: 3.0
          end_time: 3.5
        }
        total_time: 3.5
        &#34;&#34;&#34;)
    self.assertProtoEquals(expected_ns1, tunes[1])

  def testDecorations(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        .a~bHcLdMeOfPgSATbucvd
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 11)

  def testSlur(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        (ABC) ( a b c ) (c (d e f) g a)
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 12)

  def testTie(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        abc-|cba c4-c4 C.-C
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 10)

  def testTuplet(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        (3abc
        &#34;&#34;&#34;)
    self.assertEmpty(tunes)
    self.assertLen(exceptions, 1)
    self.assertIsInstance(exceptions[0], abc_parser.TupletError)

  def testLineContinuation(self):
    tunes, exceptions = abc_parser.parse_abc_tunebook(r&#34;&#34;&#34;
        X:1
        Q:1/4=120
        L:1/4
        T:Test
        abc \
        cba|
        abc\
         cba|
        abc cba|
        cdef|\
        \
        cedf:|
        &#34;&#34;&#34;)
    self.assertLen(tunes, 1)
    self.assertEmpty(exceptions)
    self.assertLen(tunes[1].notes, 26)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.testing_lib.ProtoTestCase" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase">ProtoTestCase</a></li>
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.abc_parser_test.AbcParserTest.compare_accidentals"><code class="name flex">
<span>def <span class="ident">compare_accidentals</span></span>(<span>self, expected, accidentals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_accidentals(self, expected, accidentals):
  self.assertCountEqual(expected, accidentals.values())</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.compare_proto_list"><code class="name flex">
<span>def <span class="ident">compare_proto_list</span></span>(<span>self, expected, test)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_proto_list(self, expected, test):
  self.assertEqual(len(expected), len(test))
  for e, t in zip(expected, test):
    self.assertProtoEquals(e, t)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.compare_to_abc2midi_and_metadata"><code class="name flex">
<span>def <span class="ident">compare_to_abc2midi_and_metadata</span></span>(<span>self, midi_path, expected_metadata, expected_expanded_metadata, test)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare parsing results to the abc2midi "reference" implementation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_to_abc2midi_and_metadata(
    self, midi_path, expected_metadata, expected_expanded_metadata, test):
  &#34;&#34;&#34;Compare parsing results to the abc2midi &#34;reference&#34; implementation.&#34;&#34;&#34;
  # Compare section annotations and groups before expanding.
  self.compare_proto_list(expected_metadata.section_annotations,
                          test.section_annotations)
  self.compare_proto_list(expected_metadata.section_groups,
                          test.section_groups)

  expanded_test = sequences_lib.expand_section_groups(test)

  abc2midi = midi_io.midi_file_to_sequence_proto(
      os.path.join(testing_lib.get_testdata_dir(), midi_path))

  # abc2midi adds a 1-tick delay to the start of every note, but we don&#39;t.
  tick_length = ((1 / (abc2midi.tempos[0].qpm / 60)) /
                 abc2midi.ticks_per_quarter)

  for note in abc2midi.notes:
    # For now, don&#39;t compare velocities.
    note.velocity = 90
    note.start_time -= tick_length

  self.compare_proto_list(abc2midi.notes, expanded_test.notes)

  self.assertEqual(abc2midi.total_time, expanded_test.total_time)

  self.compare_proto_list(abc2midi.time_signatures,
                          expanded_test.time_signatures)

  # We&#39;ve checked the notes and time signatures, now compare the rest of the
  # proto to the expected proto.
  expanded_test_copy = copy.deepcopy(expanded_test)
  del expanded_test_copy.notes[:]
  expanded_test_copy.ClearField(&#39;total_time&#39;)
  del expanded_test_copy.time_signatures[:]

  self.assertProtoEquals(expected_expanded_metadata, expanded_test_copy)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testChordAnnotations"><code class="name flex">
<span>def <span class="ident">testChordAnnotations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testChordAnnotations(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      &#34;G&#34;G
      % verify that an empty annotation doesn&#39;t cause problems.
      &#34;&#34;D
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 67
        velocity: 90
        end_time: 0.5
      }
      notes {
        pitch: 62
        velocity: 90
        start_time: 0.5
        end_time: 1.0
      }
      text_annotations {
        text: &#34;G&#34;
        annotation_type: CHORD_SYMBOL
      }
      text_annotations {
        time: 0.5
      }
      total_time: 1.0
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testChords"><code class="name flex">
<span>def <span class="ident">testChords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testChords(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      [CEG]&#34;&#34;&#34;)
  self.assertEmpty(tunes)
  self.assertLen(exceptions, 1)
  self.assertIsInstance(exceptions[0], abc_parser.ChordError)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testDecorations"><code class="name flex">
<span>def <span class="ident">testDecorations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testDecorations(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      .a~bHcLdMeOfPgSATbucvd
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  self.assertLen(tunes[1].notes, 11)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testInvalidCharacter"><code class="name flex">
<span>def <span class="ident">testInvalidCharacter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidCharacter(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      invalid notes!&#34;&#34;&#34;)
  self.assertEmpty(tunes)
  self.assertLen(exceptions, 1)
  self.assertIsInstance(exceptions[0], abc_parser.InvalidCharacterError)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testLineContinuation"><code class="name flex">
<span>def <span class="ident">testLineContinuation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testLineContinuation(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(r&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      abc \
      cba|
      abc\
       cba|
      abc cba|
      cdef|\
      \
      cedf:|
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  self.assertLen(tunes[1].notes, 26)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testMultiVoice"><code class="name flex">
<span>def <span class="ident">testMultiVoice</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMultiVoice(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook_file(
      os.path.join(testing_lib.get_testdata_dir(),
                   &#39;zocharti_loch.abc&#39;))
  self.assertEmpty(tunes)
  self.assertLen(exceptions, 1)
  self.assertIsInstance(exceptions[0], abc_parser.MultiVoiceError)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testNoteAccidentalsPerBar"><code class="name flex">
<span>def <span class="ident">testNoteAccidentalsPerBar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNoteAccidentalsPerBar(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      GF^GGg|Gg
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 67
        velocity: 90
        start_time: 0.0
        end_time: 0.5
      }
      notes {
        pitch: 65
        velocity: 90
        start_time: 0.5
        end_time: 1.0
      }
      notes {
        pitch: 68
        velocity: 90
        start_time: 1.0
        end_time: 1.5
      }
      notes {
        pitch: 68
        velocity: 90
        start_time: 1.5
        end_time: 2.0
      }
      notes {
        pitch: 80
        velocity: 90
        start_time: 2.0
        end_time: 2.5
      }
      notes {
        pitch: 67
        velocity: 90
        start_time: 2.5
        end_time: 3.0
      }
      notes {
        pitch: 79
        velocity: 90
        start_time: 3.0
        end_time: 3.5
      }
      total_time: 3.5
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testOneSidedRepeat"><code class="name flex">
<span>def <span class="ident">testOneSidedRepeat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneSidedRepeat(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      Bcd :| Bcd
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 0.0
        end_time: 0.5
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 0.5
        end_time: 1.0
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 1.0
        end_time: 1.5
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 1.5
        end_time: 2.0
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 2.0
        end_time: 2.5
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 2.5
        end_time: 3.0
      }
      section_annotations {
        time: 0
        section_id: 0
      }
      section_annotations {
        time: 1.5
        section_id: 1
      }
      section_groups {
        sections {
          section_id: 0
        }
        num_times: 2
      }
      section_groups {
        sections {
          section_id: 1
        }
        num_times: 1
      }
      total_time: 3.0
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseBrokenRhythm"><code class="name flex">
<span>def <span class="ident">testParseBrokenRhythm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseBrokenRhythm(self):
  # These tunes should be equivalent.
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      M:3/4
      T:Test
      B&gt;cd B&lt;cd

      X:2
      Q:1/4=120
      L:1/4
      M:3/4
      T:Test
      B3/2c/2d B/2c3/2d

      X:3
      Q:1/4=120
      L:1/4
      M:3/4
      T:Test
      B3/c/d B/c3/d
      &#34;&#34;&#34;)
  self.assertLen(tunes, 3)
  self.assertEmpty(exceptions)

  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      time_signatures {
        numerator: 3
        denominator: 4
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 0.0
        end_time: 0.75
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 0.75
        end_time: 1.0
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 1.0
        end_time: 1.5
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 1.5
        end_time: 1.75
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 1.75
        end_time: 2.5
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 2.5
        end_time: 3.0
      }
      total_time: 3.0
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])
  expected_ns2 = copy.deepcopy(expected_ns1)
  expected_ns2.reference_number = 2
  self.assertProtoEquals(expected_ns2, tunes[2])
  expected_ns2.reference_number = 3
  self.assertProtoEquals(expected_ns2, tunes[3])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseEnglishAbc"><code class="name flex">
<span>def <span class="ident">testParseEnglishAbc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseEnglishAbc(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook_file(
      os.path.join(testing_lib.get_testdata_dir(), &#39;english.abc&#39;))
  self.assertLen(tunes, 1)
  self.assertLen(exceptions, 2)
  self.assertIsInstance(exceptions[0], abc_parser.VariantEndingError)
  self.assertIsInstance(exceptions[1], abc_parser.PartError)

  expected_metadata1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Dusty Miller, The; Binny&#39;s Jig&#34;
        artist: &#34;Trad.&#34;
        composers: &#34;Trad.&#34;
      }
      key_signatures {
        key: G
      }
      section_annotations {
        time: 0.0
        section_id: 0
      }
      section_annotations {
        time: 6.0
        section_id: 1
      }
      section_annotations {
        time: 12.0
        section_id: 2
      }
      section_groups {
        sections {
          section_id: 0
        }
        num_times: 2
      }
      section_groups {
        sections {
          section_id: 1
        }
        num_times: 2
      }
      section_groups {
        sections {
          section_id: 2
        }
        num_times: 2
      }
      &#34;&#34;&#34;)
  expected_expanded_metadata1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Dusty Miller, The; Binny&#39;s Jig&#34;
        artist: &#34;Trad.&#34;
        composers: &#34;Trad.&#34;
      }
      key_signatures {
        key: G
      }
      section_annotations {
        time: 0.0
        section_id: 0
      }
      section_annotations {
        time: 6.0
        section_id: 0
      }
      section_annotations {
        time: 12.0
        section_id: 1
      }
      section_annotations {
        time: 18.0
        section_id: 1
      }
      section_annotations {
        time: 24.0
        section_id: 2
      }
      section_annotations {
        time: 30.0
        section_id: 2
      }
      &#34;&#34;&#34;)
  self.compare_to_abc2midi_and_metadata(
      &#39;english1.mid&#39;, expected_metadata1,
      expected_expanded_metadata1, tunes[1])

  # TODO(fjord): re-enable once we support variant endings.
  # expected_ns2_metadata = testing_lib.parse_test_proto(
  #     music_pb2.NoteSequence,
  #     &#34;&#34;&#34;
  #     ticks_per_quarter: 220
  #     source_info: {
  #       source_type: SCORE_BASED
  #       encoding_type: ABC
  #       parser: MAGENTA_ABC
  #     }
  #     reference_number: 2
  #     sequence_metadata {
  #       title: &#34;Old Sir Simon the King&#34;
  #       artist: &#34;Trad.&#34;
  #       composers: &#34;Trad.&#34;
  #     }
  #     key_signatures {
  #       key: G
  #     }
  #     &#34;&#34;&#34;)
  # self.compare_to_abc2midi_and_metadata(
  #     &#39;english2.mid&#39;, expected_ns2_metadata, tunes[1])

  # TODO(fjord): re-enable once we support parts.
  # expected_ns3_metadata = testing_lib.parse_test_proto(
  #     music_pb2.NoteSequence,
  #     &#34;&#34;&#34;
  #     ticks_per_quarter: 220
  #     source_info: {
  #       source_type: SCORE_BASED
  #       encoding_type: ABC
  #       parser: MAGENTA_ABC
  #     }
  #     reference_number: 3
  #     sequence_metadata {
  #       title: &#34;William and Nancy; New Mown Hay; Legacy, The&#34;
  #       artist: &#34;Trad.&#34;
  #       composers: &#34;Trad.&#34;
  #     }
  #     key_signatures {
  #       key: G
  #     }
  #     &#34;&#34;&#34;)
  # # TODO(fjord): verify chord annotations
  # del tunes[3].text_annotations[:]
  # self.compare_to_abc2midi_and_metadata(
  #     &#39;english3.mid&#39;, expected_ns3_metadata, tunes[3])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseKeyAccidentals"><code class="name flex">
<span>def <span class="ident">testParseKeyAccidentals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseKeyAccidentals(self):
  # Most examples taken from
  # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;D Phr ^f&#39;)
  self.compare_accidentals([0, -1, 0, 0, -1, 1, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.PHRYGIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;D maj =c&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 1, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;D =c&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 1, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseKeyBasic"><code class="name flex">
<span>def <span class="ident">testParseKeyBasic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseKeyBasic(self):
  # Most examples taken from
  # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(&#39;C major&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.C, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(&#39;A minor&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.A, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;C ionian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.C, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;A aeolian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.A, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;G Mixolydian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.G, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;D dorian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.DORIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;E phrygian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.E, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.PHRYGIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;F Lydian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.F, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.LYDIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;B Locrian&#39;)
  self.compare_accidentals([0, 0, 0, 0, 0, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.B, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.LOCRIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;F# mixolydian&#39;)
  self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;F#Mix&#39;)
  self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;F#MIX&#39;)
  self.compare_accidentals([1, 0, 1, 1, 0, 1, 1], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.F_SHARP, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MIXOLYDIAN,
                   proto_mode)

  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;Fm&#39;)
  self.compare_accidentals([-1, -1, 0, -1, -1, 0, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.F, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MINOR, proto_mode)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseKeyExplicit"><code class="name flex">
<span>def <span class="ident">testParseKeyExplicit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseKeyExplicit(self):
  # Most examples taken from
  # http://abcnotation.com/wiki/abc:standard:v2.1#kkey
  accidentals, proto_key, proto_mode = abc_parser.ABCTune.parse_key(
      &#39;D exp _b _e ^f&#39;)
  self.compare_accidentals([0, -1, 0, 0, -1, 1, 0], accidentals)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.D, proto_key)
  self.assertEqual(music_pb2.NoteSequence.KeySignature.MAJOR, proto_mode)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseOctaves"><code class="name flex">
<span>def <span class="ident">testParseOctaves</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseOctaves(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;X:1
      T:Test
      CC,&#39;,C,C&#39;c
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)

  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      notes {
        pitch: 60
        velocity: 90
        end_time: 0.25
      }
      notes {
        pitch: 48
        velocity: 90
        start_time: 0.25
        end_time: 0.5
      }
      notes {
        pitch: 48
        velocity: 90
        start_time: 0.5
        end_time: 0.75
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 0.75
        end_time: 1.0
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 1.0
        end_time: 1.25
      }
      total_time: 1.25
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testParseTempos"><code class="name flex">
<span>def <span class="ident">testParseTempos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseTempos(self):
  # Examples from http://abcnotation.com/wiki/abc:standard:v2.1#qtempo
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      L:1/4
      Q:60

      X:2
      L:1/4
      Q:C=100

      X:3
      Q:1/2=120

      X:4
      Q:1/4 3/8 1/4 3/8=40

      X:5
      Q:5/4=40

      X:6
      Q: &#34;Allegro&#34; 1/4=120

      X:7
      Q: 1/4=120 &#34;Allegro&#34;

      X:8
      Q: 3/8=50 &#34;Slowly&#34;

      X:9
      Q:&#34;Andante&#34;

      X:10
      Q:100  % define tempo using deprecated syntax
      % deprecated tempo syntax depends on unit note length. if it is
      % not defined, it is derived from the current meter.
      M:2/4  % define meter after tempo to verify that is supported.

      X:11
      Q:100  % define tempo using deprecated syntax
      % deprecated tempo syntax depends on unit note length.
      L:1/4  % define note length after tempo to verify that is supported.
      &#34;&#34;&#34;)
  self.assertLen(tunes, 11)
  self.assertEmpty(exceptions)

  self.assertEqual(60, tunes[1].tempos[0].qpm)
  self.assertEqual(100, tunes[2].tempos[0].qpm)
  self.assertEqual(240, tunes[3].tempos[0].qpm)
  self.assertEqual(200, tunes[4].tempos[0].qpm)
  self.assertEqual(200, tunes[5].tempos[0].qpm)
  self.assertEqual(120, tunes[6].tempos[0].qpm)
  self.assertEqual(120, tunes[7].tempos[0].qpm)
  self.assertEqual(75, tunes[8].tempos[0].qpm)
  self.assertEmpty(tunes[9].tempos, 0)
  self.assertEqual(25, tunes[10].tempos[0].qpm)
  self.assertEqual(100, tunes[11].tempos[0].qpm)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testRepeats"><code class="name flex">
<span>def <span class="ident">testRepeats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeats(self):
  # Several equivalent versions of the same tune.
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      Bcd ::[]|[]:: Bcd ::|

      X:2
      Q:1/4=120
      L:1/4
      T:Test
      Bcd :::: Bcd ::|

      X:3
      Q:1/4=120
      L:1/4
      T:Test
      |::Bcd ::|:: Bcd ::|

      % This version contains mismatched repeat symbols.
      X:4
      Q:1/4=120
      L:1/4
      T:Test
      |::Bcd ::|: Bcd ::|

      % This version is missing a repeat symbol at the end.
      X:5
      Q:1/4=120
      L:1/4
      T:Test
      |:: Bcd ::|: Bcd |

      % Ambiguous repeat that should go to the last repeat symbol.
      X:6
      Q:1/4=120
      L:1/4
      T:Test
      |:: Bcd ::| Bcd :|

      % Ambiguous repeat that should go to the last double bar.
      X:7
      Q:1/4=120
      L:1/4
      T:Test
      |:: Bcd ::| Bcd || Bcd :|

      % Ambiguous repeat that should go to the last double bar.
      X:8
      Q:1/4=120
      L:1/4
      T:Test
      || Bcd ::| Bcd || Bcd :|

      % Ensure double bar doesn&#39;t confuse declared repeat.
      X:9
      Q:1/4=120
      L:1/4
      T:Test
      |:: B || cd ::| Bcd || |: Bcd :|

      % Mismatched repeat at the very beginning.
      X:10
      Q:1/4=120
      L:1/4
      T:Test
      :| Bcd |:: Bcd ::|
      &#34;&#34;&#34;)
  self.assertLen(tunes, 7)
  self.assertLen(exceptions, 3)
  self.assertIsInstance(exceptions[0], abc_parser.RepeatParseError)
  self.assertIsInstance(exceptions[1], abc_parser.RepeatParseError)
  self.assertIsInstance(exceptions[2], abc_parser.RepeatParseError)
  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 0.0
        end_time: 0.5
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 0.5
        end_time: 1.0
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 1.0
        end_time: 1.5
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 1.5
        end_time: 2.0
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 2.0
        end_time: 2.5
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 2.5
        end_time: 3.0
      }
      section_annotations {
        time: 0
        section_id: 0
      }
      section_annotations {
        time: 1.5
        section_id: 1
      }
      section_groups {
        sections {
          section_id: 0
        }
        num_times: 3
      }
      section_groups {
        sections {
          section_id: 1
        }
        num_times: 3
      }
      total_time: 3.0
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])

  # Other versions are identical except for the reference number.
  expected_ns2 = copy.deepcopy(expected_ns1)
  expected_ns2.reference_number = 2
  self.assertProtoEquals(expected_ns2, tunes[2])

  expected_ns3 = copy.deepcopy(expected_ns1)
  expected_ns3.reference_number = 3
  self.assertProtoEquals(expected_ns3, tunes[3])

  # Also identical, except the last section is played only twice.
  expected_ns6 = copy.deepcopy(expected_ns1)
  expected_ns6.reference_number = 6
  expected_ns6.section_groups[-1].num_times = 2
  self.assertProtoEquals(expected_ns6, tunes[6])

  expected_ns7 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 7
      sequence_metadata {
        title: &#34;Test&#34;
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 0.0
        end_time: 0.5
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 0.5
        end_time: 1.0
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 1.0
        end_time: 1.5
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 1.5
        end_time: 2.0
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 2.0
        end_time: 2.5
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 2.5
        end_time: 3.0
      }
      notes {
        pitch: 71
        velocity: 90
        start_time: 3.0
        end_time: 3.5
      }
      notes {
        pitch: 72
        velocity: 90
        start_time: 3.5
        end_time: 4.0
      }
      notes {
        pitch: 74
        velocity: 90
        start_time: 4.0
        end_time: 4.5
      }
      section_annotations {
        time: 0
        section_id: 0
      }
      section_annotations {
        time: 1.5
        section_id: 1
      }
      section_annotations {
        time: 3.0
        section_id: 2
      }
      section_groups {
        sections {
          section_id: 0
        }
        num_times: 3
      }
      section_groups {
        sections {
          section_id: 1
        }
        num_times: 1
      }
      section_groups {
        sections {
          section_id: 2
        }
        num_times: 2
      }
      total_time: 4.5
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns7, tunes[7])

  expected_ns8 = copy.deepcopy(expected_ns7)
  expected_ns8.reference_number = 8
  self.assertProtoEquals(expected_ns8, tunes[8])

  expected_ns9 = copy.deepcopy(expected_ns7)
  expected_ns9.reference_number = 9
  self.assertProtoEquals(expected_ns9, tunes[9])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testSlashDuration"><code class="name flex">
<span>def <span class="ident">testSlashDuration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSlashDuration(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;X:1
      Q:1/4=120
      L:1/4
      T:Test
      CC/C//C///C////
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)

  expected_ns1 = testing_lib.parse_test_proto(
      music_pb2.NoteSequence,
      &#34;&#34;&#34;
      ticks_per_quarter: 220
      source_info: {
        source_type: SCORE_BASED
        encoding_type: ABC
        parser: MAGENTA_ABC
      }
      reference_number: 1
      sequence_metadata {
        title: &#34;Test&#34;
      }
      tempos {
        qpm: 120
      }
      notes {
        pitch: 60
        velocity: 90
        start_time: 0.0
        end_time: 0.5
      }
      notes {
        pitch: 60
        velocity: 90
        start_time: 0.5
        end_time: 0.75
      }
      notes {
        pitch: 60
        velocity: 90
        start_time: 0.75
        end_time: 0.875
      }
      notes {
        pitch: 60
        velocity: 90
        start_time: 0.875
        end_time: 0.9375
      }
      notes {
        pitch: 60
        velocity: 90
        start_time: 0.9375
        end_time: 0.96875
      }
      total_time: 0.96875
      &#34;&#34;&#34;)
  self.assertProtoEquals(expected_ns1, tunes[1])</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testSlur"><code class="name flex">
<span>def <span class="ident">testSlur</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSlur(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      (ABC) ( a b c ) (c (d e f) g a)
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  self.assertLen(tunes[1].notes, 12)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testTie"><code class="name flex">
<span>def <span class="ident">testTie</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTie(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      abc-|cba c4-c4 C.-C
      &#34;&#34;&#34;)
  self.assertLen(tunes, 1)
  self.assertEmpty(exceptions)
  self.assertLen(tunes[1].notes, 10)</code></pre>
</details>
</dd>
<dt id="note_seq.abc_parser_test.AbcParserTest.testTuplet"><code class="name flex">
<span>def <span class="ident">testTuplet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTuplet(self):
  tunes, exceptions = abc_parser.parse_abc_tunebook(&#34;&#34;&#34;
      X:1
      Q:1/4=120
      L:1/4
      T:Test
      (3abc
      &#34;&#34;&#34;)
  self.assertEmpty(tunes)
  self.assertLen(exceptions, 1)
  self.assertIsInstance(exceptions[0], abc_parser.TupletError)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="note_seq.testing_lib.ProtoTestCase" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase">ProtoTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="note_seq.testing_lib.ProtoTestCase.assertProtoEquals" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase.assertProtoEquals">assertProtoEquals</a></code></li>
<li><code><a title="note_seq.testing_lib.ProtoTestCase.setUp" href="testing_lib.html#note_seq.testing_lib.ProtoTestCase.setUp">setUp</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.abc_parser_test.AbcParserTest" href="#note_seq.abc_parser_test.AbcParserTest">AbcParserTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.compare_accidentals" href="#note_seq.abc_parser_test.AbcParserTest.compare_accidentals">compare_accidentals</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.compare_proto_list" href="#note_seq.abc_parser_test.AbcParserTest.compare_proto_list">compare_proto_list</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.compare_to_abc2midi_and_metadata" href="#note_seq.abc_parser_test.AbcParserTest.compare_to_abc2midi_and_metadata">compare_to_abc2midi_and_metadata</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testChordAnnotations" href="#note_seq.abc_parser_test.AbcParserTest.testChordAnnotations">testChordAnnotations</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testChords" href="#note_seq.abc_parser_test.AbcParserTest.testChords">testChords</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testDecorations" href="#note_seq.abc_parser_test.AbcParserTest.testDecorations">testDecorations</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testInvalidCharacter" href="#note_seq.abc_parser_test.AbcParserTest.testInvalidCharacter">testInvalidCharacter</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testLineContinuation" href="#note_seq.abc_parser_test.AbcParserTest.testLineContinuation">testLineContinuation</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testMultiVoice" href="#note_seq.abc_parser_test.AbcParserTest.testMultiVoice">testMultiVoice</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testNoteAccidentalsPerBar" href="#note_seq.abc_parser_test.AbcParserTest.testNoteAccidentalsPerBar">testNoteAccidentalsPerBar</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testOneSidedRepeat" href="#note_seq.abc_parser_test.AbcParserTest.testOneSidedRepeat">testOneSidedRepeat</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseBrokenRhythm" href="#note_seq.abc_parser_test.AbcParserTest.testParseBrokenRhythm">testParseBrokenRhythm</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseEnglishAbc" href="#note_seq.abc_parser_test.AbcParserTest.testParseEnglishAbc">testParseEnglishAbc</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseKeyAccidentals" href="#note_seq.abc_parser_test.AbcParserTest.testParseKeyAccidentals">testParseKeyAccidentals</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseKeyBasic" href="#note_seq.abc_parser_test.AbcParserTest.testParseKeyBasic">testParseKeyBasic</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseKeyExplicit" href="#note_seq.abc_parser_test.AbcParserTest.testParseKeyExplicit">testParseKeyExplicit</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseOctaves" href="#note_seq.abc_parser_test.AbcParserTest.testParseOctaves">testParseOctaves</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testParseTempos" href="#note_seq.abc_parser_test.AbcParserTest.testParseTempos">testParseTempos</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testRepeats" href="#note_seq.abc_parser_test.AbcParserTest.testRepeats">testRepeats</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testSlashDuration" href="#note_seq.abc_parser_test.AbcParserTest.testSlashDuration">testSlashDuration</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testSlur" href="#note_seq.abc_parser_test.AbcParserTest.testSlur">testSlur</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testTie" href="#note_seq.abc_parser_test.AbcParserTest.testTie">testTie</a></code></li>
<li><code><a title="note_seq.abc_parser_test.AbcParserTest.testTuplet" href="#note_seq.abc_parser_test.AbcParserTest.testTuplet">testTuplet</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>