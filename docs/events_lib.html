<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.events_lib API documentation</title>
<meta name="description" content="Abstract base classes for working with musical event sequences â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.events_lib</code></h1>
</header>
<section id="section-intro">
<p>Abstract base classes for working with musical event sequences.</p>
<p>The abstract <code><a title="note_seq.events_lib.EventSequence" href="#note_seq.events_lib.EventSequence">EventSequence</a></code> class is an interface for a sequence of musical
events. The <code><a title="note_seq.events_lib.SimpleEventSequence" href="#note_seq.events_lib.SimpleEventSequence">SimpleEventSequence</a></code> class is a basic implementation of this
interface.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Abstract base classes for working with musical event sequences.

The abstract `EventSequence` class is an interface for a sequence of musical
events. The `SimpleEventSequence` class is a basic implementation of this
interface.
&#34;&#34;&#34;

import abc
import copy

from note_seq import constants

DEFAULT_STEPS_PER_BAR = constants.DEFAULT_STEPS_PER_BAR
DEFAULT_STEPS_PER_QUARTER = constants.DEFAULT_STEPS_PER_QUARTER
STANDARD_PPQ = constants.STANDARD_PPQ


class NonIntegerStepsPerBarError(Exception):
  pass


class EventSequence(object):
  &#34;&#34;&#34;Stores a quantized stream of events.

  EventSequence is an abstract class to use as an interface for interacting
  with musical event sequences. Concrete implementations SimpleEventSequence
  (and its descendants Melody and ChordProgression) and LeadSheet represent
  sequences of musical events of particular types. In all cases, model-specific
  code is responsible for converting this representation to SequenceExample
  protos for TensorFlow.

  EventSequence represents an iterable object. Simply iterate to retrieve the
  events.

  Attributes:
    start_step: The offset of the first step of the sequence relative to the
        beginning of the source sequence.
    end_step: The offset to the beginning of the bar following the last step
        of the sequence relative to the beginning of the source sequence.
    steps: A Python list containing the time step at each event of the sequence.
  &#34;&#34;&#34;
  __metaclass__ = abc.ABCMeta

  @property
  @abc.abstractmethod
  def start_step(self):
    pass

  @property
  @abc.abstractmethod
  def end_step(self):
    pass

  @property
  @abc.abstractmethod
  def steps(self):
    pass

  @abc.abstractmethod
  def append(self, event):
    &#34;&#34;&#34;Appends event to the end of the sequence.

    Args:
      event: The event to append to the end.
    &#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def set_length(self, steps, from_left=False):
    &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

    If the event sequence is not long enough, will pad  to make the sequence
    the specified length. If it is too long, it will be truncated to the
    requested length.

    Args:
      steps: How many steps long the event sequence should be.
      from_left: Whether to add/remove from the left instead of right.
    &#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def __getitem__(self, i):
    &#34;&#34;&#34;Returns the event at the given index.&#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def __iter__(self):
    &#34;&#34;&#34;Returns an iterator over the events.&#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def __len__(self):
    &#34;&#34;&#34;How many events are in this EventSequence.

    Returns:
      Number of events as an integer.
    &#34;&#34;&#34;
    pass


class SimpleEventSequence(EventSequence):
  &#34;&#34;&#34;Stores a quantized stream of events.

  This class can be instantiated, but its main purpose is to serve as a base
  class for Melody, ChordProgression, and any other simple stream of musical
  events.

  SimpleEventSequence represents an iterable object. Simply iterate to retrieve
  the events.

  Attributes:
    start_step: The offset of the first step of the sequence relative to the
        beginning of the source sequence. Should always be the first step of a
        bar.
    end_step: The offset to the beginning of the bar following the last step
       of the sequence relative to the beginning of the source sequence. Will
       always be the first step of a bar.
    steps_per_quarter: Number of steps in in a quarter note.
    steps_per_bar: Number of steps in a bar (measure) of music.
  &#34;&#34;&#34;

  def __init__(self, pad_event, events=None, start_step=0,
               steps_per_bar=DEFAULT_STEPS_PER_BAR,
               steps_per_quarter=DEFAULT_STEPS_PER_QUARTER):
    &#34;&#34;&#34;Construct a SimpleEventSequence.

    If `events` is specified, instantiate with the provided event list.
    Otherwise, create an empty SimpleEventSequence.

    Args:
      pad_event: Event value to use when padding sequences.
      events: List of events to instantiate with.
      start_step: The integer starting step offset.
      steps_per_bar: The number of steps in a bar.
      steps_per_quarter: The number of steps in a quarter note.
    &#34;&#34;&#34;
    self._pad_event = pad_event
    if events is not None:
      self._from_event_list(events, start_step=start_step,
                            steps_per_bar=steps_per_bar,
                            steps_per_quarter=steps_per_quarter)
    else:
      self._events = []
      self._steps_per_bar = steps_per_bar
      self._steps_per_quarter = steps_per_quarter
      self._start_step = start_step
      self._end_step = start_step

  def _reset(self):
    &#34;&#34;&#34;Clear events and reset object state.&#34;&#34;&#34;
    self._events = []
    self._steps_per_bar = DEFAULT_STEPS_PER_BAR
    self._steps_per_quarter = DEFAULT_STEPS_PER_QUARTER
    self._start_step = 0
    self._end_step = 0

  def _from_event_list(self, events, start_step=0,
                       steps_per_bar=DEFAULT_STEPS_PER_BAR,
                       steps_per_quarter=DEFAULT_STEPS_PER_QUARTER):
    &#34;&#34;&#34;Initializes with a list of event values and sets attributes.&#34;&#34;&#34;
    self._events = list(events)
    self._start_step = start_step
    self._end_step = start_step + len(self)
    self._steps_per_bar = steps_per_bar
    self._steps_per_quarter = steps_per_quarter

  def __iter__(self):
    &#34;&#34;&#34;Return an iterator over the events in this SimpleEventSequence.

    Returns:
      Python iterator over events.
    &#34;&#34;&#34;
    return iter(self._events)

  def __getitem__(self, key):
    &#34;&#34;&#34;Returns the slice or individual item.&#34;&#34;&#34;
    if isinstance(key, int):
      return self._events[key]
    elif isinstance(key, slice):
      events = self._events.__getitem__(key)
      return type(self)(pad_event=self._pad_event,
                        events=events,
                        start_step=self.start_step + (key.start or 0),
                        steps_per_bar=self.steps_per_bar,
                        steps_per_quarter=self.steps_per_quarter)

  def __len__(self):
    &#34;&#34;&#34;How many events are in this SimpleEventSequence.

    Returns:
      Number of events as an integer.
    &#34;&#34;&#34;
    return len(self._events)

  def __deepcopy__(self, memo=None):
    return type(self)(pad_event=self._pad_event,
                      events=copy.deepcopy(self._events, memo),
                      start_step=self.start_step,
                      steps_per_bar=self.steps_per_bar,
                      steps_per_quarter=self.steps_per_quarter)

  def __eq__(self, other):
    if type(self) is not type(other):
      return False
    return (list(self) == list(other) and
            self.steps_per_bar == other.steps_per_bar and
            self.steps_per_quarter == other.steps_per_quarter and
            self.start_step == other.start_step and
            self.end_step == other.end_step)

  @property
  def start_step(self):
    return self._start_step

  @property
  def end_step(self):
    return self._end_step

  @property
  def steps(self):
    return list(range(self._start_step, self._end_step))

  @property
  def steps_per_bar(self):
    return self._steps_per_bar

  @property
  def steps_per_quarter(self):
    return self._steps_per_quarter

  def append(self, event):
    &#34;&#34;&#34;Appends event to the end of the sequence and increments the end step.

    Args:
      event: The event to append to the end.
    &#34;&#34;&#34;
    self._events.append(event)
    self._end_step += 1

  def set_length(self, steps, from_left=False):
    &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

    If the event sequence is not long enough, pads to make the sequence the
    specified length. If it is too long, it will be truncated to the requested
    length.

    Args:
      steps: How many steps long the event sequence should be.
      from_left: Whether to add/remove from the left instead of right.
    &#34;&#34;&#34;
    if steps &gt; len(self):
      if from_left:
        self._events[:0] = [self._pad_event] * (steps - len(self))
      else:
        self._events.extend([self._pad_event] * (steps - len(self)))
    else:
      if from_left:
        del self._events[0:-steps]
      else:
        del self._events[steps:]

    if from_left:
      self._start_step = self._end_step - steps
    else:
      self._end_step = self._start_step + steps

  def increase_resolution(self, k, fill_event=None):
    &#34;&#34;&#34;Increase the resolution of an event sequence.

    Increases the resolution of a SimpleEventSequence object by a factor of
    `k`.

    Args:
      k: An integer, the factor by which to increase the resolution of the
          event sequence.
      fill_event: Event value to use to extend each low-resolution event. If
          None, each low-resolution event value will be repeated `k` times.
    &#34;&#34;&#34;
    if fill_event is None:
      fill = lambda event: [event] * k
    else:
      fill = lambda event: [event] + [fill_event] * (k - 1)

    new_events = []
    for event in self._events:
      new_events += fill(event)

    self._events = new_events
    self._start_step *= k
    self._end_step *= k
    self._steps_per_bar *= k
    self._steps_per_quarter *= k</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.events_lib.EventSequence"><code class="flex name class">
<span>class <span class="ident">EventSequence</span></span>
</code></dt>
<dd>
<div class="desc"><p>Stores a quantized stream of events.</p>
<p>EventSequence is an abstract class to use as an interface for interacting
with musical event sequences. Concrete implementations SimpleEventSequence
(and its descendants Melody and ChordProgression) and LeadSheet represent
sequences of musical events of particular types. In all cases, model-specific
code is responsible for converting this representation to SequenceExample
protos for TensorFlow.</p>
<p>EventSequence represents an iterable object. Simply iterate to retrieve the
events.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start_step</code></strong></dt>
<dd>The offset of the first step of the sequence relative to the
beginning of the source sequence.</dd>
<dt><strong><code>end_step</code></strong></dt>
<dd>The offset to the beginning of the bar following the last step
of the sequence relative to the beginning of the source sequence.</dd>
<dt><strong><code>steps</code></strong></dt>
<dd>A Python list containing the time step at each event of the sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventSequence(object):
  &#34;&#34;&#34;Stores a quantized stream of events.

  EventSequence is an abstract class to use as an interface for interacting
  with musical event sequences. Concrete implementations SimpleEventSequence
  (and its descendants Melody and ChordProgression) and LeadSheet represent
  sequences of musical events of particular types. In all cases, model-specific
  code is responsible for converting this representation to SequenceExample
  protos for TensorFlow.

  EventSequence represents an iterable object. Simply iterate to retrieve the
  events.

  Attributes:
    start_step: The offset of the first step of the sequence relative to the
        beginning of the source sequence.
    end_step: The offset to the beginning of the bar following the last step
        of the sequence relative to the beginning of the source sequence.
    steps: A Python list containing the time step at each event of the sequence.
  &#34;&#34;&#34;
  __metaclass__ = abc.ABCMeta

  @property
  @abc.abstractmethod
  def start_step(self):
    pass

  @property
  @abc.abstractmethod
  def end_step(self):
    pass

  @property
  @abc.abstractmethod
  def steps(self):
    pass

  @abc.abstractmethod
  def append(self, event):
    &#34;&#34;&#34;Appends event to the end of the sequence.

    Args:
      event: The event to append to the end.
    &#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def set_length(self, steps, from_left=False):
    &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

    If the event sequence is not long enough, will pad  to make the sequence
    the specified length. If it is too long, it will be truncated to the
    requested length.

    Args:
      steps: How many steps long the event sequence should be.
      from_left: Whether to add/remove from the left instead of right.
    &#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def __getitem__(self, i):
    &#34;&#34;&#34;Returns the event at the given index.&#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def __iter__(self):
    &#34;&#34;&#34;Returns an iterator over the events.&#34;&#34;&#34;
    pass

  @abc.abstractmethod
  def __len__(self):
    &#34;&#34;&#34;How many events are in this EventSequence.

    Returns:
      Number of events as an integer.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="note_seq.events_lib.SimpleEventSequence" href="#note_seq.events_lib.SimpleEventSequence">SimpleEventSequence</a></li>
<li><a title="note_seq.lead_sheets_lib.LeadSheet" href="lead_sheets_lib.html#note_seq.lead_sheets_lib.LeadSheet">LeadSheet</a></li>
<li><a title="note_seq.performance_lib.BasePerformance" href="performance_lib.html#note_seq.performance_lib.BasePerformance">BasePerformance</a></li>
<li><a title="note_seq.pianoroll_lib.PianorollSequence" href="pianoroll_lib.html#note_seq.pianoroll_lib.PianorollSequence">PianorollSequence</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="note_seq.events_lib.EventSequence.end_step"><code class="name">var <span class="ident">end_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def end_step(self):
  pass</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.EventSequence.start_step"><code class="name">var <span class="ident">start_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def start_step(self):
  pass</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.EventSequence.steps"><code class="name">var <span class="ident">steps</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def steps(self):
  pass</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="note_seq.events_lib.EventSequence.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends event to the end of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The event to append to the end.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def append(self, event):
  &#34;&#34;&#34;Appends event to the end of the sequence.

  Args:
    event: The event to append to the end.
  &#34;&#34;&#34;
  pass</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.EventSequence.set_length"><code class="name flex">
<span>def <span class="ident">set_length</span></span>(<span>self, steps, from_left=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the length of the sequence to the specified number of steps.</p>
<p>If the event sequence is not long enough, will pad
to make the sequence
the specified length. If it is too long, it will be truncated to the
requested length.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>steps</code></strong></dt>
<dd>How many steps long the event sequence should be.</dd>
<dt><strong><code>from_left</code></strong></dt>
<dd>Whether to add/remove from the left instead of right.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_length(self, steps, from_left=False):
  &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

  If the event sequence is not long enough, will pad  to make the sequence
  the specified length. If it is too long, it will be truncated to the
  requested length.

  Args:
    steps: How many steps long the event sequence should be.
    from_left: Whether to add/remove from the left instead of right.
  &#34;&#34;&#34;
  pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="note_seq.events_lib.NonIntegerStepsPerBarError"><code class="flex name class">
<span>class <span class="ident">NonIntegerStepsPerBarError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonIntegerStepsPerBarError(Exception):
  pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence"><code class="flex name class">
<span>class <span class="ident">SimpleEventSequence</span></span>
<span>(</span><span>pad_event, events=None, start_step=0, steps_per_bar=16, steps_per_quarter=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores a quantized stream of events.</p>
<p>This class can be instantiated, but its main purpose is to serve as a base
class for Melody, ChordProgression, and any other simple stream of musical
events.</p>
<p>SimpleEventSequence represents an iterable object. Simply iterate to retrieve
the events.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start_step</code></strong></dt>
<dd>The offset of the first step of the sequence relative to the
beginning of the source sequence. Should always be the first step of a
bar.</dd>
<dt><strong><code>end_step</code></strong></dt>
<dd>The offset to the beginning of the bar following the last step
of the sequence relative to the beginning of the source sequence. Will
always be the first step of a bar.</dd>
<dt><strong><code>steps_per_quarter</code></strong></dt>
<dd>Number of steps in in a quarter note.</dd>
<dt><strong><code>steps_per_bar</code></strong></dt>
<dd>Number of steps in a bar (measure) of music.</dd>
</dl>
<p>Construct a SimpleEventSequence.</p>
<p>If <code>events</code> is specified, instantiate with the provided event list.
Otherwise, create an empty SimpleEventSequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pad_event</code></strong></dt>
<dd>Event value to use when padding sequences.</dd>
<dt><strong><code>events</code></strong></dt>
<dd>List of events to instantiate with.</dd>
<dt><strong><code>start_step</code></strong></dt>
<dd>The integer starting step offset.</dd>
<dt><strong><code>steps_per_bar</code></strong></dt>
<dd>The number of steps in a bar.</dd>
<dt><strong><code>steps_per_quarter</code></strong></dt>
<dd>The number of steps in a quarter note.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleEventSequence(EventSequence):
  &#34;&#34;&#34;Stores a quantized stream of events.

  This class can be instantiated, but its main purpose is to serve as a base
  class for Melody, ChordProgression, and any other simple stream of musical
  events.

  SimpleEventSequence represents an iterable object. Simply iterate to retrieve
  the events.

  Attributes:
    start_step: The offset of the first step of the sequence relative to the
        beginning of the source sequence. Should always be the first step of a
        bar.
    end_step: The offset to the beginning of the bar following the last step
       of the sequence relative to the beginning of the source sequence. Will
       always be the first step of a bar.
    steps_per_quarter: Number of steps in in a quarter note.
    steps_per_bar: Number of steps in a bar (measure) of music.
  &#34;&#34;&#34;

  def __init__(self, pad_event, events=None, start_step=0,
               steps_per_bar=DEFAULT_STEPS_PER_BAR,
               steps_per_quarter=DEFAULT_STEPS_PER_QUARTER):
    &#34;&#34;&#34;Construct a SimpleEventSequence.

    If `events` is specified, instantiate with the provided event list.
    Otherwise, create an empty SimpleEventSequence.

    Args:
      pad_event: Event value to use when padding sequences.
      events: List of events to instantiate with.
      start_step: The integer starting step offset.
      steps_per_bar: The number of steps in a bar.
      steps_per_quarter: The number of steps in a quarter note.
    &#34;&#34;&#34;
    self._pad_event = pad_event
    if events is not None:
      self._from_event_list(events, start_step=start_step,
                            steps_per_bar=steps_per_bar,
                            steps_per_quarter=steps_per_quarter)
    else:
      self._events = []
      self._steps_per_bar = steps_per_bar
      self._steps_per_quarter = steps_per_quarter
      self._start_step = start_step
      self._end_step = start_step

  def _reset(self):
    &#34;&#34;&#34;Clear events and reset object state.&#34;&#34;&#34;
    self._events = []
    self._steps_per_bar = DEFAULT_STEPS_PER_BAR
    self._steps_per_quarter = DEFAULT_STEPS_PER_QUARTER
    self._start_step = 0
    self._end_step = 0

  def _from_event_list(self, events, start_step=0,
                       steps_per_bar=DEFAULT_STEPS_PER_BAR,
                       steps_per_quarter=DEFAULT_STEPS_PER_QUARTER):
    &#34;&#34;&#34;Initializes with a list of event values and sets attributes.&#34;&#34;&#34;
    self._events = list(events)
    self._start_step = start_step
    self._end_step = start_step + len(self)
    self._steps_per_bar = steps_per_bar
    self._steps_per_quarter = steps_per_quarter

  def __iter__(self):
    &#34;&#34;&#34;Return an iterator over the events in this SimpleEventSequence.

    Returns:
      Python iterator over events.
    &#34;&#34;&#34;
    return iter(self._events)

  def __getitem__(self, key):
    &#34;&#34;&#34;Returns the slice or individual item.&#34;&#34;&#34;
    if isinstance(key, int):
      return self._events[key]
    elif isinstance(key, slice):
      events = self._events.__getitem__(key)
      return type(self)(pad_event=self._pad_event,
                        events=events,
                        start_step=self.start_step + (key.start or 0),
                        steps_per_bar=self.steps_per_bar,
                        steps_per_quarter=self.steps_per_quarter)

  def __len__(self):
    &#34;&#34;&#34;How many events are in this SimpleEventSequence.

    Returns:
      Number of events as an integer.
    &#34;&#34;&#34;
    return len(self._events)

  def __deepcopy__(self, memo=None):
    return type(self)(pad_event=self._pad_event,
                      events=copy.deepcopy(self._events, memo),
                      start_step=self.start_step,
                      steps_per_bar=self.steps_per_bar,
                      steps_per_quarter=self.steps_per_quarter)

  def __eq__(self, other):
    if type(self) is not type(other):
      return False
    return (list(self) == list(other) and
            self.steps_per_bar == other.steps_per_bar and
            self.steps_per_quarter == other.steps_per_quarter and
            self.start_step == other.start_step and
            self.end_step == other.end_step)

  @property
  def start_step(self):
    return self._start_step

  @property
  def end_step(self):
    return self._end_step

  @property
  def steps(self):
    return list(range(self._start_step, self._end_step))

  @property
  def steps_per_bar(self):
    return self._steps_per_bar

  @property
  def steps_per_quarter(self):
    return self._steps_per_quarter

  def append(self, event):
    &#34;&#34;&#34;Appends event to the end of the sequence and increments the end step.

    Args:
      event: The event to append to the end.
    &#34;&#34;&#34;
    self._events.append(event)
    self._end_step += 1

  def set_length(self, steps, from_left=False):
    &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

    If the event sequence is not long enough, pads to make the sequence the
    specified length. If it is too long, it will be truncated to the requested
    length.

    Args:
      steps: How many steps long the event sequence should be.
      from_left: Whether to add/remove from the left instead of right.
    &#34;&#34;&#34;
    if steps &gt; len(self):
      if from_left:
        self._events[:0] = [self._pad_event] * (steps - len(self))
      else:
        self._events.extend([self._pad_event] * (steps - len(self)))
    else:
      if from_left:
        del self._events[0:-steps]
      else:
        del self._events[steps:]

    if from_left:
      self._start_step = self._end_step - steps
    else:
      self._end_step = self._start_step + steps

  def increase_resolution(self, k, fill_event=None):
    &#34;&#34;&#34;Increase the resolution of an event sequence.

    Increases the resolution of a SimpleEventSequence object by a factor of
    `k`.

    Args:
      k: An integer, the factor by which to increase the resolution of the
          event sequence.
      fill_event: Event value to use to extend each low-resolution event. If
          None, each low-resolution event value will be repeated `k` times.
    &#34;&#34;&#34;
    if fill_event is None:
      fill = lambda event: [event] * k
    else:
      fill = lambda event: [event] + [fill_event] * (k - 1)

    new_events = []
    for event in self._events:
      new_events += fill(event)

    self._events = new_events
    self._start_step *= k
    self._end_step *= k
    self._steps_per_bar *= k
    self._steps_per_quarter *= k</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.events_lib.EventSequence" href="#note_seq.events_lib.EventSequence">EventSequence</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="note_seq.chords_lib.ChordProgression" href="chords_lib.html#note_seq.chords_lib.ChordProgression">ChordProgression</a></li>
<li><a title="note_seq.drums_lib.DrumTrack" href="drums_lib.html#note_seq.drums_lib.DrumTrack">DrumTrack</a></li>
<li><a title="note_seq.melodies_lib.Melody" href="melodies_lib.html#note_seq.melodies_lib.Melody">Melody</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="note_seq.events_lib.SimpleEventSequence.end_step"><code class="name">var <span class="ident">end_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_step(self):
  return self._end_step</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence.start_step"><code class="name">var <span class="ident">start_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_step(self):
  return self._start_step</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence.steps"><code class="name">var <span class="ident">steps</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steps(self):
  return list(range(self._start_step, self._end_step))</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence.steps_per_bar"><code class="name">var <span class="ident">steps_per_bar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steps_per_bar(self):
  return self._steps_per_bar</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence.steps_per_quarter"><code class="name">var <span class="ident">steps_per_quarter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steps_per_quarter(self):
  return self._steps_per_quarter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="note_seq.events_lib.SimpleEventSequence.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends event to the end of the sequence and increments the end step.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The event to append to the end.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, event):
  &#34;&#34;&#34;Appends event to the end of the sequence and increments the end step.

  Args:
    event: The event to append to the end.
  &#34;&#34;&#34;
  self._events.append(event)
  self._end_step += 1</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence.increase_resolution"><code class="name flex">
<span>def <span class="ident">increase_resolution</span></span>(<span>self, k, fill_event=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Increase the resolution of an event sequence.</p>
<p>Increases the resolution of a SimpleEventSequence object by a factor of
<code>k</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>k</code></strong></dt>
<dd>An integer, the factor by which to increase the resolution of the
event sequence.</dd>
<dt><strong><code>fill_event</code></strong></dt>
<dd>Event value to use to extend each low-resolution event. If
None, each low-resolution event value will be repeated <code>k</code> times.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increase_resolution(self, k, fill_event=None):
  &#34;&#34;&#34;Increase the resolution of an event sequence.

  Increases the resolution of a SimpleEventSequence object by a factor of
  `k`.

  Args:
    k: An integer, the factor by which to increase the resolution of the
        event sequence.
    fill_event: Event value to use to extend each low-resolution event. If
        None, each low-resolution event value will be repeated `k` times.
  &#34;&#34;&#34;
  if fill_event is None:
    fill = lambda event: [event] * k
  else:
    fill = lambda event: [event] + [fill_event] * (k - 1)

  new_events = []
  for event in self._events:
    new_events += fill(event)

  self._events = new_events
  self._start_step *= k
  self._end_step *= k
  self._steps_per_bar *= k
  self._steps_per_quarter *= k</code></pre>
</details>
</dd>
<dt id="note_seq.events_lib.SimpleEventSequence.set_length"><code class="name flex">
<span>def <span class="ident">set_length</span></span>(<span>self, steps, from_left=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the length of the sequence to the specified number of steps.</p>
<p>If the event sequence is not long enough, pads to make the sequence the
specified length. If it is too long, it will be truncated to the requested
length.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>steps</code></strong></dt>
<dd>How many steps long the event sequence should be.</dd>
<dt><strong><code>from_left</code></strong></dt>
<dd>Whether to add/remove from the left instead of right.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_length(self, steps, from_left=False):
  &#34;&#34;&#34;Sets the length of the sequence to the specified number of steps.

  If the event sequence is not long enough, pads to make the sequence the
  specified length. If it is too long, it will be truncated to the requested
  length.

  Args:
    steps: How many steps long the event sequence should be.
    from_left: Whether to add/remove from the left instead of right.
  &#34;&#34;&#34;
  if steps &gt; len(self):
    if from_left:
      self._events[:0] = [self._pad_event] * (steps - len(self))
    else:
      self._events.extend([self._pad_event] * (steps - len(self)))
  else:
    if from_left:
      del self._events[0:-steps]
    else:
      del self._events[steps:]

  if from_left:
    self._start_step = self._end_step - steps
  else:
    self._end_step = self._start_step + steps</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.events_lib.EventSequence" href="#note_seq.events_lib.EventSequence">EventSequence</a></code></h4>
<ul class="">
<li><code><a title="note_seq.events_lib.EventSequence.append" href="#note_seq.events_lib.EventSequence.append">append</a></code></li>
<li><code><a title="note_seq.events_lib.EventSequence.end_step" href="#note_seq.events_lib.EventSequence.end_step">end_step</a></code></li>
<li><code><a title="note_seq.events_lib.EventSequence.set_length" href="#note_seq.events_lib.EventSequence.set_length">set_length</a></code></li>
<li><code><a title="note_seq.events_lib.EventSequence.start_step" href="#note_seq.events_lib.EventSequence.start_step">start_step</a></code></li>
<li><code><a title="note_seq.events_lib.EventSequence.steps" href="#note_seq.events_lib.EventSequence.steps">steps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.events_lib.NonIntegerStepsPerBarError" href="#note_seq.events_lib.NonIntegerStepsPerBarError">NonIntegerStepsPerBarError</a></code></h4>
</li>
<li>
<h4><code><a title="note_seq.events_lib.SimpleEventSequence" href="#note_seq.events_lib.SimpleEventSequence">SimpleEventSequence</a></code></h4>
<ul class="two-column">
<li><code><a title="note_seq.events_lib.SimpleEventSequence.append" href="#note_seq.events_lib.SimpleEventSequence.append">append</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.end_step" href="#note_seq.events_lib.SimpleEventSequence.end_step">end_step</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.increase_resolution" href="#note_seq.events_lib.SimpleEventSequence.increase_resolution">increase_resolution</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.set_length" href="#note_seq.events_lib.SimpleEventSequence.set_length">set_length</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.start_step" href="#note_seq.events_lib.SimpleEventSequence.start_step">start_step</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.steps" href="#note_seq.events_lib.SimpleEventSequence.steps">steps</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.steps_per_bar" href="#note_seq.events_lib.SimpleEventSequence.steps_per_bar">steps_per_bar</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.steps_per_quarter" href="#note_seq.events_lib.SimpleEventSequence.steps_per_quarter">steps_per_quarter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>