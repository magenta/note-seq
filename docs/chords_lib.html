<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.chords_lib API documentation</title>
<meta name="description" content="Utility functions for working with chord progressions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.chords_lib</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for working with chord progressions.</p>
<p>Use extract_chords_for_melodies to extract chord progressions from a
quantized NoteSequence object, aligned with already-extracted melodies.</p>
<p>Use ChordProgression.to_sequence to write a chord progression to a
NoteSequence proto, encoding the chords as text annotations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Utility functions for working with chord progressions.

Use extract_chords_for_melodies to extract chord progressions from a
quantized NoteSequence object, aligned with already-extracted melodies.

Use ChordProgression.to_sequence to write a chord progression to a
NoteSequence proto, encoding the chords as text annotations.
&#34;&#34;&#34;

import abc
import bisect

from note_seq import chord_symbols_lib
from note_seq import constants
from note_seq import events_lib
from note_seq import sequences_lib
from note_seq.protobuf import music_pb2

STANDARD_PPQ = constants.STANDARD_PPQ
NOTES_PER_OCTAVE = constants.NOTES_PER_OCTAVE
NO_CHORD = constants.NO_CHORD

# Shortcut to CHORD_SYMBOL annotation type.
CHORD_SYMBOL = music_pb2.NoteSequence.TextAnnotation.CHORD_SYMBOL


class CoincidentChordsError(Exception):
  pass


class BadChordError(Exception):
  pass


class ChordProgression(events_lib.SimpleEventSequence):
  &#34;&#34;&#34;Stores a quantized stream of chord events.

  ChordProgression is an intermediate representation that all chord or lead
  sheet models can use. Chords are represented here by a chord symbol string;
  model-specific code is responsible for converting this representation to
  SequenceExample protos for TensorFlow.

  ChordProgression implements an iterable object. Simply iterate to retrieve
  the chord events.

  ChordProgression events are chord symbol strings like &#34;Cm7&#34;, with special
  event NO_CHORD to indicate no chordal harmony. When a chord lasts for longer
  than a single step, the chord symbol event is repeated multiple times. Note
  that this is different from Melody, where the special MELODY_NO_EVENT is used
  for subsequent steps of sustained notes; in the case of harmony, there&#39;s no
  distinction between a repeated chord and a sustained chord.

  Chords must be inserted in ascending order by start time.

  Attributes:
    start_step: The offset of the first step of the progression relative to the
        beginning of the source sequence.
    end_step: The offset to the beginning of the bar following the last step
       of the progression relative to the beginning of the source sequence.
    steps_per_quarter: Number of steps in in a quarter note.
    steps_per_bar: Number of steps in a bar (measure) of music.
  &#34;&#34;&#34;

  def __init__(self, events=None, **kwargs):
    &#34;&#34;&#34;Construct a ChordProgression.&#34;&#34;&#34;
    if &#39;pad_event&#39; in kwargs:
      del kwargs[&#39;pad_event&#39;]
    super(ChordProgression, self).__init__(pad_event=NO_CHORD,
                                           events=events, **kwargs)

  def _add_chord(self, figure, start_step, end_step):
    &#34;&#34;&#34;Adds the given chord to the `events` list.

    `start_step` is set to the given chord. Everything after `start_step` in
    `events` is deleted before the chord is added. `events`&#39;s length will be
     changed so that the last event has index `end_step` - 1.

    Args:
      figure: Chord symbol figure. A string like &#34;Cm9&#34; representing the chord.
      start_step: A non-negative integer step that the chord begins on.
      end_step: An integer step that the chord ends on. The chord is considered
          to end at the onset of the end step. `end_step` must be greater than
          `start_step`.

    Raises:
      BadChordError: If `start_step` does not precede `end_step`.
    &#34;&#34;&#34;
    if start_step &gt;= end_step:
      raise BadChordError(
          &#39;Start step does not precede end step: start=%d, end=%d&#39; %
          (start_step, end_step))

    self.set_length(end_step)

    for i in range(start_step, end_step):
      self._events[i] = figure

  def from_quantized_sequence(self, quantized_sequence, start_step, end_step):
    &#34;&#34;&#34;Populate self with the chords from the given quantized NoteSequence.

    A chord progression is extracted from the given sequence starting at time
    step `start_step` and ending at time step `end_step`.

    The number of time steps per bar is computed from the time signature in
    `quantized_sequence`.

    Args:
      quantized_sequence: A quantized NoteSequence instance.
      start_step: Start populating chords at this time step.
      end_step: Stop populating chords at this time step.

    Raises:
      NonIntegerStepsPerBarError: If `quantized_sequence`&#39;s bar length
          (derived from its time signature) is not an integer number of time
          steps.
      CoincidentChordsError: If any of the chords start on the same step.
    &#34;&#34;&#34;
    sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)
    self._reset()

    steps_per_bar_float = sequences_lib.steps_per_bar_in_quantized_sequence(
        quantized_sequence)
    if steps_per_bar_float % 1 != 0:
      raise events_lib.NonIntegerStepsPerBarError(
          &#39;There are %f timesteps per bar. Time signature: %d/%d&#39; %
          (steps_per_bar_float, quantized_sequence.time_signature.numerator,
           quantized_sequence.time_signature.denominator))
    self._steps_per_bar = int(steps_per_bar_float)
    self._steps_per_quarter = (
        quantized_sequence.quantization_info.steps_per_quarter)

    # Sort track by chord times.
    chords = sorted([a for a in quantized_sequence.text_annotations
                     if a.annotation_type == CHORD_SYMBOL],
                    key=lambda chord: chord.quantized_step)

    prev_step = None
    prev_figure = NO_CHORD

    for chord in chords:
      if chord.quantized_step &gt;= end_step:
        # No more chords within range.
        break

      elif chord.quantized_step &lt; start_step:
        # Chord is before start of range.
        prev_step = chord.quantized_step
        prev_figure = chord.text
        continue

      if chord.quantized_step == prev_step:
        if chord.text == prev_figure:
          # Identical coincident chords, just skip.
          continue
        else:
          # Two different chords start at the same time step.
          self._reset()
          raise CoincidentChordsError(
              &#39;chords %s and %s are coincident&#39; % (prev_figure, chord.text))

      if chord.quantized_step &gt; start_step:
        # Add the previous chord.
        if prev_step is None:
          start_index = 0
        else:
          start_index = max(prev_step, start_step) - start_step
        end_index = chord.quantized_step - start_step
        self._add_chord(prev_figure, start_index, end_index)

      prev_step = chord.quantized_step
      prev_figure = chord.text

    if prev_step is None or prev_step &lt; end_step:
      # Add the last chord active before end_step.
      if prev_step is None:
        start_index = 0
      else:
        start_index = max(prev_step, start_step) - start_step
      end_index = end_step - start_step
      self._add_chord(prev_figure, start_index, end_index)

    self._start_step = start_step
    self._end_step = end_step

  def to_sequence(self,
                  sequence_start_time=0.0,
                  qpm=120.0):
    &#34;&#34;&#34;Converts the ChordProgression to NoteSequence proto.

    This doesn&#39;t generate actual notes, but text annotations specifying the
    chord changes when they occur.

    Args:
      sequence_start_time: A time in seconds (float) that the first chord in
          the sequence will land on.
      qpm: Quarter notes per minute (float).

    Returns:
      A NoteSequence proto encoding the given chords as text annotations.
    &#34;&#34;&#34;
    seconds_per_step = 60.0 / qpm / self.steps_per_quarter

    sequence = music_pb2.NoteSequence()
    sequence.tempos.add().qpm = qpm
    sequence.ticks_per_quarter = STANDARD_PPQ

    current_figure = NO_CHORD
    for step, figure in enumerate(self):
      if figure != current_figure:
        current_figure = figure
        chord = sequence.text_annotations.add()
        chord.time = step * seconds_per_step + sequence_start_time
        chord.text = figure
        chord.annotation_type = CHORD_SYMBOL

    return sequence

  def transpose(self, transpose_amount):
    &#34;&#34;&#34;Transpose chords in this ChordProgression.

    Args:
      transpose_amount: The number of half steps to transpose this
          ChordProgression. Positive values transpose up. Negative values
          transpose down.

    Raises:
      ChordSymbolError: If a chord (other than &#34;no chord&#34;) fails to be
          interpreted by the `chord_symbols_lib` module.
    &#34;&#34;&#34;
    for i in range(len(self._events)):
      if self._events[i] != NO_CHORD:
        self._events[i] = chord_symbols_lib.transpose_chord_symbol(
            self._events[i], transpose_amount % NOTES_PER_OCTAVE)


def event_list_chords(quantized_sequence, event_lists):
  &#34;&#34;&#34;Extract corresponding chords for multiple EventSequences.

  Args:
    quantized_sequence: The underlying quantized NoteSequence from which to
        extract the chords. It is assumed that the step numbering in this
        sequence matches the step numbering in each EventSequence in
        `event_lists`.
    event_lists: A list of EventSequence objects.

  Returns:
    A nested list of chord the same length as `event_lists`, where each list is
    the same length as the corresponding EventSequence (in events, not steps).
  &#34;&#34;&#34;
  sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)

  chords = ChordProgression()
  if quantized_sequence.total_quantized_steps &gt; 0:
    chords.from_quantized_sequence(
        quantized_sequence, 0, quantized_sequence.total_quantized_steps)

  pad_chord = chords[-1] if chords else NO_CHORD

  chord_lists = []
  for e in event_lists:
    chord_lists.append([chords[step] if step &lt; len(chords) else pad_chord
                        for step in e.steps])

  return chord_lists


def event_list_keys(sequence, event_lists, steps_per_second):
  &#34;&#34;&#34;Extract corresponding keys for multiple EventSequences.

  Args:
    sequence: The underlying NoteSequence from which to extract the keys.
    event_lists: A list of EventSequence objects.
    steps_per_second: The number of quantized steps per second in the event
        lists.

  Returns:
    A nested list of keys (integers 0-11 indicating the key signature) the same
    length as `event_lists`, where each list is the same length as the
    corresponding EventSequence (in events, not necessarily steps).
  &#34;&#34;&#34;
  if not sequence.key_signatures:
    raise ValueError(&#39;Sequence has no key signatures.&#39;)

  key_changes = sorted((steps_per_second * ks.time, ks.key)
                       for ks in sequence.key_signatures)
  key_change_steps = [step for (step, _) in key_changes]

  def step_to_key(step):
    index = bisect.bisect(key_change_steps, step)
    if index == 0:
      # Step is before first key signature; just use that key.
      return key_changes[0][1]
    else:
      return key_changes[index - 1][1]

  key_lists = []
  for e in event_lists:
    key_lists.append([step_to_key(step) for step in e.steps])

  return key_lists


def add_chords_to_sequence(note_sequence, chords, chord_times):
  &#34;&#34;&#34;Add chords to a NoteSequence (in place) at specified times.

  Args:
    note_sequence: The NoteSequence proto to which chords will be added (in
        place). Should not already have chords.
    chords: A Python list of chord figure strings to add to `note_sequence` as
        text annotations.
    chord_times: A Python list containing the time in seconds at which to add
        each chord. Should be the same length as `chords` and nondecreasing.

  Raises:
    ValueError: If `note_sequence` already has chords, or if `chord_times` is
        not sorted in ascending order.
  &#34;&#34;&#34;
  if any(ta.annotation_type == CHORD_SYMBOL
         for ta in note_sequence.text_annotations):
    raise ValueError(&#39;NoteSequence already has chords.&#39;)
  if any(t1 &gt; t2 for t1, t2 in zip(chord_times[:-1], chord_times[1:])):
    raise ValueError(&#39;Chord times not sorted in ascending order.&#39;)

  current_chord = None
  for chord, time in zip(chords, chord_times):
    if chord != current_chord:
      current_chord = chord
      ta = note_sequence.text_annotations.add()
      ta.annotation_type = CHORD_SYMBOL
      ta.time = time
      ta.text = chord


def add_keys_to_sequence(note_sequence, keys, key_times):
  &#34;&#34;&#34;Add key signatures to a NoteSequence (in place) at specified times.

  Args:
    note_sequence: The NoteSequence proto to which key signatures will be added
        (in place). Should not already have key signatures.
    keys: A Python list of keys (integers 0-11) to add to `note_sequence` as
        KeySignature fields.
    key_times: A Python list containing the time in seconds at which to add
        each key signature. Should be the same length as `keys` and
        nondecreasing.

  Raises:
    ValueError: If `note_sequence` already has key signatures, or if `key_times`
        is not sorted in ascending order.
  &#34;&#34;&#34;
  if note_sequence.key_signatures:
    raise ValueError(&#39;NoteSequence already has keys.&#39;)
  if any(t1 &gt; t2 for t1, t2 in zip(key_times[:-1], key_times[1:])):
    raise ValueError(&#39;Key times not sorted in ascending order.&#39;)

  current_key = None
  for key, time in zip(keys, key_times):
    if key != current_key:
      current_key = key
      ks = note_sequence.key_signatures.add()
      ks.time = time
      ks.key = key


class ChordRenderer(object):
  &#34;&#34;&#34;An abstract class for rendering NoteSequence chord symbols as notes.&#34;&#34;&#34;
  __metaclass__ = abc.ABCMeta

  @abc.abstractmethod
  def render(self, sequence):
    &#34;&#34;&#34;Renders the chord symbols of a NoteSequence.

    This function renders chord symbol annotations in a NoteSequence as actual
    notes. Notes are added to the NoteSequence object, and the chord symbols
    remain also.

    Args:
      sequence: The NoteSequence for which to render chord symbols.
    &#34;&#34;&#34;
    pass


class BasicChordRenderer(ChordRenderer):
  &#34;&#34;&#34;A chord renderer that holds each note for the duration of the chord.&#34;&#34;&#34;

  def __init__(self,
               velocity=100,
               instrument=1,
               program=88,
               octave=4,
               bass_octave=3):
    &#34;&#34;&#34;Initialize a BasicChordRenderer object.

    Args:
      velocity: The MIDI note velocity to use.
      instrument: The MIDI instrument to use.
      program: The MIDI program to use.
      octave: The octave in which to render chord notes. If the bass note is not
          otherwise part of the chord, it will not be rendered in this octave.
      bass_octave: The octave in which to render chord bass notes.
    &#34;&#34;&#34;
    self._velocity = velocity
    self._instrument = instrument
    self._program = program
    self._octave = octave
    self._bass_octave = bass_octave

  def _render_notes(self, sequence, pitches, bass_pitch, start_time, end_time):
    &#34;&#34;&#34;Renders notes.&#34;&#34;&#34;
    all_pitches = []
    for pitch in pitches:
      all_pitches.append(12 * self._octave + pitch % 12)
    all_pitches.append(12 * self._bass_octave + bass_pitch % 12)

    for pitch in all_pitches:
      # Add a note.
      note = sequence.notes.add()
      note.start_time = start_time
      note.end_time = end_time
      note.pitch = pitch
      note.velocity = self._velocity
      note.instrument = self._instrument
      note.program = self._program

  def render(self, sequence):
    # Sort text annotations by time.
    annotations = sorted(sequence.text_annotations, key=lambda a: a.time)

    prev_time = 0.0
    prev_figure = NO_CHORD

    for annotation in annotations:
      if annotation.time &gt;= sequence.total_time:
        break

      if annotation.annotation_type == CHORD_SYMBOL:
        if prev_figure != NO_CHORD:
          # Render the previous chord.
          pitches = chord_symbols_lib.chord_symbol_pitches(prev_figure)
          bass_pitch = chord_symbols_lib.chord_symbol_bass(prev_figure)
          self._render_notes(sequence=sequence,
                             pitches=pitches,
                             bass_pitch=bass_pitch,
                             start_time=prev_time,
                             end_time=annotation.time)

        prev_time = annotation.time
        prev_figure = annotation.text

    if (prev_time &lt; sequence.total_time and
        prev_figure != NO_CHORD):
      # Render the last chord.
      pitches = chord_symbols_lib.chord_symbol_pitches(prev_figure)
      bass_pitch = chord_symbols_lib.chord_symbol_bass(prev_figure)
      self._render_notes(sequence=sequence,
                         pitches=pitches,
                         bass_pitch=bass_pitch,
                         start_time=prev_time,
                         end_time=sequence.total_time)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="note_seq.chords_lib.add_chords_to_sequence"><code class="name flex">
<span>def <span class="ident">add_chords_to_sequence</span></span>(<span>note_sequence, chords, chord_times)</span>
</code></dt>
<dd>
<div class="desc"><p>Add chords to a NoteSequence (in place) at specified times.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>note_sequence</code></strong></dt>
<dd>The NoteSequence proto to which chords will be added (in
place). Should not already have chords.</dd>
<dt><strong><code>chords</code></strong></dt>
<dd>A Python list of chord figure strings to add to <code>note_sequence</code> as
text annotations.</dd>
<dt><strong><code>chord_times</code></strong></dt>
<dd>A Python list containing the time in seconds at which to add
each chord. Should be the same length as <code>chords</code> and nondecreasing.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>note_sequence</code> already has chords, or if <code>chord_times</code> is
not sorted in ascending order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_chords_to_sequence(note_sequence, chords, chord_times):
  &#34;&#34;&#34;Add chords to a NoteSequence (in place) at specified times.

  Args:
    note_sequence: The NoteSequence proto to which chords will be added (in
        place). Should not already have chords.
    chords: A Python list of chord figure strings to add to `note_sequence` as
        text annotations.
    chord_times: A Python list containing the time in seconds at which to add
        each chord. Should be the same length as `chords` and nondecreasing.

  Raises:
    ValueError: If `note_sequence` already has chords, or if `chord_times` is
        not sorted in ascending order.
  &#34;&#34;&#34;
  if any(ta.annotation_type == CHORD_SYMBOL
         for ta in note_sequence.text_annotations):
    raise ValueError(&#39;NoteSequence already has chords.&#39;)
  if any(t1 &gt; t2 for t1, t2 in zip(chord_times[:-1], chord_times[1:])):
    raise ValueError(&#39;Chord times not sorted in ascending order.&#39;)

  current_chord = None
  for chord, time in zip(chords, chord_times):
    if chord != current_chord:
      current_chord = chord
      ta = note_sequence.text_annotations.add()
      ta.annotation_type = CHORD_SYMBOL
      ta.time = time
      ta.text = chord</code></pre>
</details>
</dd>
<dt id="note_seq.chords_lib.add_keys_to_sequence"><code class="name flex">
<span>def <span class="ident">add_keys_to_sequence</span></span>(<span>note_sequence, keys, key_times)</span>
</code></dt>
<dd>
<div class="desc"><p>Add key signatures to a NoteSequence (in place) at specified times.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>note_sequence</code></strong></dt>
<dd>The NoteSequence proto to which key signatures will be added
(in place). Should not already have key signatures.</dd>
<dt><strong><code>keys</code></strong></dt>
<dd>A Python list of keys (integers 0-11) to add to <code>note_sequence</code> as
KeySignature fields.</dd>
<dt><strong><code>key_times</code></strong></dt>
<dd>A Python list containing the time in seconds at which to add
each key signature. Should be the same length as <code>keys</code> and
nondecreasing.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>note_sequence</code> already has key signatures, or if <code>key_times</code>
is not sorted in ascending order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_keys_to_sequence(note_sequence, keys, key_times):
  &#34;&#34;&#34;Add key signatures to a NoteSequence (in place) at specified times.

  Args:
    note_sequence: The NoteSequence proto to which key signatures will be added
        (in place). Should not already have key signatures.
    keys: A Python list of keys (integers 0-11) to add to `note_sequence` as
        KeySignature fields.
    key_times: A Python list containing the time in seconds at which to add
        each key signature. Should be the same length as `keys` and
        nondecreasing.

  Raises:
    ValueError: If `note_sequence` already has key signatures, or if `key_times`
        is not sorted in ascending order.
  &#34;&#34;&#34;
  if note_sequence.key_signatures:
    raise ValueError(&#39;NoteSequence already has keys.&#39;)
  if any(t1 &gt; t2 for t1, t2 in zip(key_times[:-1], key_times[1:])):
    raise ValueError(&#39;Key times not sorted in ascending order.&#39;)

  current_key = None
  for key, time in zip(keys, key_times):
    if key != current_key:
      current_key = key
      ks = note_sequence.key_signatures.add()
      ks.time = time
      ks.key = key</code></pre>
</details>
</dd>
<dt id="note_seq.chords_lib.event_list_chords"><code class="name flex">
<span>def <span class="ident">event_list_chords</span></span>(<span>quantized_sequence, event_lists)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract corresponding chords for multiple EventSequences.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantized_sequence</code></strong></dt>
<dd>The underlying quantized NoteSequence from which to
extract the chords. It is assumed that the step numbering in this
sequence matches the step numbering in each EventSequence in
<code>event_lists</code>.</dd>
<dt><strong><code>event_lists</code></strong></dt>
<dd>A list of EventSequence objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A nested list of chord the same length as <code>event_lists</code>, where each list is
the same length as the corresponding EventSequence (in events, not steps).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_list_chords(quantized_sequence, event_lists):
  &#34;&#34;&#34;Extract corresponding chords for multiple EventSequences.

  Args:
    quantized_sequence: The underlying quantized NoteSequence from which to
        extract the chords. It is assumed that the step numbering in this
        sequence matches the step numbering in each EventSequence in
        `event_lists`.
    event_lists: A list of EventSequence objects.

  Returns:
    A nested list of chord the same length as `event_lists`, where each list is
    the same length as the corresponding EventSequence (in events, not steps).
  &#34;&#34;&#34;
  sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)

  chords = ChordProgression()
  if quantized_sequence.total_quantized_steps &gt; 0:
    chords.from_quantized_sequence(
        quantized_sequence, 0, quantized_sequence.total_quantized_steps)

  pad_chord = chords[-1] if chords else NO_CHORD

  chord_lists = []
  for e in event_lists:
    chord_lists.append([chords[step] if step &lt; len(chords) else pad_chord
                        for step in e.steps])

  return chord_lists</code></pre>
</details>
</dd>
<dt id="note_seq.chords_lib.event_list_keys"><code class="name flex">
<span>def <span class="ident">event_list_keys</span></span>(<span>sequence, event_lists, steps_per_second)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract corresponding keys for multiple EventSequences.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sequence</code></strong></dt>
<dd>The underlying NoteSequence from which to extract the keys.</dd>
<dt><strong><code>event_lists</code></strong></dt>
<dd>A list of EventSequence objects.</dd>
<dt><strong><code>steps_per_second</code></strong></dt>
<dd>The number of quantized steps per second in the event
lists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A nested list of keys (integers 0-11 indicating the key signature) the same
length as <code>event_lists</code>, where each list is the same length as the
corresponding EventSequence (in events, not necessarily steps).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_list_keys(sequence, event_lists, steps_per_second):
  &#34;&#34;&#34;Extract corresponding keys for multiple EventSequences.

  Args:
    sequence: The underlying NoteSequence from which to extract the keys.
    event_lists: A list of EventSequence objects.
    steps_per_second: The number of quantized steps per second in the event
        lists.

  Returns:
    A nested list of keys (integers 0-11 indicating the key signature) the same
    length as `event_lists`, where each list is the same length as the
    corresponding EventSequence (in events, not necessarily steps).
  &#34;&#34;&#34;
  if not sequence.key_signatures:
    raise ValueError(&#39;Sequence has no key signatures.&#39;)

  key_changes = sorted((steps_per_second * ks.time, ks.key)
                       for ks in sequence.key_signatures)
  key_change_steps = [step for (step, _) in key_changes]

  def step_to_key(step):
    index = bisect.bisect(key_change_steps, step)
    if index == 0:
      # Step is before first key signature; just use that key.
      return key_changes[0][1]
    else:
      return key_changes[index - 1][1]

  key_lists = []
  for e in event_lists:
    key_lists.append([step_to_key(step) for step in e.steps])

  return key_lists</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.chords_lib.BadChordError"><code class="flex name class">
<span>class <span class="ident">BadChordError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadChordError(Exception):
  pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="note_seq.chords_lib.BasicChordRenderer"><code class="flex name class">
<span>class <span class="ident">BasicChordRenderer</span></span>
<span>(</span><span>velocity=100, instrument=1, program=88, octave=4, bass_octave=3)</span>
</code></dt>
<dd>
<div class="desc"><p>A chord renderer that holds each note for the duration of the chord.</p>
<p>Initialize a BasicChordRenderer object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>velocity</code></strong></dt>
<dd>The MIDI note velocity to use.</dd>
<dt><strong><code>instrument</code></strong></dt>
<dd>The MIDI instrument to use.</dd>
<dt><strong><code>program</code></strong></dt>
<dd>The MIDI program to use.</dd>
<dt><strong><code>octave</code></strong></dt>
<dd>The octave in which to render chord notes. If the bass note is not
otherwise part of the chord, it will not be rendered in this octave.</dd>
<dt><strong><code>bass_octave</code></strong></dt>
<dd>The octave in which to render chord bass notes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasicChordRenderer(ChordRenderer):
  &#34;&#34;&#34;A chord renderer that holds each note for the duration of the chord.&#34;&#34;&#34;

  def __init__(self,
               velocity=100,
               instrument=1,
               program=88,
               octave=4,
               bass_octave=3):
    &#34;&#34;&#34;Initialize a BasicChordRenderer object.

    Args:
      velocity: The MIDI note velocity to use.
      instrument: The MIDI instrument to use.
      program: The MIDI program to use.
      octave: The octave in which to render chord notes. If the bass note is not
          otherwise part of the chord, it will not be rendered in this octave.
      bass_octave: The octave in which to render chord bass notes.
    &#34;&#34;&#34;
    self._velocity = velocity
    self._instrument = instrument
    self._program = program
    self._octave = octave
    self._bass_octave = bass_octave

  def _render_notes(self, sequence, pitches, bass_pitch, start_time, end_time):
    &#34;&#34;&#34;Renders notes.&#34;&#34;&#34;
    all_pitches = []
    for pitch in pitches:
      all_pitches.append(12 * self._octave + pitch % 12)
    all_pitches.append(12 * self._bass_octave + bass_pitch % 12)

    for pitch in all_pitches:
      # Add a note.
      note = sequence.notes.add()
      note.start_time = start_time
      note.end_time = end_time
      note.pitch = pitch
      note.velocity = self._velocity
      note.instrument = self._instrument
      note.program = self._program

  def render(self, sequence):
    # Sort text annotations by time.
    annotations = sorted(sequence.text_annotations, key=lambda a: a.time)

    prev_time = 0.0
    prev_figure = NO_CHORD

    for annotation in annotations:
      if annotation.time &gt;= sequence.total_time:
        break

      if annotation.annotation_type == CHORD_SYMBOL:
        if prev_figure != NO_CHORD:
          # Render the previous chord.
          pitches = chord_symbols_lib.chord_symbol_pitches(prev_figure)
          bass_pitch = chord_symbols_lib.chord_symbol_bass(prev_figure)
          self._render_notes(sequence=sequence,
                             pitches=pitches,
                             bass_pitch=bass_pitch,
                             start_time=prev_time,
                             end_time=annotation.time)

        prev_time = annotation.time
        prev_figure = annotation.text

    if (prev_time &lt; sequence.total_time and
        prev_figure != NO_CHORD):
      # Render the last chord.
      pitches = chord_symbols_lib.chord_symbol_pitches(prev_figure)
      bass_pitch = chord_symbols_lib.chord_symbol_bass(prev_figure)
      self._render_notes(sequence=sequence,
                         pitches=pitches,
                         bass_pitch=bass_pitch,
                         start_time=prev_time,
                         end_time=sequence.total_time)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.chords_lib.ChordRenderer" href="#note_seq.chords_lib.ChordRenderer">ChordRenderer</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="note_seq.chords_lib.ChordRenderer" href="#note_seq.chords_lib.ChordRenderer">ChordRenderer</a></b></code>:
<ul class="hlist">
<li><code><a title="note_seq.chords_lib.ChordRenderer.render" href="#note_seq.chords_lib.ChordRenderer.render">render</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="note_seq.chords_lib.ChordProgression"><code class="flex name class">
<span>class <span class="ident">ChordProgression</span></span>
<span>(</span><span>events=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores a quantized stream of chord events.</p>
<p>ChordProgression is an intermediate representation that all chord or lead
sheet models can use. Chords are represented here by a chord symbol string;
model-specific code is responsible for converting this representation to
SequenceExample protos for TensorFlow.</p>
<p>ChordProgression implements an iterable object. Simply iterate to retrieve
the chord events.</p>
<p>ChordProgression events are chord symbol strings like "Cm7", with special
event NO_CHORD to indicate no chordal harmony. When a chord lasts for longer
than a single step, the chord symbol event is repeated multiple times. Note
that this is different from Melody, where the special MELODY_NO_EVENT is used
for subsequent steps of sustained notes; in the case of harmony, there's no
distinction between a repeated chord and a sustained chord.</p>
<p>Chords must be inserted in ascending order by start time.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start_step</code></strong></dt>
<dd>The offset of the first step of the progression relative to the
beginning of the source sequence.</dd>
<dt><strong><code>end_step</code></strong></dt>
<dd>The offset to the beginning of the bar following the last step
of the progression relative to the beginning of the source sequence.</dd>
<dt><strong><code>steps_per_quarter</code></strong></dt>
<dd>Number of steps in in a quarter note.</dd>
<dt><strong><code>steps_per_bar</code></strong></dt>
<dd>Number of steps in a bar (measure) of music.</dd>
</dl>
<p>Construct a ChordProgression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChordProgression(events_lib.SimpleEventSequence):
  &#34;&#34;&#34;Stores a quantized stream of chord events.

  ChordProgression is an intermediate representation that all chord or lead
  sheet models can use. Chords are represented here by a chord symbol string;
  model-specific code is responsible for converting this representation to
  SequenceExample protos for TensorFlow.

  ChordProgression implements an iterable object. Simply iterate to retrieve
  the chord events.

  ChordProgression events are chord symbol strings like &#34;Cm7&#34;, with special
  event NO_CHORD to indicate no chordal harmony. When a chord lasts for longer
  than a single step, the chord symbol event is repeated multiple times. Note
  that this is different from Melody, where the special MELODY_NO_EVENT is used
  for subsequent steps of sustained notes; in the case of harmony, there&#39;s no
  distinction between a repeated chord and a sustained chord.

  Chords must be inserted in ascending order by start time.

  Attributes:
    start_step: The offset of the first step of the progression relative to the
        beginning of the source sequence.
    end_step: The offset to the beginning of the bar following the last step
       of the progression relative to the beginning of the source sequence.
    steps_per_quarter: Number of steps in in a quarter note.
    steps_per_bar: Number of steps in a bar (measure) of music.
  &#34;&#34;&#34;

  def __init__(self, events=None, **kwargs):
    &#34;&#34;&#34;Construct a ChordProgression.&#34;&#34;&#34;
    if &#39;pad_event&#39; in kwargs:
      del kwargs[&#39;pad_event&#39;]
    super(ChordProgression, self).__init__(pad_event=NO_CHORD,
                                           events=events, **kwargs)

  def _add_chord(self, figure, start_step, end_step):
    &#34;&#34;&#34;Adds the given chord to the `events` list.

    `start_step` is set to the given chord. Everything after `start_step` in
    `events` is deleted before the chord is added. `events`&#39;s length will be
     changed so that the last event has index `end_step` - 1.

    Args:
      figure: Chord symbol figure. A string like &#34;Cm9&#34; representing the chord.
      start_step: A non-negative integer step that the chord begins on.
      end_step: An integer step that the chord ends on. The chord is considered
          to end at the onset of the end step. `end_step` must be greater than
          `start_step`.

    Raises:
      BadChordError: If `start_step` does not precede `end_step`.
    &#34;&#34;&#34;
    if start_step &gt;= end_step:
      raise BadChordError(
          &#39;Start step does not precede end step: start=%d, end=%d&#39; %
          (start_step, end_step))

    self.set_length(end_step)

    for i in range(start_step, end_step):
      self._events[i] = figure

  def from_quantized_sequence(self, quantized_sequence, start_step, end_step):
    &#34;&#34;&#34;Populate self with the chords from the given quantized NoteSequence.

    A chord progression is extracted from the given sequence starting at time
    step `start_step` and ending at time step `end_step`.

    The number of time steps per bar is computed from the time signature in
    `quantized_sequence`.

    Args:
      quantized_sequence: A quantized NoteSequence instance.
      start_step: Start populating chords at this time step.
      end_step: Stop populating chords at this time step.

    Raises:
      NonIntegerStepsPerBarError: If `quantized_sequence`&#39;s bar length
          (derived from its time signature) is not an integer number of time
          steps.
      CoincidentChordsError: If any of the chords start on the same step.
    &#34;&#34;&#34;
    sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)
    self._reset()

    steps_per_bar_float = sequences_lib.steps_per_bar_in_quantized_sequence(
        quantized_sequence)
    if steps_per_bar_float % 1 != 0:
      raise events_lib.NonIntegerStepsPerBarError(
          &#39;There are %f timesteps per bar. Time signature: %d/%d&#39; %
          (steps_per_bar_float, quantized_sequence.time_signature.numerator,
           quantized_sequence.time_signature.denominator))
    self._steps_per_bar = int(steps_per_bar_float)
    self._steps_per_quarter = (
        quantized_sequence.quantization_info.steps_per_quarter)

    # Sort track by chord times.
    chords = sorted([a for a in quantized_sequence.text_annotations
                     if a.annotation_type == CHORD_SYMBOL],
                    key=lambda chord: chord.quantized_step)

    prev_step = None
    prev_figure = NO_CHORD

    for chord in chords:
      if chord.quantized_step &gt;= end_step:
        # No more chords within range.
        break

      elif chord.quantized_step &lt; start_step:
        # Chord is before start of range.
        prev_step = chord.quantized_step
        prev_figure = chord.text
        continue

      if chord.quantized_step == prev_step:
        if chord.text == prev_figure:
          # Identical coincident chords, just skip.
          continue
        else:
          # Two different chords start at the same time step.
          self._reset()
          raise CoincidentChordsError(
              &#39;chords %s and %s are coincident&#39; % (prev_figure, chord.text))

      if chord.quantized_step &gt; start_step:
        # Add the previous chord.
        if prev_step is None:
          start_index = 0
        else:
          start_index = max(prev_step, start_step) - start_step
        end_index = chord.quantized_step - start_step
        self._add_chord(prev_figure, start_index, end_index)

      prev_step = chord.quantized_step
      prev_figure = chord.text

    if prev_step is None or prev_step &lt; end_step:
      # Add the last chord active before end_step.
      if prev_step is None:
        start_index = 0
      else:
        start_index = max(prev_step, start_step) - start_step
      end_index = end_step - start_step
      self._add_chord(prev_figure, start_index, end_index)

    self._start_step = start_step
    self._end_step = end_step

  def to_sequence(self,
                  sequence_start_time=0.0,
                  qpm=120.0):
    &#34;&#34;&#34;Converts the ChordProgression to NoteSequence proto.

    This doesn&#39;t generate actual notes, but text annotations specifying the
    chord changes when they occur.

    Args:
      sequence_start_time: A time in seconds (float) that the first chord in
          the sequence will land on.
      qpm: Quarter notes per minute (float).

    Returns:
      A NoteSequence proto encoding the given chords as text annotations.
    &#34;&#34;&#34;
    seconds_per_step = 60.0 / qpm / self.steps_per_quarter

    sequence = music_pb2.NoteSequence()
    sequence.tempos.add().qpm = qpm
    sequence.ticks_per_quarter = STANDARD_PPQ

    current_figure = NO_CHORD
    for step, figure in enumerate(self):
      if figure != current_figure:
        current_figure = figure
        chord = sequence.text_annotations.add()
        chord.time = step * seconds_per_step + sequence_start_time
        chord.text = figure
        chord.annotation_type = CHORD_SYMBOL

    return sequence

  def transpose(self, transpose_amount):
    &#34;&#34;&#34;Transpose chords in this ChordProgression.

    Args:
      transpose_amount: The number of half steps to transpose this
          ChordProgression. Positive values transpose up. Negative values
          transpose down.

    Raises:
      ChordSymbolError: If a chord (other than &#34;no chord&#34;) fails to be
          interpreted by the `chord_symbols_lib` module.
    &#34;&#34;&#34;
    for i in range(len(self._events)):
      if self._events[i] != NO_CHORD:
        self._events[i] = chord_symbols_lib.transpose_chord_symbol(
            self._events[i], transpose_amount % NOTES_PER_OCTAVE)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.events_lib.SimpleEventSequence" href="events_lib.html#note_seq.events_lib.SimpleEventSequence">SimpleEventSequence</a></li>
<li><a title="note_seq.events_lib.EventSequence" href="events_lib.html#note_seq.events_lib.EventSequence">EventSequence</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.chords_lib.ChordProgression.from_quantized_sequence"><code class="name flex">
<span>def <span class="ident">from_quantized_sequence</span></span>(<span>self, quantized_sequence, start_step, end_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Populate self with the chords from the given quantized NoteSequence.</p>
<p>A chord progression is extracted from the given sequence starting at time
step <code>start_step</code> and ending at time step <code>end_step</code>.</p>
<p>The number of time steps per bar is computed from the time signature in
<code>quantized_sequence</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quantized_sequence</code></strong></dt>
<dd>A quantized NoteSequence instance.</dd>
<dt><strong><code>start_step</code></strong></dt>
<dd>Start populating chords at this time step.</dd>
<dt><strong><code>end_step</code></strong></dt>
<dd>Stop populating chords at this time step.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NonIntegerStepsPerBarError</code></dt>
<dd>If <code>quantized_sequence</code>'s bar length
(derived from its time signature) is not an integer number of time
steps.</dd>
<dt><code><a title="note_seq.chords_lib.CoincidentChordsError" href="#note_seq.chords_lib.CoincidentChordsError">CoincidentChordsError</a></code></dt>
<dd>If any of the chords start on the same step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_quantized_sequence(self, quantized_sequence, start_step, end_step):
  &#34;&#34;&#34;Populate self with the chords from the given quantized NoteSequence.

  A chord progression is extracted from the given sequence starting at time
  step `start_step` and ending at time step `end_step`.

  The number of time steps per bar is computed from the time signature in
  `quantized_sequence`.

  Args:
    quantized_sequence: A quantized NoteSequence instance.
    start_step: Start populating chords at this time step.
    end_step: Stop populating chords at this time step.

  Raises:
    NonIntegerStepsPerBarError: If `quantized_sequence`&#39;s bar length
        (derived from its time signature) is not an integer number of time
        steps.
    CoincidentChordsError: If any of the chords start on the same step.
  &#34;&#34;&#34;
  sequences_lib.assert_is_relative_quantized_sequence(quantized_sequence)
  self._reset()

  steps_per_bar_float = sequences_lib.steps_per_bar_in_quantized_sequence(
      quantized_sequence)
  if steps_per_bar_float % 1 != 0:
    raise events_lib.NonIntegerStepsPerBarError(
        &#39;There are %f timesteps per bar. Time signature: %d/%d&#39; %
        (steps_per_bar_float, quantized_sequence.time_signature.numerator,
         quantized_sequence.time_signature.denominator))
  self._steps_per_bar = int(steps_per_bar_float)
  self._steps_per_quarter = (
      quantized_sequence.quantization_info.steps_per_quarter)

  # Sort track by chord times.
  chords = sorted([a for a in quantized_sequence.text_annotations
                   if a.annotation_type == CHORD_SYMBOL],
                  key=lambda chord: chord.quantized_step)

  prev_step = None
  prev_figure = NO_CHORD

  for chord in chords:
    if chord.quantized_step &gt;= end_step:
      # No more chords within range.
      break

    elif chord.quantized_step &lt; start_step:
      # Chord is before start of range.
      prev_step = chord.quantized_step
      prev_figure = chord.text
      continue

    if chord.quantized_step == prev_step:
      if chord.text == prev_figure:
        # Identical coincident chords, just skip.
        continue
      else:
        # Two different chords start at the same time step.
        self._reset()
        raise CoincidentChordsError(
            &#39;chords %s and %s are coincident&#39; % (prev_figure, chord.text))

    if chord.quantized_step &gt; start_step:
      # Add the previous chord.
      if prev_step is None:
        start_index = 0
      else:
        start_index = max(prev_step, start_step) - start_step
      end_index = chord.quantized_step - start_step
      self._add_chord(prev_figure, start_index, end_index)

    prev_step = chord.quantized_step
    prev_figure = chord.text

  if prev_step is None or prev_step &lt; end_step:
    # Add the last chord active before end_step.
    if prev_step is None:
      start_index = 0
    else:
      start_index = max(prev_step, start_step) - start_step
    end_index = end_step - start_step
    self._add_chord(prev_figure, start_index, end_index)

  self._start_step = start_step
  self._end_step = end_step</code></pre>
</details>
</dd>
<dt id="note_seq.chords_lib.ChordProgression.to_sequence"><code class="name flex">
<span>def <span class="ident">to_sequence</span></span>(<span>self, sequence_start_time=0.0, qpm=120.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the ChordProgression to NoteSequence proto.</p>
<p>This doesn't generate actual notes, but text annotations specifying the
chord changes when they occur.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sequence_start_time</code></strong></dt>
<dd>A time in seconds (float) that the first chord in
the sequence will land on.</dd>
<dt><strong><code>qpm</code></strong></dt>
<dd>Quarter notes per minute (float).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A NoteSequence proto encoding the given chords as text annotations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_sequence(self,
                sequence_start_time=0.0,
                qpm=120.0):
  &#34;&#34;&#34;Converts the ChordProgression to NoteSequence proto.

  This doesn&#39;t generate actual notes, but text annotations specifying the
  chord changes when they occur.

  Args:
    sequence_start_time: A time in seconds (float) that the first chord in
        the sequence will land on.
    qpm: Quarter notes per minute (float).

  Returns:
    A NoteSequence proto encoding the given chords as text annotations.
  &#34;&#34;&#34;
  seconds_per_step = 60.0 / qpm / self.steps_per_quarter

  sequence = music_pb2.NoteSequence()
  sequence.tempos.add().qpm = qpm
  sequence.ticks_per_quarter = STANDARD_PPQ

  current_figure = NO_CHORD
  for step, figure in enumerate(self):
    if figure != current_figure:
      current_figure = figure
      chord = sequence.text_annotations.add()
      chord.time = step * seconds_per_step + sequence_start_time
      chord.text = figure
      chord.annotation_type = CHORD_SYMBOL

  return sequence</code></pre>
</details>
</dd>
<dt id="note_seq.chords_lib.ChordProgression.transpose"><code class="name flex">
<span>def <span class="ident">transpose</span></span>(<span>self, transpose_amount)</span>
</code></dt>
<dd>
<div class="desc"><p>Transpose chords in this ChordProgression.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transpose_amount</code></strong></dt>
<dd>The number of half steps to transpose this
ChordProgression. Positive values transpose up. Negative values
transpose down.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ChordSymbolError</code></dt>
<dd>If a chord (other than "no chord") fails to be
interpreted by the <code>chord_symbols_lib</code> module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose(self, transpose_amount):
  &#34;&#34;&#34;Transpose chords in this ChordProgression.

  Args:
    transpose_amount: The number of half steps to transpose this
        ChordProgression. Positive values transpose up. Negative values
        transpose down.

  Raises:
    ChordSymbolError: If a chord (other than &#34;no chord&#34;) fails to be
        interpreted by the `chord_symbols_lib` module.
  &#34;&#34;&#34;
  for i in range(len(self._events)):
    if self._events[i] != NO_CHORD:
      self._events[i] = chord_symbols_lib.transpose_chord_symbol(
          self._events[i], transpose_amount % NOTES_PER_OCTAVE)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="note_seq.events_lib.SimpleEventSequence" href="events_lib.html#note_seq.events_lib.SimpleEventSequence">SimpleEventSequence</a></b></code>:
<ul class="hlist">
<li><code><a title="note_seq.events_lib.SimpleEventSequence.append" href="events_lib.html#note_seq.events_lib.SimpleEventSequence.append">append</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.increase_resolution" href="events_lib.html#note_seq.events_lib.SimpleEventSequence.increase_resolution">increase_resolution</a></code></li>
<li><code><a title="note_seq.events_lib.SimpleEventSequence.set_length" href="events_lib.html#note_seq.events_lib.SimpleEventSequence.set_length">set_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="note_seq.chords_lib.ChordRenderer"><code class="flex name class">
<span>class <span class="ident">ChordRenderer</span></span>
</code></dt>
<dd>
<div class="desc"><p>An abstract class for rendering NoteSequence chord symbols as notes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChordRenderer(object):
  &#34;&#34;&#34;An abstract class for rendering NoteSequence chord symbols as notes.&#34;&#34;&#34;
  __metaclass__ = abc.ABCMeta

  @abc.abstractmethod
  def render(self, sequence):
    &#34;&#34;&#34;Renders the chord symbols of a NoteSequence.

    This function renders chord symbol annotations in a NoteSequence as actual
    notes. Notes are added to the NoteSequence object, and the chord symbols
    remain also.

    Args:
      sequence: The NoteSequence for which to render chord symbols.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="note_seq.chords_lib.BasicChordRenderer" href="#note_seq.chords_lib.BasicChordRenderer">BasicChordRenderer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.chords_lib.ChordRenderer.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, sequence)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders the chord symbols of a NoteSequence.</p>
<p>This function renders chord symbol annotations in a NoteSequence as actual
notes. Notes are added to the NoteSequence object, and the chord symbols
remain also.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sequence</code></strong></dt>
<dd>The NoteSequence for which to render chord symbols.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def render(self, sequence):
  &#34;&#34;&#34;Renders the chord symbols of a NoteSequence.

  This function renders chord symbol annotations in a NoteSequence as actual
  notes. Notes are added to the NoteSequence object, and the chord symbols
  remain also.

  Args:
    sequence: The NoteSequence for which to render chord symbols.
  &#34;&#34;&#34;
  pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="note_seq.chords_lib.CoincidentChordsError"><code class="flex name class">
<span>class <span class="ident">CoincidentChordsError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoincidentChordsError(Exception):
  pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="note_seq.chords_lib.add_chords_to_sequence" href="#note_seq.chords_lib.add_chords_to_sequence">add_chords_to_sequence</a></code></li>
<li><code><a title="note_seq.chords_lib.add_keys_to_sequence" href="#note_seq.chords_lib.add_keys_to_sequence">add_keys_to_sequence</a></code></li>
<li><code><a title="note_seq.chords_lib.event_list_chords" href="#note_seq.chords_lib.event_list_chords">event_list_chords</a></code></li>
<li><code><a title="note_seq.chords_lib.event_list_keys" href="#note_seq.chords_lib.event_list_keys">event_list_keys</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.chords_lib.BadChordError" href="#note_seq.chords_lib.BadChordError">BadChordError</a></code></h4>
</li>
<li>
<h4><code><a title="note_seq.chords_lib.BasicChordRenderer" href="#note_seq.chords_lib.BasicChordRenderer">BasicChordRenderer</a></code></h4>
</li>
<li>
<h4><code><a title="note_seq.chords_lib.ChordProgression" href="#note_seq.chords_lib.ChordProgression">ChordProgression</a></code></h4>
<ul class="">
<li><code><a title="note_seq.chords_lib.ChordProgression.from_quantized_sequence" href="#note_seq.chords_lib.ChordProgression.from_quantized_sequence">from_quantized_sequence</a></code></li>
<li><code><a title="note_seq.chords_lib.ChordProgression.to_sequence" href="#note_seq.chords_lib.ChordProgression.to_sequence">to_sequence</a></code></li>
<li><code><a title="note_seq.chords_lib.ChordProgression.transpose" href="#note_seq.chords_lib.ChordProgression.transpose">transpose</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.chords_lib.ChordRenderer" href="#note_seq.chords_lib.ChordRenderer">ChordRenderer</a></code></h4>
<ul class="">
<li><code><a title="note_seq.chords_lib.ChordRenderer.render" href="#note_seq.chords_lib.ChordRenderer.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.chords_lib.CoincidentChordsError" href="#note_seq.chords_lib.CoincidentChordsError">CoincidentChordsError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>