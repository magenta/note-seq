<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.midi_io_test API documentation</title>
<meta name="description" content="Test to ensure correct midi input and output." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.midi_io_test</code></h1>
</header>
<section id="section-intro">
<p>Test to ensure correct midi input and output.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Test to ensure correct midi input and output.&#34;&#34;&#34;
import collections
import os.path
import tempfile

from absl.testing import absltest
import mido
from note_seq import constants
from note_seq import midi_io
from note_seq import testing_lib
from note_seq.protobuf import music_pb2
import pretty_midi

# self.midi_simple_filename contains a c-major scale of 8 quarter notes each
# with a sustain of .95 of the entire note. Here are the first two notes dumped
# using mididump.py:
#   midi.NoteOnEvent(tick=0, channel=0, data=[60, 100]),
#   midi.NoteOnEvent(tick=209, channel=0, data=[60, 0]),
#   midi.NoteOnEvent(tick=11, channel=0, data=[62, 100]),
#   midi.NoteOnEvent(tick=209, channel=0, data=[62, 0]),
_SIMPLE_MIDI_FILE_VELO = 100
_SIMPLE_MIDI_FILE_NUM_NOTES = 8
_SIMPLE_MIDI_FILE_SUSTAIN = .95

# self.midi_complex_filename contains many instruments including percussion as
# well as control change and pitch bend events.

# self.midi_is_drum_filename contains 41 tracks, two of which are on channel 9.

# self.midi_event_order_filename contains notes ordered
# non-monotonically by pitch.  Here are relevent events as printed by
# mididump.py:
#   midi.NoteOnEvent(tick=0, channel=0, data=[1, 100]),
#   midi.NoteOnEvent(tick=0, channel=0, data=[3, 100]),
#   midi.NoteOnEvent(tick=0, channel=0, data=[2, 100]),
#   midi.NoteOnEvent(tick=4400, channel=0, data=[3, 0]),
#   midi.NoteOnEvent(tick=0, channel=0, data=[1, 0]),
#   midi.NoteOnEvent(tick=0, channel=0, data=[2, 0]),


class MidiIoTest(absltest.TestCase):

  def setUp(self):
    super().setUp()
    self.midi_simple_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example.mid&#39;)
    self.midi_complex_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example_complex.mid&#39;)
    self.midi_is_drum_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example_is_drum.mid&#39;)
    self.midi_event_order_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example_event_order.mid&#39;)

  def CheckPrettyMidiAndSequence(self, midi, sequence_proto):
    &#34;&#34;&#34;Compares PrettyMIDI object against a sequence proto.

    Args:
      midi: A pretty_midi.PrettyMIDI object.
      sequence_proto: A NoteSequence proto.
    &#34;&#34;&#34;
    # Test time signature changes.
    self.assertEqual(len(midi.time_signature_changes),
                     len(sequence_proto.time_signatures))
    for midi_time, sequence_time in zip(midi.time_signature_changes,
                                        sequence_proto.time_signatures):
      self.assertEqual(midi_time.numerator, sequence_time.numerator)
      self.assertEqual(midi_time.denominator, sequence_time.denominator)
      self.assertAlmostEqual(midi_time.time, sequence_time.time)

    # Test key signature changes.
    self.assertEqual(len(midi.key_signature_changes),
                     len(sequence_proto.key_signatures))
    for midi_key, sequence_key in zip(midi.key_signature_changes,
                                      sequence_proto.key_signatures):
      self.assertEqual(midi_key.key_number % 12, sequence_key.key)
      self.assertEqual(midi_key.key_number // 12, sequence_key.mode)
      self.assertAlmostEqual(midi_key.time, sequence_key.time)

    # Test tempos.
    midi_times, midi_qpms = midi.get_tempo_changes()
    self.assertEqual(len(midi_times),
                     len(sequence_proto.tempos))
    self.assertEqual(len(midi_qpms),
                     len(sequence_proto.tempos))
    for midi_time, midi_qpm, sequence_tempo in zip(
        midi_times, midi_qpms, sequence_proto.tempos):
      self.assertAlmostEqual(midi_qpm, sequence_tempo.qpm)
      self.assertAlmostEqual(midi_time, sequence_tempo.time)

    # Test instruments.
    seq_instruments = collections.defaultdict(
        lambda: collections.defaultdict(list))
    for seq_note in sequence_proto.notes:
      seq_instruments[
          (seq_note.instrument, seq_note.program, seq_note.is_drum)][
              &#39;notes&#39;].append(seq_note)
    for seq_bend in sequence_proto.pitch_bends:
      seq_instruments[
          (seq_bend.instrument, seq_bend.program, seq_bend.is_drum)][
              &#39;bends&#39;].append(seq_bend)
    for seq_control in sequence_proto.control_changes:
      seq_instruments[
          (seq_control.instrument, seq_control.program, seq_control.is_drum)][
              &#39;controls&#39;].append(seq_control)

    sorted_seq_instrument_keys = sorted(seq_instruments.keys())

    if seq_instruments:
      self.assertEqual(len(midi.instruments), len(seq_instruments))
    else:
      self.assertLen(midi.instruments, 1)
      self.assertEmpty(midi.instruments[0].notes)
      self.assertEmpty(midi.instruments[0].pitch_bends)

    for midi_instrument, seq_instrument_key in zip(
        midi.instruments, sorted_seq_instrument_keys):

      seq_instrument_notes = seq_instruments[seq_instrument_key][&#39;notes&#39;]

      self.assertEqual(len(midi_instrument.notes), len(seq_instrument_notes))
      for midi_note, sequence_note in zip(midi_instrument.notes,
                                          seq_instrument_notes):
        self.assertEqual(midi_note.pitch, sequence_note.pitch)
        self.assertEqual(midi_note.velocity, sequence_note.velocity)
        self.assertAlmostEqual(midi_note.start, sequence_note.start_time)
        self.assertAlmostEqual(midi_note.end, sequence_note.end_time)

      seq_instrument_pitch_bends = seq_instruments[seq_instrument_key][&#39;bends&#39;]
      self.assertEqual(len(midi_instrument.pitch_bends),
                       len(seq_instrument_pitch_bends))
      for midi_pitch_bend, sequence_pitch_bend in zip(
          midi_instrument.pitch_bends,
          seq_instrument_pitch_bends):
        self.assertEqual(midi_pitch_bend.pitch, sequence_pitch_bend.bend)
        self.assertAlmostEqual(midi_pitch_bend.time, sequence_pitch_bend.time)

  def CheckMidiToSequence(self, filename):
    &#34;&#34;&#34;Test the translation from PrettyMIDI to Sequence proto.&#34;&#34;&#34;
    source_midi = pretty_midi.PrettyMIDI(filename)
    sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    self.CheckPrettyMidiAndSequence(source_midi, sequence_proto)

  def CheckSequenceToPrettyMidi(self, filename):
    &#34;&#34;&#34;Test the translation from Sequence proto to PrettyMIDI.&#34;&#34;&#34;
    source_midi = pretty_midi.PrettyMIDI(filename)
    sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    translated_midi = midi_io.sequence_proto_to_pretty_midi(sequence_proto)
    self.CheckPrettyMidiAndSequence(translated_midi, sequence_proto)

  def CheckReadWriteMidi(self, filename):
    &#34;&#34;&#34;Test writing to a MIDI file and comparing it to the original Sequence.&#34;&#34;&#34;

    # TODO(deck): The input MIDI file is opened in pretty-midi and
    # re-written to a temp file, sanitizing the MIDI data (reordering
    # note ons, etc). Issue 85 in the pretty-midi GitHub
    # (http://github.com/craffel/pretty-midi/issues/85) requests that
    # this sanitization be available outside of the context of a file
    # write. If that is implemented, this rewrite code should be
    # modified or deleted.

    # When writing to the temp file, use the file object itself instead of
    # file.name to avoid the permission error on Windows.
    with tempfile.NamedTemporaryFile(prefix=&#39;MidiIoTest&#39;) as rewrite_file:
      original_midi = pretty_midi.PrettyMIDI(filename)
      original_midi.write(rewrite_file)  # Use file object
      # Back the file position to top to reload the rewrite_file
      rewrite_file.seek(0)
      source_midi = pretty_midi.PrettyMIDI(rewrite_file)  # Use file object
      sequence_proto = midi_io.midi_to_sequence_proto(source_midi)

    # Translate the NoteSequence to MIDI and write to a file.
    with tempfile.NamedTemporaryFile(prefix=&#39;MidiIoTest&#39;) as temp_file:
      midi_io.sequence_proto_to_midi_file(sequence_proto, temp_file.name)
      # Read it back in and compare to source.
      created_midi = pretty_midi.PrettyMIDI(temp_file)  # Use file object

    self.CheckPrettyMidiAndSequence(created_midi, sequence_proto)

  def testSimplePrettyMidiToSequence(self):
    self.CheckMidiToSequence(self.midi_simple_filename)

  def testSimpleSequenceToPrettyMidi(self):
    self.CheckSequenceToPrettyMidi(self.midi_simple_filename)

  def testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    stripped_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    del stripped_sequence_proto.tempos[:]
    stripped_sequence_proto.ClearField(&#39;ticks_per_quarter&#39;)

    expected_sequence_proto = music_pb2.NoteSequence()
    expected_sequence_proto.CopyFrom(stripped_sequence_proto)
    expected_sequence_proto.tempos.add(
        qpm=constants.DEFAULT_QUARTERS_PER_MINUTE)
    expected_sequence_proto.ticks_per_quarter = constants.STANDARD_PPQ

    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        stripped_sequence_proto)

    self.CheckPrettyMidiAndSequence(translated_midi, expected_sequence_proto)

  def testSimpleSequenceToPrettyMidi_MultipleTempos(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
    multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto)

    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  def testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    del multi_tempo_sequence_proto.tempos[:]
    multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
    multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto)

    # Translating to MIDI adds an implicit DEFAULT_QUARTERS_PER_MINUTE tempo
    # at time 0, so recreate the list with that in place.
    del multi_tempo_sequence_proto.tempos[:]
    multi_tempo_sequence_proto.tempos.add(
        time=0.0, qpm=constants.DEFAULT_QUARTERS_PER_MINUTE)
    multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
    multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  def testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    # Add a final tempo long after the last note.
    multi_tempo_sequence_proto.tempos.add(time=600.0, qpm=120)

    # Translate without dropping.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto)
    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

    # Translate dropping anything after the last note.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto, drop_events_n_seconds_after_last_note=0)
    # The added tempo should have been dropped.
    del multi_tempo_sequence_proto.tempos[-1]
    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

    # Add a final tempo 15 seconds after the last note.
    last_note_time = max([n.end_time for n in multi_tempo_sequence_proto.notes])
    multi_tempo_sequence_proto.tempos.add(time=last_note_time + 15, qpm=120)
    # Translate dropping anything 30 seconds after the last note, which should
    # preserve the added tempo.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto, drop_events_n_seconds_after_last_note=30)
    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  def testEmptySequenceToPrettyMidi_DropEventsAfterLastNote(self):
    source_sequence = music_pb2.NoteSequence()

    # Translate without dropping.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence)
    self.assertLen(translated_midi.instruments, 1)
    self.assertEmpty(translated_midi.instruments[0].notes)

    # Translate dropping anything after 30 seconds.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence, drop_events_n_seconds_after_last_note=30)
    self.assertLen(translated_midi.instruments, 1)
    self.assertEmpty(translated_midi.instruments[0].notes)

  def testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote(self):
    source_sequence = music_pb2.NoteSequence()
    source_sequence.tempos.add(time=0, qpm=120)
    source_sequence.tempos.add(time=10, qpm=160)
    source_sequence.tempos.add(time=40, qpm=240)

    # Translate without dropping.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence)
    self.CheckPrettyMidiAndSequence(translated_midi, source_sequence)

    # Translate dropping anything after 30 seconds.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence, drop_events_n_seconds_after_last_note=30)
    del source_sequence.tempos[-1]
    self.CheckPrettyMidiAndSequence(translated_midi, source_sequence)

  def testSimpleReadWriteMidi(self):
    self.CheckReadWriteMidi(self.midi_simple_filename)

  def testComplexPrettyMidiToSequence(self):
    self.CheckMidiToSequence(self.midi_complex_filename)

  def testComplexSequenceToPrettyMidi(self):
    self.CheckSequenceToPrettyMidi(self.midi_complex_filename)

  def testIsDrumDetection(self):
    &#34;&#34;&#34;Verify that is_drum instruments are properly tracked.

    self.midi_is_drum_filename is a MIDI file containing two tracks
    set to channel 9 (is_drum == True). Each contains one NoteOn. This
    test is designed to catch a bug where the second track would lose
    is_drum, remapping the drum track to an instrument track.
    &#34;&#34;&#34;
    sequence_proto = midi_io.midi_file_to_sequence_proto(
        self.midi_is_drum_filename)
    with tempfile.NamedTemporaryFile(prefix=&#39;MidiDrumTest&#39;) as temp_file:
      midi_io.sequence_proto_to_midi_file(sequence_proto, temp_file.name)
      midi_data1 = mido.MidiFile(filename=self.midi_is_drum_filename)
      # Use the file object when writing to the tempfile
      # to avoid permission error.
      midi_data2 = mido.MidiFile(file=temp_file)

    # Count number of channel 9 Note Ons.
    channel_counts = [0, 0]
    for index, midi_data in enumerate([midi_data1, midi_data2]):
      for event in midi_data:
        if (event.type == &#39;note_on&#39; and
            event.velocity &gt; 0 and event.channel == 9):
          channel_counts[index] += 1
    self.assertEqual(channel_counts, [2, 2])

  def testInstrumentInfo_NoteSequenceToPrettyMidi(self):
    source_sequence = music_pb2.NoteSequence()
    source_sequence.notes.add(
        pitch=60, start_time=0.0, end_time=0.5, velocity=80, instrument=0)
    source_sequence.notes.add(
        pitch=60, start_time=0.5, end_time=1.0, velocity=80, instrument=1)
    instrument_info1 = source_sequence.instrument_infos.add()
    instrument_info1.name = &#39;inst_0&#39;
    instrument_info1.instrument = 0
    instrument_info2 = source_sequence.instrument_infos.add()
    instrument_info2.name = &#39;inst_1&#39;
    instrument_info2.instrument = 1
    translated_midi = midi_io.sequence_proto_to_pretty_midi(source_sequence)
    translated_sequence = midi_io.midi_to_note_sequence(translated_midi)

    self.assertEqual(
        len(source_sequence.instrument_infos),
        len(translated_sequence.instrument_infos))
    self.assertEqual(source_sequence.instrument_infos[0].name,
                     translated_sequence.instrument_infos[0].name)
    self.assertEqual(source_sequence.instrument_infos[1].name,
                     translated_sequence.instrument_infos[1].name)

  def testComplexReadWriteMidi(self):
    self.CheckReadWriteMidi(self.midi_complex_filename)

  def testEventOrdering(self):
    self.CheckReadWriteMidi(self.midi_event_order_filename)


if __name__ == &#39;__main__&#39;:
  absltest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.midi_io_test.MidiIoTest"><code class="flex name class">
<span>class <span class="ident">MidiIoTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of unittest.TestCase providing more power.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MidiIoTest(absltest.TestCase):

  def setUp(self):
    super().setUp()
    self.midi_simple_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example.mid&#39;)
    self.midi_complex_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example_complex.mid&#39;)
    self.midi_is_drum_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example_is_drum.mid&#39;)
    self.midi_event_order_filename = os.path.join(
        testing_lib.get_testdata_dir(), &#39;example_event_order.mid&#39;)

  def CheckPrettyMidiAndSequence(self, midi, sequence_proto):
    &#34;&#34;&#34;Compares PrettyMIDI object against a sequence proto.

    Args:
      midi: A pretty_midi.PrettyMIDI object.
      sequence_proto: A NoteSequence proto.
    &#34;&#34;&#34;
    # Test time signature changes.
    self.assertEqual(len(midi.time_signature_changes),
                     len(sequence_proto.time_signatures))
    for midi_time, sequence_time in zip(midi.time_signature_changes,
                                        sequence_proto.time_signatures):
      self.assertEqual(midi_time.numerator, sequence_time.numerator)
      self.assertEqual(midi_time.denominator, sequence_time.denominator)
      self.assertAlmostEqual(midi_time.time, sequence_time.time)

    # Test key signature changes.
    self.assertEqual(len(midi.key_signature_changes),
                     len(sequence_proto.key_signatures))
    for midi_key, sequence_key in zip(midi.key_signature_changes,
                                      sequence_proto.key_signatures):
      self.assertEqual(midi_key.key_number % 12, sequence_key.key)
      self.assertEqual(midi_key.key_number // 12, sequence_key.mode)
      self.assertAlmostEqual(midi_key.time, sequence_key.time)

    # Test tempos.
    midi_times, midi_qpms = midi.get_tempo_changes()
    self.assertEqual(len(midi_times),
                     len(sequence_proto.tempos))
    self.assertEqual(len(midi_qpms),
                     len(sequence_proto.tempos))
    for midi_time, midi_qpm, sequence_tempo in zip(
        midi_times, midi_qpms, sequence_proto.tempos):
      self.assertAlmostEqual(midi_qpm, sequence_tempo.qpm)
      self.assertAlmostEqual(midi_time, sequence_tempo.time)

    # Test instruments.
    seq_instruments = collections.defaultdict(
        lambda: collections.defaultdict(list))
    for seq_note in sequence_proto.notes:
      seq_instruments[
          (seq_note.instrument, seq_note.program, seq_note.is_drum)][
              &#39;notes&#39;].append(seq_note)
    for seq_bend in sequence_proto.pitch_bends:
      seq_instruments[
          (seq_bend.instrument, seq_bend.program, seq_bend.is_drum)][
              &#39;bends&#39;].append(seq_bend)
    for seq_control in sequence_proto.control_changes:
      seq_instruments[
          (seq_control.instrument, seq_control.program, seq_control.is_drum)][
              &#39;controls&#39;].append(seq_control)

    sorted_seq_instrument_keys = sorted(seq_instruments.keys())

    if seq_instruments:
      self.assertEqual(len(midi.instruments), len(seq_instruments))
    else:
      self.assertLen(midi.instruments, 1)
      self.assertEmpty(midi.instruments[0].notes)
      self.assertEmpty(midi.instruments[0].pitch_bends)

    for midi_instrument, seq_instrument_key in zip(
        midi.instruments, sorted_seq_instrument_keys):

      seq_instrument_notes = seq_instruments[seq_instrument_key][&#39;notes&#39;]

      self.assertEqual(len(midi_instrument.notes), len(seq_instrument_notes))
      for midi_note, sequence_note in zip(midi_instrument.notes,
                                          seq_instrument_notes):
        self.assertEqual(midi_note.pitch, sequence_note.pitch)
        self.assertEqual(midi_note.velocity, sequence_note.velocity)
        self.assertAlmostEqual(midi_note.start, sequence_note.start_time)
        self.assertAlmostEqual(midi_note.end, sequence_note.end_time)

      seq_instrument_pitch_bends = seq_instruments[seq_instrument_key][&#39;bends&#39;]
      self.assertEqual(len(midi_instrument.pitch_bends),
                       len(seq_instrument_pitch_bends))
      for midi_pitch_bend, sequence_pitch_bend in zip(
          midi_instrument.pitch_bends,
          seq_instrument_pitch_bends):
        self.assertEqual(midi_pitch_bend.pitch, sequence_pitch_bend.bend)
        self.assertAlmostEqual(midi_pitch_bend.time, sequence_pitch_bend.time)

  def CheckMidiToSequence(self, filename):
    &#34;&#34;&#34;Test the translation from PrettyMIDI to Sequence proto.&#34;&#34;&#34;
    source_midi = pretty_midi.PrettyMIDI(filename)
    sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    self.CheckPrettyMidiAndSequence(source_midi, sequence_proto)

  def CheckSequenceToPrettyMidi(self, filename):
    &#34;&#34;&#34;Test the translation from Sequence proto to PrettyMIDI.&#34;&#34;&#34;
    source_midi = pretty_midi.PrettyMIDI(filename)
    sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    translated_midi = midi_io.sequence_proto_to_pretty_midi(sequence_proto)
    self.CheckPrettyMidiAndSequence(translated_midi, sequence_proto)

  def CheckReadWriteMidi(self, filename):
    &#34;&#34;&#34;Test writing to a MIDI file and comparing it to the original Sequence.&#34;&#34;&#34;

    # TODO(deck): The input MIDI file is opened in pretty-midi and
    # re-written to a temp file, sanitizing the MIDI data (reordering
    # note ons, etc). Issue 85 in the pretty-midi GitHub
    # (http://github.com/craffel/pretty-midi/issues/85) requests that
    # this sanitization be available outside of the context of a file
    # write. If that is implemented, this rewrite code should be
    # modified or deleted.

    # When writing to the temp file, use the file object itself instead of
    # file.name to avoid the permission error on Windows.
    with tempfile.NamedTemporaryFile(prefix=&#39;MidiIoTest&#39;) as rewrite_file:
      original_midi = pretty_midi.PrettyMIDI(filename)
      original_midi.write(rewrite_file)  # Use file object
      # Back the file position to top to reload the rewrite_file
      rewrite_file.seek(0)
      source_midi = pretty_midi.PrettyMIDI(rewrite_file)  # Use file object
      sequence_proto = midi_io.midi_to_sequence_proto(source_midi)

    # Translate the NoteSequence to MIDI and write to a file.
    with tempfile.NamedTemporaryFile(prefix=&#39;MidiIoTest&#39;) as temp_file:
      midi_io.sequence_proto_to_midi_file(sequence_proto, temp_file.name)
      # Read it back in and compare to source.
      created_midi = pretty_midi.PrettyMIDI(temp_file)  # Use file object

    self.CheckPrettyMidiAndSequence(created_midi, sequence_proto)

  def testSimplePrettyMidiToSequence(self):
    self.CheckMidiToSequence(self.midi_simple_filename)

  def testSimpleSequenceToPrettyMidi(self):
    self.CheckSequenceToPrettyMidi(self.midi_simple_filename)

  def testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    stripped_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    del stripped_sequence_proto.tempos[:]
    stripped_sequence_proto.ClearField(&#39;ticks_per_quarter&#39;)

    expected_sequence_proto = music_pb2.NoteSequence()
    expected_sequence_proto.CopyFrom(stripped_sequence_proto)
    expected_sequence_proto.tempos.add(
        qpm=constants.DEFAULT_QUARTERS_PER_MINUTE)
    expected_sequence_proto.ticks_per_quarter = constants.STANDARD_PPQ

    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        stripped_sequence_proto)

    self.CheckPrettyMidiAndSequence(translated_midi, expected_sequence_proto)

  def testSimpleSequenceToPrettyMidi_MultipleTempos(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
    multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto)

    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  def testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    del multi_tempo_sequence_proto.tempos[:]
    multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
    multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto)

    # Translating to MIDI adds an implicit DEFAULT_QUARTERS_PER_MINUTE tempo
    # at time 0, so recreate the list with that in place.
    del multi_tempo_sequence_proto.tempos[:]
    multi_tempo_sequence_proto.tempos.add(
        time=0.0, qpm=constants.DEFAULT_QUARTERS_PER_MINUTE)
    multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
    multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  def testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote(self):
    source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
    multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
    # Add a final tempo long after the last note.
    multi_tempo_sequence_proto.tempos.add(time=600.0, qpm=120)

    # Translate without dropping.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto)
    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

    # Translate dropping anything after the last note.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto, drop_events_n_seconds_after_last_note=0)
    # The added tempo should have been dropped.
    del multi_tempo_sequence_proto.tempos[-1]
    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

    # Add a final tempo 15 seconds after the last note.
    last_note_time = max([n.end_time for n in multi_tempo_sequence_proto.notes])
    multi_tempo_sequence_proto.tempos.add(time=last_note_time + 15, qpm=120)
    # Translate dropping anything 30 seconds after the last note, which should
    # preserve the added tempo.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        multi_tempo_sequence_proto, drop_events_n_seconds_after_last_note=30)
    self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  def testEmptySequenceToPrettyMidi_DropEventsAfterLastNote(self):
    source_sequence = music_pb2.NoteSequence()

    # Translate without dropping.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence)
    self.assertLen(translated_midi.instruments, 1)
    self.assertEmpty(translated_midi.instruments[0].notes)

    # Translate dropping anything after 30 seconds.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence, drop_events_n_seconds_after_last_note=30)
    self.assertLen(translated_midi.instruments, 1)
    self.assertEmpty(translated_midi.instruments[0].notes)

  def testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote(self):
    source_sequence = music_pb2.NoteSequence()
    source_sequence.tempos.add(time=0, qpm=120)
    source_sequence.tempos.add(time=10, qpm=160)
    source_sequence.tempos.add(time=40, qpm=240)

    # Translate without dropping.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence)
    self.CheckPrettyMidiAndSequence(translated_midi, source_sequence)

    # Translate dropping anything after 30 seconds.
    translated_midi = midi_io.sequence_proto_to_pretty_midi(
        source_sequence, drop_events_n_seconds_after_last_note=30)
    del source_sequence.tempos[-1]
    self.CheckPrettyMidiAndSequence(translated_midi, source_sequence)

  def testSimpleReadWriteMidi(self):
    self.CheckReadWriteMidi(self.midi_simple_filename)

  def testComplexPrettyMidiToSequence(self):
    self.CheckMidiToSequence(self.midi_complex_filename)

  def testComplexSequenceToPrettyMidi(self):
    self.CheckSequenceToPrettyMidi(self.midi_complex_filename)

  def testIsDrumDetection(self):
    &#34;&#34;&#34;Verify that is_drum instruments are properly tracked.

    self.midi_is_drum_filename is a MIDI file containing two tracks
    set to channel 9 (is_drum == True). Each contains one NoteOn. This
    test is designed to catch a bug where the second track would lose
    is_drum, remapping the drum track to an instrument track.
    &#34;&#34;&#34;
    sequence_proto = midi_io.midi_file_to_sequence_proto(
        self.midi_is_drum_filename)
    with tempfile.NamedTemporaryFile(prefix=&#39;MidiDrumTest&#39;) as temp_file:
      midi_io.sequence_proto_to_midi_file(sequence_proto, temp_file.name)
      midi_data1 = mido.MidiFile(filename=self.midi_is_drum_filename)
      # Use the file object when writing to the tempfile
      # to avoid permission error.
      midi_data2 = mido.MidiFile(file=temp_file)

    # Count number of channel 9 Note Ons.
    channel_counts = [0, 0]
    for index, midi_data in enumerate([midi_data1, midi_data2]):
      for event in midi_data:
        if (event.type == &#39;note_on&#39; and
            event.velocity &gt; 0 and event.channel == 9):
          channel_counts[index] += 1
    self.assertEqual(channel_counts, [2, 2])

  def testInstrumentInfo_NoteSequenceToPrettyMidi(self):
    source_sequence = music_pb2.NoteSequence()
    source_sequence.notes.add(
        pitch=60, start_time=0.0, end_time=0.5, velocity=80, instrument=0)
    source_sequence.notes.add(
        pitch=60, start_time=0.5, end_time=1.0, velocity=80, instrument=1)
    instrument_info1 = source_sequence.instrument_infos.add()
    instrument_info1.name = &#39;inst_0&#39;
    instrument_info1.instrument = 0
    instrument_info2 = source_sequence.instrument_infos.add()
    instrument_info2.name = &#39;inst_1&#39;
    instrument_info2.instrument = 1
    translated_midi = midi_io.sequence_proto_to_pretty_midi(source_sequence)
    translated_sequence = midi_io.midi_to_note_sequence(translated_midi)

    self.assertEqual(
        len(source_sequence.instrument_infos),
        len(translated_sequence.instrument_infos))
    self.assertEqual(source_sequence.instrument_infos[0].name,
                     translated_sequence.instrument_infos[0].name)
    self.assertEqual(source_sequence.instrument_infos[1].name,
                     translated_sequence.instrument_infos[1].name)

  def testComplexReadWriteMidi(self):
    self.CheckReadWriteMidi(self.midi_complex_filename)

  def testEventOrdering(self):
    self.CheckReadWriteMidi(self.midi_event_order_filename)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.midi_io_test.MidiIoTest.CheckMidiToSequence"><code class="name flex">
<span>def <span class="ident">CheckMidiToSequence</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Test the translation from PrettyMIDI to Sequence proto.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckMidiToSequence(self, filename):
  &#34;&#34;&#34;Test the translation from PrettyMIDI to Sequence proto.&#34;&#34;&#34;
  source_midi = pretty_midi.PrettyMIDI(filename)
  sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
  self.CheckPrettyMidiAndSequence(source_midi, sequence_proto)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.CheckPrettyMidiAndSequence"><code class="name flex">
<span>def <span class="ident">CheckPrettyMidiAndSequence</span></span>(<span>self, midi, sequence_proto)</span>
</code></dt>
<dd>
<div class="desc"><p>Compares PrettyMIDI object against a sequence proto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>midi</code></strong></dt>
<dd>A pretty_midi.PrettyMIDI object.</dd>
<dt><strong><code>sequence_proto</code></strong></dt>
<dd>A NoteSequence proto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckPrettyMidiAndSequence(self, midi, sequence_proto):
  &#34;&#34;&#34;Compares PrettyMIDI object against a sequence proto.

  Args:
    midi: A pretty_midi.PrettyMIDI object.
    sequence_proto: A NoteSequence proto.
  &#34;&#34;&#34;
  # Test time signature changes.
  self.assertEqual(len(midi.time_signature_changes),
                   len(sequence_proto.time_signatures))
  for midi_time, sequence_time in zip(midi.time_signature_changes,
                                      sequence_proto.time_signatures):
    self.assertEqual(midi_time.numerator, sequence_time.numerator)
    self.assertEqual(midi_time.denominator, sequence_time.denominator)
    self.assertAlmostEqual(midi_time.time, sequence_time.time)

  # Test key signature changes.
  self.assertEqual(len(midi.key_signature_changes),
                   len(sequence_proto.key_signatures))
  for midi_key, sequence_key in zip(midi.key_signature_changes,
                                    sequence_proto.key_signatures):
    self.assertEqual(midi_key.key_number % 12, sequence_key.key)
    self.assertEqual(midi_key.key_number // 12, sequence_key.mode)
    self.assertAlmostEqual(midi_key.time, sequence_key.time)

  # Test tempos.
  midi_times, midi_qpms = midi.get_tempo_changes()
  self.assertEqual(len(midi_times),
                   len(sequence_proto.tempos))
  self.assertEqual(len(midi_qpms),
                   len(sequence_proto.tempos))
  for midi_time, midi_qpm, sequence_tempo in zip(
      midi_times, midi_qpms, sequence_proto.tempos):
    self.assertAlmostEqual(midi_qpm, sequence_tempo.qpm)
    self.assertAlmostEqual(midi_time, sequence_tempo.time)

  # Test instruments.
  seq_instruments = collections.defaultdict(
      lambda: collections.defaultdict(list))
  for seq_note in sequence_proto.notes:
    seq_instruments[
        (seq_note.instrument, seq_note.program, seq_note.is_drum)][
            &#39;notes&#39;].append(seq_note)
  for seq_bend in sequence_proto.pitch_bends:
    seq_instruments[
        (seq_bend.instrument, seq_bend.program, seq_bend.is_drum)][
            &#39;bends&#39;].append(seq_bend)
  for seq_control in sequence_proto.control_changes:
    seq_instruments[
        (seq_control.instrument, seq_control.program, seq_control.is_drum)][
            &#39;controls&#39;].append(seq_control)

  sorted_seq_instrument_keys = sorted(seq_instruments.keys())

  if seq_instruments:
    self.assertEqual(len(midi.instruments), len(seq_instruments))
  else:
    self.assertLen(midi.instruments, 1)
    self.assertEmpty(midi.instruments[0].notes)
    self.assertEmpty(midi.instruments[0].pitch_bends)

  for midi_instrument, seq_instrument_key in zip(
      midi.instruments, sorted_seq_instrument_keys):

    seq_instrument_notes = seq_instruments[seq_instrument_key][&#39;notes&#39;]

    self.assertEqual(len(midi_instrument.notes), len(seq_instrument_notes))
    for midi_note, sequence_note in zip(midi_instrument.notes,
                                        seq_instrument_notes):
      self.assertEqual(midi_note.pitch, sequence_note.pitch)
      self.assertEqual(midi_note.velocity, sequence_note.velocity)
      self.assertAlmostEqual(midi_note.start, sequence_note.start_time)
      self.assertAlmostEqual(midi_note.end, sequence_note.end_time)

    seq_instrument_pitch_bends = seq_instruments[seq_instrument_key][&#39;bends&#39;]
    self.assertEqual(len(midi_instrument.pitch_bends),
                     len(seq_instrument_pitch_bends))
    for midi_pitch_bend, sequence_pitch_bend in zip(
        midi_instrument.pitch_bends,
        seq_instrument_pitch_bends):
      self.assertEqual(midi_pitch_bend.pitch, sequence_pitch_bend.bend)
      self.assertAlmostEqual(midi_pitch_bend.time, sequence_pitch_bend.time)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.CheckReadWriteMidi"><code class="name flex">
<span>def <span class="ident">CheckReadWriteMidi</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Test writing to a MIDI file and comparing it to the original Sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckReadWriteMidi(self, filename):
  &#34;&#34;&#34;Test writing to a MIDI file and comparing it to the original Sequence.&#34;&#34;&#34;

  # TODO(deck): The input MIDI file is opened in pretty-midi and
  # re-written to a temp file, sanitizing the MIDI data (reordering
  # note ons, etc). Issue 85 in the pretty-midi GitHub
  # (http://github.com/craffel/pretty-midi/issues/85) requests that
  # this sanitization be available outside of the context of a file
  # write. If that is implemented, this rewrite code should be
  # modified or deleted.

  # When writing to the temp file, use the file object itself instead of
  # file.name to avoid the permission error on Windows.
  with tempfile.NamedTemporaryFile(prefix=&#39;MidiIoTest&#39;) as rewrite_file:
    original_midi = pretty_midi.PrettyMIDI(filename)
    original_midi.write(rewrite_file)  # Use file object
    # Back the file position to top to reload the rewrite_file
    rewrite_file.seek(0)
    source_midi = pretty_midi.PrettyMIDI(rewrite_file)  # Use file object
    sequence_proto = midi_io.midi_to_sequence_proto(source_midi)

  # Translate the NoteSequence to MIDI and write to a file.
  with tempfile.NamedTemporaryFile(prefix=&#39;MidiIoTest&#39;) as temp_file:
    midi_io.sequence_proto_to_midi_file(sequence_proto, temp_file.name)
    # Read it back in and compare to source.
    created_midi = pretty_midi.PrettyMIDI(temp_file)  # Use file object

  self.CheckPrettyMidiAndSequence(created_midi, sequence_proto)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.CheckSequenceToPrettyMidi"><code class="name flex">
<span>def <span class="ident">CheckSequenceToPrettyMidi</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Test the translation from Sequence proto to PrettyMIDI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckSequenceToPrettyMidi(self, filename):
  &#34;&#34;&#34;Test the translation from Sequence proto to PrettyMIDI.&#34;&#34;&#34;
  source_midi = pretty_midi.PrettyMIDI(filename)
  sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
  translated_midi = midi_io.sequence_proto_to_pretty_midi(sequence_proto)
  self.CheckPrettyMidiAndSequence(translated_midi, sequence_proto)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  super().setUp()
  self.midi_simple_filename = os.path.join(
      testing_lib.get_testdata_dir(), &#39;example.mid&#39;)
  self.midi_complex_filename = os.path.join(
      testing_lib.get_testdata_dir(), &#39;example_complex.mid&#39;)
  self.midi_is_drum_filename = os.path.join(
      testing_lib.get_testdata_dir(), &#39;example_is_drum.mid&#39;)
  self.midi_event_order_filename = os.path.join(
      testing_lib.get_testdata_dir(), &#39;example_event_order.mid&#39;)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testComplexPrettyMidiToSequence"><code class="name flex">
<span>def <span class="ident">testComplexPrettyMidiToSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testComplexPrettyMidiToSequence(self):
  self.CheckMidiToSequence(self.midi_complex_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testComplexReadWriteMidi"><code class="name flex">
<span>def <span class="ident">testComplexReadWriteMidi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testComplexReadWriteMidi(self):
  self.CheckReadWriteMidi(self.midi_complex_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testComplexSequenceToPrettyMidi"><code class="name flex">
<span>def <span class="ident">testComplexSequenceToPrettyMidi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testComplexSequenceToPrettyMidi(self):
  self.CheckSequenceToPrettyMidi(self.midi_complex_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testEmptySequenceToPrettyMidi_DropEventsAfterLastNote"><code class="name flex">
<span>def <span class="ident">testEmptySequenceToPrettyMidi_DropEventsAfterLastNote</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEmptySequenceToPrettyMidi_DropEventsAfterLastNote(self):
  source_sequence = music_pb2.NoteSequence()

  # Translate without dropping.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      source_sequence)
  self.assertLen(translated_midi.instruments, 1)
  self.assertEmpty(translated_midi.instruments[0].notes)

  # Translate dropping anything after 30 seconds.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      source_sequence, drop_events_n_seconds_after_last_note=30)
  self.assertLen(translated_midi.instruments, 1)
  self.assertEmpty(translated_midi.instruments[0].notes)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testEventOrdering"><code class="name flex">
<span>def <span class="ident">testEventOrdering</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEventOrdering(self):
  self.CheckReadWriteMidi(self.midi_event_order_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testInstrumentInfo_NoteSequenceToPrettyMidi"><code class="name flex">
<span>def <span class="ident">testInstrumentInfo_NoteSequenceToPrettyMidi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInstrumentInfo_NoteSequenceToPrettyMidi(self):
  source_sequence = music_pb2.NoteSequence()
  source_sequence.notes.add(
      pitch=60, start_time=0.0, end_time=0.5, velocity=80, instrument=0)
  source_sequence.notes.add(
      pitch=60, start_time=0.5, end_time=1.0, velocity=80, instrument=1)
  instrument_info1 = source_sequence.instrument_infos.add()
  instrument_info1.name = &#39;inst_0&#39;
  instrument_info1.instrument = 0
  instrument_info2 = source_sequence.instrument_infos.add()
  instrument_info2.name = &#39;inst_1&#39;
  instrument_info2.instrument = 1
  translated_midi = midi_io.sequence_proto_to_pretty_midi(source_sequence)
  translated_sequence = midi_io.midi_to_note_sequence(translated_midi)

  self.assertEqual(
      len(source_sequence.instrument_infos),
      len(translated_sequence.instrument_infos))
  self.assertEqual(source_sequence.instrument_infos[0].name,
                   translated_sequence.instrument_infos[0].name)
  self.assertEqual(source_sequence.instrument_infos[1].name,
                   translated_sequence.instrument_infos[1].name)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testIsDrumDetection"><code class="name flex">
<span>def <span class="ident">testIsDrumDetection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify that is_drum instruments are properly tracked.</p>
<p>self.midi_is_drum_filename is a MIDI file containing two tracks
set to channel 9 (is_drum == True). Each contains one NoteOn. This
test is designed to catch a bug where the second track would lose
is_drum, remapping the drum track to an instrument track.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testIsDrumDetection(self):
  &#34;&#34;&#34;Verify that is_drum instruments are properly tracked.

  self.midi_is_drum_filename is a MIDI file containing two tracks
  set to channel 9 (is_drum == True). Each contains one NoteOn. This
  test is designed to catch a bug where the second track would lose
  is_drum, remapping the drum track to an instrument track.
  &#34;&#34;&#34;
  sequence_proto = midi_io.midi_file_to_sequence_proto(
      self.midi_is_drum_filename)
  with tempfile.NamedTemporaryFile(prefix=&#39;MidiDrumTest&#39;) as temp_file:
    midi_io.sequence_proto_to_midi_file(sequence_proto, temp_file.name)
    midi_data1 = mido.MidiFile(filename=self.midi_is_drum_filename)
    # Use the file object when writing to the tempfile
    # to avoid permission error.
    midi_data2 = mido.MidiFile(file=temp_file)

  # Count number of channel 9 Note Ons.
  channel_counts = [0, 0]
  for index, midi_data in enumerate([midi_data1, midi_data2]):
    for event in midi_data:
      if (event.type == &#39;note_on&#39; and
          event.velocity &gt; 0 and event.channel == 9):
        channel_counts[index] += 1
  self.assertEqual(channel_counts, [2, 2])</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote"><code class="name flex">
<span>def <span class="ident">testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote(self):
  source_sequence = music_pb2.NoteSequence()
  source_sequence.tempos.add(time=0, qpm=120)
  source_sequence.tempos.add(time=10, qpm=160)
  source_sequence.tempos.add(time=40, qpm=240)

  # Translate without dropping.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      source_sequence)
  self.CheckPrettyMidiAndSequence(translated_midi, source_sequence)

  # Translate dropping anything after 30 seconds.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      source_sequence, drop_events_n_seconds_after_last_note=30)
  del source_sequence.tempos[-1]
  self.CheckPrettyMidiAndSequence(translated_midi, source_sequence)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimplePrettyMidiToSequence"><code class="name flex">
<span>def <span class="ident">testSimplePrettyMidiToSequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimplePrettyMidiToSequence(self):
  self.CheckMidiToSequence(self.midi_simple_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimpleReadWriteMidi"><code class="name flex">
<span>def <span class="ident">testSimpleReadWriteMidi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimpleReadWriteMidi(self):
  self.CheckReadWriteMidi(self.midi_simple_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi"><code class="name flex">
<span>def <span class="ident">testSimpleSequenceToPrettyMidi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimpleSequenceToPrettyMidi(self):
  self.CheckSequenceToPrettyMidi(self.midi_simple_filename)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo"><code class="name flex">
<span>def <span class="ident">testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo(self):
  source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
  stripped_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
  del stripped_sequence_proto.tempos[:]
  stripped_sequence_proto.ClearField(&#39;ticks_per_quarter&#39;)

  expected_sequence_proto = music_pb2.NoteSequence()
  expected_sequence_proto.CopyFrom(stripped_sequence_proto)
  expected_sequence_proto.tempos.add(
      qpm=constants.DEFAULT_QUARTERS_PER_MINUTE)
  expected_sequence_proto.ticks_per_quarter = constants.STANDARD_PPQ

  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      stripped_sequence_proto)

  self.CheckPrettyMidiAndSequence(translated_midi, expected_sequence_proto)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote"><code class="name flex">
<span>def <span class="ident">testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote(self):
  source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
  multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
  # Add a final tempo long after the last note.
  multi_tempo_sequence_proto.tempos.add(time=600.0, qpm=120)

  # Translate without dropping.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      multi_tempo_sequence_proto)
  self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  # Translate dropping anything after the last note.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      multi_tempo_sequence_proto, drop_events_n_seconds_after_last_note=0)
  # The added tempo should have been dropped.
  del multi_tempo_sequence_proto.tempos[-1]
  self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)

  # Add a final tempo 15 seconds after the last note.
  last_note_time = max([n.end_time for n in multi_tempo_sequence_proto.notes])
  multi_tempo_sequence_proto.tempos.add(time=last_note_time + 15, qpm=120)
  # Translate dropping anything 30 seconds after the last note, which should
  # preserve the added tempo.
  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      multi_tempo_sequence_proto, drop_events_n_seconds_after_last_note=30)
  self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero"><code class="name flex">
<span>def <span class="ident">testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero(self):
  source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
  multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
  del multi_tempo_sequence_proto.tempos[:]
  multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
  multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      multi_tempo_sequence_proto)

  # Translating to MIDI adds an implicit DEFAULT_QUARTERS_PER_MINUTE tempo
  # at time 0, so recreate the list with that in place.
  del multi_tempo_sequence_proto.tempos[:]
  multi_tempo_sequence_proto.tempos.add(
      time=0.0, qpm=constants.DEFAULT_QUARTERS_PER_MINUTE)
  multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
  multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

  self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)</code></pre>
</details>
</dd>
<dt id="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_MultipleTempos"><code class="name flex">
<span>def <span class="ident">testSimpleSequenceToPrettyMidi_MultipleTempos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSimpleSequenceToPrettyMidi_MultipleTempos(self):
  source_midi = pretty_midi.PrettyMIDI(self.midi_simple_filename)
  multi_tempo_sequence_proto = midi_io.midi_to_sequence_proto(source_midi)
  multi_tempo_sequence_proto.tempos.add(time=1.0, qpm=60)
  multi_tempo_sequence_proto.tempos.add(time=2.0, qpm=120)

  translated_midi = midi_io.sequence_proto_to_pretty_midi(
      multi_tempo_sequence_proto)

  self.CheckPrettyMidiAndSequence(translated_midi, multi_tempo_sequence_proto)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.midi_io_test.MidiIoTest" href="#note_seq.midi_io_test.MidiIoTest">MidiIoTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.midi_io_test.MidiIoTest.CheckMidiToSequence" href="#note_seq.midi_io_test.MidiIoTest.CheckMidiToSequence">CheckMidiToSequence</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.CheckPrettyMidiAndSequence" href="#note_seq.midi_io_test.MidiIoTest.CheckPrettyMidiAndSequence">CheckPrettyMidiAndSequence</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.CheckReadWriteMidi" href="#note_seq.midi_io_test.MidiIoTest.CheckReadWriteMidi">CheckReadWriteMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.CheckSequenceToPrettyMidi" href="#note_seq.midi_io_test.MidiIoTest.CheckSequenceToPrettyMidi">CheckSequenceToPrettyMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.setUp" href="#note_seq.midi_io_test.MidiIoTest.setUp">setUp</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testComplexPrettyMidiToSequence" href="#note_seq.midi_io_test.MidiIoTest.testComplexPrettyMidiToSequence">testComplexPrettyMidiToSequence</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testComplexReadWriteMidi" href="#note_seq.midi_io_test.MidiIoTest.testComplexReadWriteMidi">testComplexReadWriteMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testComplexSequenceToPrettyMidi" href="#note_seq.midi_io_test.MidiIoTest.testComplexSequenceToPrettyMidi">testComplexSequenceToPrettyMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testEmptySequenceToPrettyMidi_DropEventsAfterLastNote" href="#note_seq.midi_io_test.MidiIoTest.testEmptySequenceToPrettyMidi_DropEventsAfterLastNote">testEmptySequenceToPrettyMidi_DropEventsAfterLastNote</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testEventOrdering" href="#note_seq.midi_io_test.MidiIoTest.testEventOrdering">testEventOrdering</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testInstrumentInfo_NoteSequenceToPrettyMidi" href="#note_seq.midi_io_test.MidiIoTest.testInstrumentInfo_NoteSequenceToPrettyMidi">testInstrumentInfo_NoteSequenceToPrettyMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testIsDrumDetection" href="#note_seq.midi_io_test.MidiIoTest.testIsDrumDetection">testIsDrumDetection</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote" href="#note_seq.midi_io_test.MidiIoTest.testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote">testNonEmptySequenceWithNoNotesToPrettyMidi_DropEventsAfterLastNote</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimplePrettyMidiToSequence" href="#note_seq.midi_io_test.MidiIoTest.testSimplePrettyMidiToSequence">testSimplePrettyMidiToSequence</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimpleReadWriteMidi" href="#note_seq.midi_io_test.MidiIoTest.testSimpleReadWriteMidi">testSimpleReadWriteMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi" href="#note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi">testSimpleSequenceToPrettyMidi</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo" href="#note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo">testSimpleSequenceToPrettyMidi_DefaultTicksAndTempo</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote" href="#note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote">testSimpleSequenceToPrettyMidi_DropEventsAfterLastNote</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero" href="#note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero">testSimpleSequenceToPrettyMidi_FirstTempoNotAtZero</a></code></li>
<li><code><a title="note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_MultipleTempos" href="#note_seq.midi_io_test.MidiIoTest.testSimpleSequenceToPrettyMidi_MultipleTempos">testSimpleSequenceToPrettyMidi_MultipleTempos</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>