<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.testing_lib API documentation</title>
<meta name="description" content="Testing support code." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.testing_lib</code></h1>
</header>
<section id="section-intro">
<p>Testing support code.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Testing support code.&#34;&#34;&#34;

import os

from absl.testing import absltest

from note_seq import encoder_decoder
from note_seq.protobuf import compare
from note_seq.protobuf import music_pb2

from google.protobuf import descriptor_pool
from google.protobuf import text_format

# Shortcut to text annotation types.
BEAT = music_pb2.NoteSequence.TextAnnotation.BEAT
CHORD_SYMBOL = music_pb2.NoteSequence.TextAnnotation.CHORD_SYMBOL


def add_track_to_sequence(note_sequence,
                          instrument,
                          notes,
                          is_drum=False,
                          program=0):
  &#34;&#34;&#34;Adds instrument track to NoteSequence.&#34;&#34;&#34;
  for pitch, velocity, start_time, end_time in notes:
    note = note_sequence.notes.add()
    note.pitch = pitch
    note.velocity = velocity
    note.start_time = start_time
    note.end_time = end_time
    note.instrument = instrument
    note.is_drum = is_drum
    note.program = program
    if end_time &gt; note_sequence.total_time:
      note_sequence.total_time = end_time


def add_chords_to_sequence(note_sequence, chords):
  for figure, time in chords:
    annotation = note_sequence.text_annotations.add()
    annotation.time = time
    annotation.text = figure
    annotation.annotation_type = CHORD_SYMBOL


def add_key_signatures_to_sequence(note_sequence, keys):
  for key, time in keys:
    ks = note_sequence.key_signatures.add()
    ks.time = time
    ks.key = key


def add_beats_to_sequence(note_sequence, beats, beats_per_bar=None):
  for i, time in enumerate(beats):
    annotation = note_sequence.text_annotations.add()
    annotation.time = time
    annotation.annotation_type = BEAT
    if beats_per_bar:
      annotation.text = str((i % beats_per_bar) + 1)


def add_control_changes_to_sequence(note_sequence, instrument, control_changes):
  for time, control_number, control_value in control_changes:
    control_change = note_sequence.control_changes.add()
    control_change.time = time
    control_change.control_number = control_number
    control_change.control_value = control_value
    control_change.instrument = instrument


def add_pitch_bends_to_sequence(
    note_sequence, instrument, program, pitch_bends):
  for time, bend in pitch_bends:
    pitch_bend = note_sequence.pitch_bends.add()
    pitch_bend.time = time
    pitch_bend.bend = bend
    pitch_bend.program = program
    pitch_bend.instrument = instrument
    pitch_bend.is_drum = False  # Assume false for this test method.


def add_quantized_steps_to_sequence(sequence, quantized_steps):
  assert len(sequence.notes) == len(quantized_steps)

  for note, quantized_step in zip(sequence.notes, quantized_steps):
    note.quantized_start_step = quantized_step[0]
    note.quantized_end_step = quantized_step[1]

    if quantized_step[1] &gt; sequence.total_quantized_steps:
      sequence.total_quantized_steps = quantized_step[1]


def add_quantized_chord_steps_to_sequence(sequence, quantized_steps):
  chord_annotations = [a for a in sequence.text_annotations
                       if a.annotation_type == CHORD_SYMBOL]
  assert len(chord_annotations) == len(quantized_steps)
  for chord, quantized_step in zip(chord_annotations, quantized_steps):
    chord.quantized_step = quantized_step


def add_quantized_control_steps_to_sequence(sequence, quantized_steps):
  assert len(sequence.control_changes) == len(quantized_steps)

  for cc, quantized_step in zip(sequence.control_changes, quantized_steps):
    cc.quantized_step = quantized_step


class TrivialOneHotEncoding(encoder_decoder.OneHotEncoding):
  &#34;&#34;&#34;One-hot encoding that uses the identity encoding.&#34;&#34;&#34;

  def __init__(self, num_classes, num_steps=None):
    if num_steps is not None and len(num_steps) != num_classes:
      raise ValueError(&#39;num_steps must have length num_classes&#39;)
    self._num_classes = num_classes
    self._num_steps = num_steps

  @property
  def num_classes(self):
    return self._num_classes

  @property
  def default_event(self):
    return 0

  def encode_event(self, event):
    return event

  def decode_event(self, index):
    event = index
    return event

  def event_to_num_steps(self, event):
    if self._num_steps is not None:
      return self._num_steps[event]
    else:
      return 1


def parse_test_proto(proto_type, proto_string):
  instance = proto_type()
  text_format.Parse(proto_string, instance)
  return instance


def get_testdata_dir():
  dir_path = &#39;note_seq/testdata&#39;
  return os.path.join(absltest.get_default_test_srcdir(), dir_path)


class ProtoTestCase(absltest.TestCase):
  &#34;&#34;&#34;Adds assertProtoEquals from tf.test.TestCase.&#34;&#34;&#34;

  def setUp(self):
    self.maxDiff = None  # pylint:disable=invalid-name
    self.steps_per_quarter = 4
    self.note_sequence = parse_test_proto(
        music_pb2.NoteSequence, &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4
        }
        tempos: {
          qpm: 60
        }
        &#34;&#34;&#34;)
    super().setUp()

  def _AssertProtoEquals(self, a, b, msg=None):  # pylint:disable=invalid-name
    &#34;&#34;&#34;Asserts that a and b are the same proto.

    Uses ProtoEq() first, as it returns correct results
    for floating point attributes, and then use assertProtoEqual()
    in case of failure as it provides good error messages.

    Args:
      a: a proto.
      b: another proto.
      msg: Optional message to report on failure.
    &#34;&#34;&#34;
    if not compare.ProtoEq(a, b):
      compare.assertProtoEqual(self, a, b, normalize_numbers=True, msg=msg)

  def assertProtoEquals(self, expected_message_maybe_ascii, message, msg=None):
    &#34;&#34;&#34;Asserts that message is same as parsed expected_message_ascii.

    Creates another prototype of message, reads the ascii message into it and
    then compares them using self._AssertProtoEqual().

    Args:
      expected_message_maybe_ascii: proto message in original or ascii form.
      message: the message to validate.
      msg: Optional message to report on failure.
    &#34;&#34;&#34;
    msg = msg if msg else &#39;&#39;
    if isinstance(expected_message_maybe_ascii, type(message)):
      expected_message = expected_message_maybe_ascii
      self._AssertProtoEquals(expected_message, message)
    elif isinstance(expected_message_maybe_ascii, str):
      expected_message = type(message)()
      text_format.Parse(
          expected_message_maybe_ascii,
          expected_message,
          descriptor_pool=descriptor_pool.Default())
      self._AssertProtoEquals(expected_message, message, msg=msg)
    else:
      assert False, (&#34;Can&#39;t compare protos of type %s and %s. %s&#34; %
                     (type(expected_message_maybe_ascii), type(message), msg))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="note_seq.testing_lib.add_beats_to_sequence"><code class="name flex">
<span>def <span class="ident">add_beats_to_sequence</span></span>(<span>note_sequence, beats, beats_per_bar=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_beats_to_sequence(note_sequence, beats, beats_per_bar=None):
  for i, time in enumerate(beats):
    annotation = note_sequence.text_annotations.add()
    annotation.time = time
    annotation.annotation_type = BEAT
    if beats_per_bar:
      annotation.text = str((i % beats_per_bar) + 1)</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_chords_to_sequence"><code class="name flex">
<span>def <span class="ident">add_chords_to_sequence</span></span>(<span>note_sequence, chords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_chords_to_sequence(note_sequence, chords):
  for figure, time in chords:
    annotation = note_sequence.text_annotations.add()
    annotation.time = time
    annotation.text = figure
    annotation.annotation_type = CHORD_SYMBOL</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_control_changes_to_sequence"><code class="name flex">
<span>def <span class="ident">add_control_changes_to_sequence</span></span>(<span>note_sequence, instrument, control_changes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_control_changes_to_sequence(note_sequence, instrument, control_changes):
  for time, control_number, control_value in control_changes:
    control_change = note_sequence.control_changes.add()
    control_change.time = time
    control_change.control_number = control_number
    control_change.control_value = control_value
    control_change.instrument = instrument</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_key_signatures_to_sequence"><code class="name flex">
<span>def <span class="ident">add_key_signatures_to_sequence</span></span>(<span>note_sequence, keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_key_signatures_to_sequence(note_sequence, keys):
  for key, time in keys:
    ks = note_sequence.key_signatures.add()
    ks.time = time
    ks.key = key</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_pitch_bends_to_sequence"><code class="name flex">
<span>def <span class="ident">add_pitch_bends_to_sequence</span></span>(<span>note_sequence, instrument, program, pitch_bends)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_pitch_bends_to_sequence(
    note_sequence, instrument, program, pitch_bends):
  for time, bend in pitch_bends:
    pitch_bend = note_sequence.pitch_bends.add()
    pitch_bend.time = time
    pitch_bend.bend = bend
    pitch_bend.program = program
    pitch_bend.instrument = instrument
    pitch_bend.is_drum = False  # Assume false for this test method.</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_quantized_chord_steps_to_sequence"><code class="name flex">
<span>def <span class="ident">add_quantized_chord_steps_to_sequence</span></span>(<span>sequence, quantized_steps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_quantized_chord_steps_to_sequence(sequence, quantized_steps):
  chord_annotations = [a for a in sequence.text_annotations
                       if a.annotation_type == CHORD_SYMBOL]
  assert len(chord_annotations) == len(quantized_steps)
  for chord, quantized_step in zip(chord_annotations, quantized_steps):
    chord.quantized_step = quantized_step</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_quantized_control_steps_to_sequence"><code class="name flex">
<span>def <span class="ident">add_quantized_control_steps_to_sequence</span></span>(<span>sequence, quantized_steps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_quantized_control_steps_to_sequence(sequence, quantized_steps):
  assert len(sequence.control_changes) == len(quantized_steps)

  for cc, quantized_step in zip(sequence.control_changes, quantized_steps):
    cc.quantized_step = quantized_step</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_quantized_steps_to_sequence"><code class="name flex">
<span>def <span class="ident">add_quantized_steps_to_sequence</span></span>(<span>sequence, quantized_steps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_quantized_steps_to_sequence(sequence, quantized_steps):
  assert len(sequence.notes) == len(quantized_steps)

  for note, quantized_step in zip(sequence.notes, quantized_steps):
    note.quantized_start_step = quantized_step[0]
    note.quantized_end_step = quantized_step[1]

    if quantized_step[1] &gt; sequence.total_quantized_steps:
      sequence.total_quantized_steps = quantized_step[1]</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.add_track_to_sequence"><code class="name flex">
<span>def <span class="ident">add_track_to_sequence</span></span>(<span>note_sequence, instrument, notes, is_drum=False, program=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds instrument track to NoteSequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_track_to_sequence(note_sequence,
                          instrument,
                          notes,
                          is_drum=False,
                          program=0):
  &#34;&#34;&#34;Adds instrument track to NoteSequence.&#34;&#34;&#34;
  for pitch, velocity, start_time, end_time in notes:
    note = note_sequence.notes.add()
    note.pitch = pitch
    note.velocity = velocity
    note.start_time = start_time
    note.end_time = end_time
    note.instrument = instrument
    note.is_drum = is_drum
    note.program = program
    if end_time &gt; note_sequence.total_time:
      note_sequence.total_time = end_time</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.get_testdata_dir"><code class="name flex">
<span>def <span class="ident">get_testdata_dir</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_testdata_dir():
  dir_path = &#39;note_seq/testdata&#39;
  return os.path.join(absltest.get_default_test_srcdir(), dir_path)</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.parse_test_proto"><code class="name flex">
<span>def <span class="ident">parse_test_proto</span></span>(<span>proto_type, proto_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_test_proto(proto_type, proto_string):
  instance = proto_type()
  text_format.Parse(proto_string, instance)
  return instance</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.testing_lib.ProtoTestCase"><code class="flex name class">
<span>class <span class="ident">ProtoTestCase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds assertProtoEquals from tf.test.TestCase.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProtoTestCase(absltest.TestCase):
  &#34;&#34;&#34;Adds assertProtoEquals from tf.test.TestCase.&#34;&#34;&#34;

  def setUp(self):
    self.maxDiff = None  # pylint:disable=invalid-name
    self.steps_per_quarter = 4
    self.note_sequence = parse_test_proto(
        music_pb2.NoteSequence, &#34;&#34;&#34;
        time_signatures: {
          numerator: 4
          denominator: 4
        }
        tempos: {
          qpm: 60
        }
        &#34;&#34;&#34;)
    super().setUp()

  def _AssertProtoEquals(self, a, b, msg=None):  # pylint:disable=invalid-name
    &#34;&#34;&#34;Asserts that a and b are the same proto.

    Uses ProtoEq() first, as it returns correct results
    for floating point attributes, and then use assertProtoEqual()
    in case of failure as it provides good error messages.

    Args:
      a: a proto.
      b: another proto.
      msg: Optional message to report on failure.
    &#34;&#34;&#34;
    if not compare.ProtoEq(a, b):
      compare.assertProtoEqual(self, a, b, normalize_numbers=True, msg=msg)

  def assertProtoEquals(self, expected_message_maybe_ascii, message, msg=None):
    &#34;&#34;&#34;Asserts that message is same as parsed expected_message_ascii.

    Creates another prototype of message, reads the ascii message into it and
    then compares them using self._AssertProtoEqual().

    Args:
      expected_message_maybe_ascii: proto message in original or ascii form.
      message: the message to validate.
      msg: Optional message to report on failure.
    &#34;&#34;&#34;
    msg = msg if msg else &#39;&#39;
    if isinstance(expected_message_maybe_ascii, type(message)):
      expected_message = expected_message_maybe_ascii
      self._AssertProtoEquals(expected_message, message)
    elif isinstance(expected_message_maybe_ascii, str):
      expected_message = type(message)()
      text_format.Parse(
          expected_message_maybe_ascii,
          expected_message,
          descriptor_pool=descriptor_pool.Default())
      self._AssertProtoEquals(expected_message, message, msg=msg)
    else:
      assert False, (&#34;Can&#39;t compare protos of type %s and %s. %s&#34; %
                     (type(expected_message_maybe_ascii), type(message), msg))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="note_seq.abc_parser_test.AbcParserTest" href="abc_parser_test.html#note_seq.abc_parser_test.AbcParserTest">AbcParserTest</a></li>
<li><a title="note_seq.chords_lib_test.ChordsLibTest" href="chords_lib_test.html#note_seq.chords_lib_test.ChordsLibTest">ChordsLibTest</a></li>
<li><a title="note_seq.drums_lib_test.DrumsLibTest" href="drums_lib_test.html#note_seq.drums_lib_test.DrumsLibTest">DrumsLibTest</a></li>
<li><a title="note_seq.lead_sheets_lib_test.LeadSheetsLibTest" href="lead_sheets_lib_test.html#note_seq.lead_sheets_lib_test.LeadSheetsLibTest">LeadSheetsLibTest</a></li>
<li><a title="note_seq.melodies_lib_test.MelodiesLibTest" href="melodies_lib_test.html#note_seq.melodies_lib_test.MelodiesLibTest">MelodiesLibTest</a></li>
<li><a title="note_seq.musicxml_parser_test.MusicXMLParserTest" href="musicxml_parser_test.html#note_seq.musicxml_parser_test.MusicXMLParserTest">MusicXMLParserTest</a></li>
<li><a title="note_seq.sequences_lib_test.SequencesLibTest" href="sequences_lib_test.html#note_seq.sequences_lib_test.SequencesLibTest">SequencesLibTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.testing_lib.ProtoTestCase.assertProtoEquals"><code class="name flex">
<span>def <span class="ident">assertProtoEquals</span></span>(<span>self, expected_message_maybe_ascii, message, msg=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Asserts that message is same as parsed expected_message_ascii.</p>
<p>Creates another prototype of message, reads the ascii message into it and
then compares them using self._AssertProtoEqual().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expected_message_maybe_ascii</code></strong></dt>
<dd>proto message in original or ascii form.</dd>
<dt><strong><code>message</code></strong></dt>
<dd>the message to validate.</dd>
<dt><strong><code>msg</code></strong></dt>
<dd>Optional message to report on failure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertProtoEquals(self, expected_message_maybe_ascii, message, msg=None):
  &#34;&#34;&#34;Asserts that message is same as parsed expected_message_ascii.

  Creates another prototype of message, reads the ascii message into it and
  then compares them using self._AssertProtoEqual().

  Args:
    expected_message_maybe_ascii: proto message in original or ascii form.
    message: the message to validate.
    msg: Optional message to report on failure.
  &#34;&#34;&#34;
  msg = msg if msg else &#39;&#39;
  if isinstance(expected_message_maybe_ascii, type(message)):
    expected_message = expected_message_maybe_ascii
    self._AssertProtoEquals(expected_message, message)
  elif isinstance(expected_message_maybe_ascii, str):
    expected_message = type(message)()
    text_format.Parse(
        expected_message_maybe_ascii,
        expected_message,
        descriptor_pool=descriptor_pool.Default())
    self._AssertProtoEquals(expected_message, message, msg=msg)
  else:
    assert False, (&#34;Can&#39;t compare protos of type %s and %s. %s&#34; %
                   (type(expected_message_maybe_ascii), type(message), msg))</code></pre>
</details>
</dd>
<dt id="note_seq.testing_lib.ProtoTestCase.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  self.maxDiff = None  # pylint:disable=invalid-name
  self.steps_per_quarter = 4
  self.note_sequence = parse_test_proto(
      music_pb2.NoteSequence, &#34;&#34;&#34;
      time_signatures: {
        numerator: 4
        denominator: 4
      }
      tempos: {
        qpm: 60
      }
      &#34;&#34;&#34;)
  super().setUp()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="note_seq.testing_lib.TrivialOneHotEncoding"><code class="flex name class">
<span>class <span class="ident">TrivialOneHotEncoding</span></span>
<span>(</span><span>num_classes, num_steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>One-hot encoding that uses the identity encoding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrivialOneHotEncoding(encoder_decoder.OneHotEncoding):
  &#34;&#34;&#34;One-hot encoding that uses the identity encoding.&#34;&#34;&#34;

  def __init__(self, num_classes, num_steps=None):
    if num_steps is not None and len(num_steps) != num_classes:
      raise ValueError(&#39;num_steps must have length num_classes&#39;)
    self._num_classes = num_classes
    self._num_steps = num_steps

  @property
  def num_classes(self):
    return self._num_classes

  @property
  def default_event(self):
    return 0

  def encode_event(self, event):
    return event

  def decode_event(self, index):
    event = index
    return event

  def event_to_num_steps(self, event):
    if self._num_steps is not None:
      return self._num_steps[event]
    else:
      return 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="note_seq.encoder_decoder.OneHotEncoding" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding">OneHotEncoding</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="note_seq.encoder_decoder.OneHotEncoding" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding">OneHotEncoding</a></b></code>:
<ul class="hlist">
<li><code><a title="note_seq.encoder_decoder.OneHotEncoding.decode_event" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding.decode_event">decode_event</a></code></li>
<li><code><a title="note_seq.encoder_decoder.OneHotEncoding.default_event" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding.default_event">default_event</a></code></li>
<li><code><a title="note_seq.encoder_decoder.OneHotEncoding.encode_event" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding.encode_event">encode_event</a></code></li>
<li><code><a title="note_seq.encoder_decoder.OneHotEncoding.event_to_num_steps" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding.event_to_num_steps">event_to_num_steps</a></code></li>
<li><code><a title="note_seq.encoder_decoder.OneHotEncoding.num_classes" href="encoder_decoder.html#note_seq.encoder_decoder.OneHotEncoding.num_classes">num_classes</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="note_seq.testing_lib.add_beats_to_sequence" href="#note_seq.testing_lib.add_beats_to_sequence">add_beats_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_chords_to_sequence" href="#note_seq.testing_lib.add_chords_to_sequence">add_chords_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_control_changes_to_sequence" href="#note_seq.testing_lib.add_control_changes_to_sequence">add_control_changes_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_key_signatures_to_sequence" href="#note_seq.testing_lib.add_key_signatures_to_sequence">add_key_signatures_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_pitch_bends_to_sequence" href="#note_seq.testing_lib.add_pitch_bends_to_sequence">add_pitch_bends_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_quantized_chord_steps_to_sequence" href="#note_seq.testing_lib.add_quantized_chord_steps_to_sequence">add_quantized_chord_steps_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_quantized_control_steps_to_sequence" href="#note_seq.testing_lib.add_quantized_control_steps_to_sequence">add_quantized_control_steps_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_quantized_steps_to_sequence" href="#note_seq.testing_lib.add_quantized_steps_to_sequence">add_quantized_steps_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.add_track_to_sequence" href="#note_seq.testing_lib.add_track_to_sequence">add_track_to_sequence</a></code></li>
<li><code><a title="note_seq.testing_lib.get_testdata_dir" href="#note_seq.testing_lib.get_testdata_dir">get_testdata_dir</a></code></li>
<li><code><a title="note_seq.testing_lib.parse_test_proto" href="#note_seq.testing_lib.parse_test_proto">parse_test_proto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.testing_lib.ProtoTestCase" href="#note_seq.testing_lib.ProtoTestCase">ProtoTestCase</a></code></h4>
<ul class="">
<li><code><a title="note_seq.testing_lib.ProtoTestCase.assertProtoEquals" href="#note_seq.testing_lib.ProtoTestCase.assertProtoEquals">assertProtoEquals</a></code></li>
<li><code><a title="note_seq.testing_lib.ProtoTestCase.setUp" href="#note_seq.testing_lib.ProtoTestCase.setUp">setUp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.testing_lib.TrivialOneHotEncoding" href="#note_seq.testing_lib.TrivialOneHotEncoding">TrivialOneHotEncoding</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>