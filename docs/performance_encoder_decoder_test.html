<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>note_seq.performance_encoder_decoder_test API documentation</title>
<meta name="description" content="Tests for performance_encoder_decoder." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>note_seq.performance_encoder_decoder_test</code></h1>
</header>
<section id="section-intro">
<p>Tests for performance_encoder_decoder.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Tests for performance_encoder_decoder.&#34;&#34;&#34;

import math

from absl.testing import absltest
from note_seq import performance_encoder_decoder
from note_seq import performance_lib
from note_seq.performance_encoder_decoder import ModuloPerformanceEventSequenceEncoderDecoder
from note_seq.performance_encoder_decoder import NotePerformanceEventSequenceEncoderDecoder
from note_seq.performance_encoder_decoder import PerformanceModuloEncoding
from note_seq.performance_lib import PerformanceEvent

cos = math.cos
sin = math.sin
pi = math.pi


class PerformanceOneHotEncodingTest(absltest.TestCase):

  def setUp(self):
    self.enc = performance_encoder_decoder.PerformanceOneHotEncoding(
        num_velocity_bins=16)

  def testEncodeDecode(self):
    expected_pairs = [
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_ON, event_value=60), 60),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_ON, event_value=0), 0),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_ON, event_value=127), 127),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=72), 200),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=0), 128),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=127), 255),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=10), 265),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1), 256),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100), 355),
        (PerformanceEvent(
            event_type=PerformanceEvent.VELOCITY, event_value=5), 360),
        (PerformanceEvent(
            event_type=PerformanceEvent.VELOCITY, event_value=1), 356),
        (PerformanceEvent(
            event_type=PerformanceEvent.VELOCITY, event_value=16), 371)
    ]

    for expected_event, expected_index in expected_pairs:
      index = self.enc.encode_event(expected_event)
      self.assertEqual(expected_index, index)
      event = self.enc.decode_event(expected_index)
      self.assertEqual(expected_event, event)

  def testEventToNumSteps(self):
    self.assertEqual(0, self.enc.event_to_num_steps(
        PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60)))
    self.assertEqual(0, self.enc.event_to_num_steps(
        PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=67)))
    self.assertEqual(0, self.enc.event_to_num_steps(
        PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=10)))

    self.assertEqual(1, self.enc.event_to_num_steps(
        PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1)))
    self.assertEqual(45, self.enc.event_to_num_steps(
        PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=45)))
    self.assertEqual(100, self.enc.event_to_num_steps(
        PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100)))


class PerformanceModuloEncodingTest(absltest.TestCase):
  &#34;&#34;&#34;Test class for PerformanceModuloEncoding.&#34;&#34;&#34;

  def setUp(self):
    self._num_velocity_bins = 16
    self._max_shift_steps = performance_lib.DEFAULT_MAX_SHIFT_STEPS
    self.enc = PerformanceModuloEncoding(
        num_velocity_bins=self._num_velocity_bins,
        max_shift_steps=self._max_shift_steps)

    self._expected_input_size = (
        2 * performance_encoder_decoder.MODULO_PITCH_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_VELOCITY_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_TIME_SHIFT_ENCODER_WIDTH)

    self._expected_num_classes = (self._num_velocity_bins +
                                  self._max_shift_steps +
                                  (performance_lib.MAX_MIDI_PITCH -
                                   performance_lib.MIN_MIDI_PITCH + 1) * 2)

  def testInputSize(self):
    self.assertEqual(self._expected_input_size, self.enc.input_size)

  def testEmbedPitchClass(self):
    # The following are true only for semitone_steps = 1.
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (1, (cos(pi / 6.0), sin(pi / 6.0))),
        (2, (cos(pi / 3.0), sin(pi / 3.0))),
        (3, (cos(pi / 2.0), sin(pi / 2.0))),
        (4, (cos(2.0 * pi / 3.0), sin(2.0 * pi / 3.0))),
        (5, (cos(5.0 * pi / 6.0), sin(5.0 * pi / 6.0))),
        (6, (cos(pi), sin(pi))),
        (7, (cos(7.0 * pi / 6.0), sin(7.0 * pi / 6.0))),
        (8, (cos(4.0 * pi / 3.0), sin(4.0 * pi / 3.0))),
        (9, (cos(3.0 * pi / 2.0), sin(3.0 * pi / 2.0))),
        (10, (cos(5.0 * pi / 3.0), sin(5.0 * pi / 3.0))),
        (11, (cos(11.0 * pi / 6.0), sin(11.0 * pi / 6.0)))]

    for note, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_pitch_class(note)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEmbedNote(self):
    # The following are true only for semitone_steps = 1.
    base = 72.0
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (13, (cos(pi * 13.0 / base), sin(pi * 13.0 / base))),
        (26, (cos(pi * 26.0 / base), sin(pi * 26.0 / base))),
        (39, (cos(pi * 39.0 / base), sin(pi * 39.0 / base))),
        (52, (cos(pi * 52.0 / base), sin(pi * 52.0 / base))),
        (65, (cos(pi * 65.0 / base), sin(pi * 65.0 / base))),
        (78, (cos(pi * 78.0 / base), sin(pi * 78.0 / base))),
        (91, (cos(pi * 91.0 / base), sin(pi * 91.0 / base))),
        (104, (cos(pi * 104.0 / base), sin(pi * 104.0 / base))),
        (117, (cos(pi * 117.0 / base), sin(pi * 117.0 / base))),
        (130, (cos(pi * 130.0 / base), sin(pi * 130.0 / base))),
        (143, (cos(pi * 143.0 / base), sin(pi * 143.0 / base)))]

    for note, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_note(note)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEmbedTimeShift(self):
    # The following are true only for semitone_steps = 1.
    base = self._max_shift_steps  # 100
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (2, (cos(2.0 * pi * 2.0 / base), sin(2.0 * pi * 2.0 / base))),
        (5, (cos(2.0 * pi * 5.0 / base), sin(2.0 * pi * 5.0 / base))),
        (13, (cos(2.0 * pi * 13.0 / base), sin(2.0 * pi * 13.0 / base))),
        (20, (cos(2.0 * pi * 20.0 / base), sin(2.0 * pi * 20.0 / base))),
        (45, (cos(2.0 * pi * 45.0 / base), sin(2.0 * pi * 45.0 / base))),
        (70, (cos(2.0 * pi * 70.0 / base), sin(2.0 * pi * 70.0 / base))),
        (99, (cos(2.0 * pi * 99.0 / base), sin(2.0 * pi * 99.0 / base)))]

    for time_shift, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_time_shift(time_shift)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEmbedVelocity(self):
    # The following are true only for semitone_steps = 1.
    base = self._num_velocity_bins  # 16
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (2, (cos(2.0 * pi * 2.0 / base), sin(2.0 * pi * 2.0 / base))),
        (5, (cos(2.0 * pi * 5.0 / base), sin(2.0 * pi * 5.0 / base))),
        (7, (cos(2.0 * pi * 7.0 / base), sin(2.0 * pi * 7.0 / base))),
        (10, (cos(2.0 * pi * 10.0 / base), sin(2.0 * pi * 10.0 / base))),
        (13, (cos(2.0 * pi * 13.0 / base), sin(2.0 * pi * 13.0 / base))),
        (15, (cos(2.0 * pi * 15.0 / base), sin(2.0 * pi * 15.0 / base)))]

    for velocity, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_velocity(velocity)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEncodeModuloEvent(self):
    expected_pairs = [
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60),
         (0, PerformanceEvent.NOTE_ON, 60)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=0),
         (0, PerformanceEvent.NOTE_ON, 0)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=127),
         (0, PerformanceEvent.NOTE_ON, 127)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=72),
         (5, PerformanceEvent.NOTE_OFF, 72)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=0),
         (5, PerformanceEvent.NOTE_OFF, 0)),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=127),
         (5, PerformanceEvent.NOTE_OFF, 127)),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=10),
         (10, PerformanceEvent.TIME_SHIFT, 9)),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1),
         (10, PerformanceEvent.TIME_SHIFT, 0)),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100),
         (10, PerformanceEvent.TIME_SHIFT, 99)),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=5),
         (13, PerformanceEvent.VELOCITY, 4)),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=1),
         (13, PerformanceEvent.VELOCITY, 0)),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=16),
         (13, PerformanceEvent.VELOCITY, 15)),
    ]

    # expected_encoded_modulo_event is of the following form:
    # (offset, encoder_width, event_type, value, bins)
    for event, expected_encoded_modulo_event in expected_pairs:
      actual_encoded_modulo_event = self.enc.encode_modulo_event(event)
      self.assertEqual(actual_encoded_modulo_event,
                       expected_encoded_modulo_event)


class ModuloPerformanceEventSequenceEncoderTest(absltest.TestCase):
  &#34;&#34;&#34;Test class for ModuloPerformanceEventSequenceEncoder.

  ModuloPerformanceEventSequenceEncoderDecoder is tightly coupled with the
  PerformanceModuloEncoding, and PerformanceOneHotEncoding classes. As a result,
  in the test set up, the test object is initialized with one of each objects
  and tested accordingly. Since this class only modifies the input encoding
  of performance events, and otherwise its treatment of labels is the same as
  OneHotEventSequenceEncoderDecoder, the events_to_labels(), and
  class_index_to_event() methods of the class are not tested.
  &#34;&#34;&#34;

  def setUp(self):
    self._num_velocity_bins = 32
    self._max_shift_steps = 100
    self.enc = ModuloPerformanceEventSequenceEncoderDecoder(
        num_velocity_bins=self._num_velocity_bins,
        max_shift_steps=self._max_shift_steps)

    self._expected_input_size = (
        2 * performance_encoder_decoder.MODULO_PITCH_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_VELOCITY_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_TIME_SHIFT_ENCODER_WIDTH)

    self._expected_num_classes = (self._num_velocity_bins +
                                  self._max_shift_steps +
                                  2 * (performance_lib.MAX_MIDI_PITCH -
                                       performance_lib.MIN_MIDI_PITCH + 1))

  def testInputSize(self):
    self.assertEqual(self._expected_input_size, self.enc.input_size)

  def testNumClasses(self):
    self.assertEqual(self._expected_num_classes, self.enc.num_classes)

  def testDefaultEventLabel(self):
    label = self._expected_num_classes - self._num_velocity_bins - 1
    self.assertEqual(label, self.enc.default_event_label)

  def testEventsToInput(self):
    num_shift_bins = self._max_shift_steps
    num_velocity_bins = self._num_velocity_bins
    slow_base = 2.0 * pi / 144.0
    fast_base = 2.0 * pi / 12.0
    shift_base = 2.0 * pi / num_shift_bins
    velocity_base = 2.0 * pi / num_velocity_bins

    expected_pairs = [
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60),
         [1.0, cos(60.0 * slow_base), sin(60.0 * slow_base),
          cos(60.0 * fast_base), sin(60.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=0),
         [1.0, cos(0.0 * slow_base), sin(0.0 * slow_base),
          cos(0.0 * fast_base), sin(0.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=127),
         [1.0, cos(127.0 * slow_base), sin(127.0 * slow_base),
          cos(127.0 * fast_base), sin(127.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=72),
         [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          cos(72.0 * slow_base), sin(72.0 * slow_base),
          cos(72.0 * fast_base), sin(72.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=0),
         [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          cos(0.0 * slow_base), sin(0.0 * slow_base),
          cos(0.0 * fast_base), sin(0.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=127),
         [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          cos(127.0 * slow_base), sin(127.0 * slow_base),
          cos(127.0 * fast_base), sin(127.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=10),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, cos(9.0 * shift_base), sin(9.0 * shift_base),
          0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, cos(0.0 * shift_base), sin(0.0 * shift_base),
          0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, cos(99.0 * shift_base), sin(99.0 * shift_base),
          0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=5),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, cos(4.0 * velocity_base), sin(4.0 * velocity_base)]),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=1),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, cos(0.0 * velocity_base), sin(0.0 * velocity_base)]),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=16),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, cos(15.0 * velocity_base), sin(15.0 * velocity_base)]),
    ]

    events = []
    position = 0
    for event, expected_encoded_modulo_event in expected_pairs:
      events += [event]
      actual_encoded_modulo_event = self.enc.events_to_input(events, position)
      position += 1
      for i in range(self._expected_input_size):
        self.assertAlmostEqual(expected_encoded_modulo_event[i],
                               actual_encoded_modulo_event[i])


class NotePerformanceEventSequenceEncoderDecoderTest(absltest.TestCase):

  def setUp(self):
    self.enc = NotePerformanceEventSequenceEncoderDecoder(
        num_velocity_bins=16, max_shift_steps=99, max_duration_steps=500)

    self.assertEqual(10, self.enc.shift_steps_segments)
    self.assertEqual(20, self.enc.duration_steps_segments)

  def testEncodeDecode(self):
    pe = PerformanceEvent
    performance = [
        (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 60),
         pe(pe.VELOCITY, 13), pe(pe.DURATION, 401)),
        (pe(pe.TIME_SHIFT, 55), pe(pe.NOTE_ON, 64),
         pe(pe.VELOCITY, 13), pe(pe.DURATION, 310)),
        (pe(pe.TIME_SHIFT, 99), pe(pe.NOTE_ON, 67),
         pe(pe.VELOCITY, 16), pe(pe.DURATION, 100)),
        (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 67),
         pe(pe.VELOCITY, 16), pe(pe.DURATION, 1)),
        (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 67),
         pe(pe.VELOCITY, 16), pe(pe.DURATION, 500)),
    ]

    labels = [self.enc.events_to_label(performance, i)
              for i in range(len(performance))]

    expected_labels = [
        (0, 0, 60, 12, 16, 0),
        (5, 5, 64, 12, 12, 9),
        (9, 9, 67, 15, 3, 24),
        (0, 0, 67, 15, 0, 0),
        (0, 0, 67, 15, 19, 24),
    ]

    self.assertEqual(expected_labels, labels)

    inputs = [self.enc.events_to_input(performance, i)
              for i in range(len(performance))]

    for input_ in inputs:
      self.assertEqual(6, input_.nonzero()[0].shape[0])

    decoded_performance = [self.enc.class_index_to_event(label, None)
                           for label in labels]

    self.assertEqual(performance, decoded_performance)


if __name__ == &#39;__main__&#39;:
  absltest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest"><code class="flex name class">
<span>class <span class="ident">ModuloPerformanceEventSequenceEncoderTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Test class for ModuloPerformanceEventSequenceEncoder.</p>
<p>ModuloPerformanceEventSequenceEncoderDecoder is tightly coupled with the
PerformanceModuloEncoding, and PerformanceOneHotEncoding classes. As a result,
in the test set up, the test object is initialized with one of each objects
and tested accordingly. Since this class only modifies the input encoding
of performance events, and otherwise its treatment of labels is the same as
OneHotEventSequenceEncoderDecoder, the events_to_labels(), and
class_index_to_event() methods of the class are not tested.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModuloPerformanceEventSequenceEncoderTest(absltest.TestCase):
  &#34;&#34;&#34;Test class for ModuloPerformanceEventSequenceEncoder.

  ModuloPerformanceEventSequenceEncoderDecoder is tightly coupled with the
  PerformanceModuloEncoding, and PerformanceOneHotEncoding classes. As a result,
  in the test set up, the test object is initialized with one of each objects
  and tested accordingly. Since this class only modifies the input encoding
  of performance events, and otherwise its treatment of labels is the same as
  OneHotEventSequenceEncoderDecoder, the events_to_labels(), and
  class_index_to_event() methods of the class are not tested.
  &#34;&#34;&#34;

  def setUp(self):
    self._num_velocity_bins = 32
    self._max_shift_steps = 100
    self.enc = ModuloPerformanceEventSequenceEncoderDecoder(
        num_velocity_bins=self._num_velocity_bins,
        max_shift_steps=self._max_shift_steps)

    self._expected_input_size = (
        2 * performance_encoder_decoder.MODULO_PITCH_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_VELOCITY_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_TIME_SHIFT_ENCODER_WIDTH)

    self._expected_num_classes = (self._num_velocity_bins +
                                  self._max_shift_steps +
                                  2 * (performance_lib.MAX_MIDI_PITCH -
                                       performance_lib.MIN_MIDI_PITCH + 1))

  def testInputSize(self):
    self.assertEqual(self._expected_input_size, self.enc.input_size)

  def testNumClasses(self):
    self.assertEqual(self._expected_num_classes, self.enc.num_classes)

  def testDefaultEventLabel(self):
    label = self._expected_num_classes - self._num_velocity_bins - 1
    self.assertEqual(label, self.enc.default_event_label)

  def testEventsToInput(self):
    num_shift_bins = self._max_shift_steps
    num_velocity_bins = self._num_velocity_bins
    slow_base = 2.0 * pi / 144.0
    fast_base = 2.0 * pi / 12.0
    shift_base = 2.0 * pi / num_shift_bins
    velocity_base = 2.0 * pi / num_velocity_bins

    expected_pairs = [
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60),
         [1.0, cos(60.0 * slow_base), sin(60.0 * slow_base),
          cos(60.0 * fast_base), sin(60.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=0),
         [1.0, cos(0.0 * slow_base), sin(0.0 * slow_base),
          cos(0.0 * fast_base), sin(0.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=127),
         [1.0, cos(127.0 * slow_base), sin(127.0 * slow_base),
          cos(127.0 * fast_base), sin(127.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=72),
         [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          cos(72.0 * slow_base), sin(72.0 * slow_base),
          cos(72.0 * fast_base), sin(72.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=0),
         [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          cos(0.0 * slow_base), sin(0.0 * slow_base),
          cos(0.0 * fast_base), sin(0.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=127),
         [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          cos(127.0 * slow_base), sin(127.0 * slow_base),
          cos(127.0 * fast_base), sin(127.0 * fast_base),
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=10),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, cos(9.0 * shift_base), sin(9.0 * shift_base),
          0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, cos(0.0 * shift_base), sin(0.0 * shift_base),
          0.0, 0.0, 0.0]),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, cos(99.0 * shift_base), sin(99.0 * shift_base),
          0.0, 0.0, 0.0]),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=5),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, cos(4.0 * velocity_base), sin(4.0 * velocity_base)]),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=1),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, cos(0.0 * velocity_base), sin(0.0 * velocity_base)]),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=16),
         [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, cos(15.0 * velocity_base), sin(15.0 * velocity_base)]),
    ]

    events = []
    position = 0
    for event, expected_encoded_modulo_event in expected_pairs:
      events += [event]
      actual_encoded_modulo_event = self.enc.events_to_input(events, position)
      position += 1
      for i in range(self._expected_input_size):
        self.assertAlmostEqual(expected_encoded_modulo_event[i],
                               actual_encoded_modulo_event[i])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  self._num_velocity_bins = 32
  self._max_shift_steps = 100
  self.enc = ModuloPerformanceEventSequenceEncoderDecoder(
      num_velocity_bins=self._num_velocity_bins,
      max_shift_steps=self._max_shift_steps)

  self._expected_input_size = (
      2 * performance_encoder_decoder.MODULO_PITCH_ENCODER_WIDTH +
      performance_encoder_decoder.MODULO_VELOCITY_ENCODER_WIDTH +
      performance_encoder_decoder.MODULO_TIME_SHIFT_ENCODER_WIDTH)

  self._expected_num_classes = (self._num_velocity_bins +
                                self._max_shift_steps +
                                2 * (performance_lib.MAX_MIDI_PITCH -
                                     performance_lib.MIN_MIDI_PITCH + 1))</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testDefaultEventLabel"><code class="name flex">
<span>def <span class="ident">testDefaultEventLabel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testDefaultEventLabel(self):
  label = self._expected_num_classes - self._num_velocity_bins - 1
  self.assertEqual(label, self.enc.default_event_label)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testEventsToInput"><code class="name flex">
<span>def <span class="ident">testEventsToInput</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEventsToInput(self):
  num_shift_bins = self._max_shift_steps
  num_velocity_bins = self._num_velocity_bins
  slow_base = 2.0 * pi / 144.0
  fast_base = 2.0 * pi / 12.0
  shift_base = 2.0 * pi / num_shift_bins
  velocity_base = 2.0 * pi / num_velocity_bins

  expected_pairs = [
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60),
       [1.0, cos(60.0 * slow_base), sin(60.0 * slow_base),
        cos(60.0 * fast_base), sin(60.0 * fast_base),
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=0),
       [1.0, cos(0.0 * slow_base), sin(0.0 * slow_base),
        cos(0.0 * fast_base), sin(0.0 * fast_base),
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=127),
       [1.0, cos(127.0 * slow_base), sin(127.0 * slow_base),
        cos(127.0 * fast_base), sin(127.0 * fast_base),
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=72),
       [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
        cos(72.0 * slow_base), sin(72.0 * slow_base),
        cos(72.0 * fast_base), sin(72.0 * fast_base),
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=0),
       [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
        cos(0.0 * slow_base), sin(0.0 * slow_base),
        cos(0.0 * fast_base), sin(0.0 * fast_base),
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_OFF, event_value=127),
       [0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
        cos(127.0 * slow_base), sin(127.0 * slow_base),
        cos(127.0 * fast_base), sin(127.0 * fast_base),
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=10),
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, cos(9.0 * shift_base), sin(9.0 * shift_base),
        0.0, 0.0, 0.0]),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=1),
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, cos(0.0 * shift_base), sin(0.0 * shift_base),
        0.0, 0.0, 0.0]),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=100),
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, cos(99.0 * shift_base), sin(99.0 * shift_base),
        0.0, 0.0, 0.0]),
      (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=5),
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0,
        1.0, cos(4.0 * velocity_base), sin(4.0 * velocity_base)]),
      (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=1),
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0,
        1.0, cos(0.0 * velocity_base), sin(0.0 * velocity_base)]),
      (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=16),
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0,
        1.0, cos(15.0 * velocity_base), sin(15.0 * velocity_base)]),
  ]

  events = []
  position = 0
  for event, expected_encoded_modulo_event in expected_pairs:
    events += [event]
    actual_encoded_modulo_event = self.enc.events_to_input(events, position)
    position += 1
    for i in range(self._expected_input_size):
      self.assertAlmostEqual(expected_encoded_modulo_event[i],
                             actual_encoded_modulo_event[i])</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testInputSize"><code class="name flex">
<span>def <span class="ident">testInputSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInputSize(self):
  self.assertEqual(self._expected_input_size, self.enc.input_size)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testNumClasses"><code class="name flex">
<span>def <span class="ident">testNumClasses</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNumClasses(self):
  self.assertEqual(self._expected_num_classes, self.enc.num_classes)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest"><code class="flex name class">
<span>class <span class="ident">NotePerformanceEventSequenceEncoderDecoderTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of unittest.TestCase providing more power.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotePerformanceEventSequenceEncoderDecoderTest(absltest.TestCase):

  def setUp(self):
    self.enc = NotePerformanceEventSequenceEncoderDecoder(
        num_velocity_bins=16, max_shift_steps=99, max_duration_steps=500)

    self.assertEqual(10, self.enc.shift_steps_segments)
    self.assertEqual(20, self.enc.duration_steps_segments)

  def testEncodeDecode(self):
    pe = PerformanceEvent
    performance = [
        (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 60),
         pe(pe.VELOCITY, 13), pe(pe.DURATION, 401)),
        (pe(pe.TIME_SHIFT, 55), pe(pe.NOTE_ON, 64),
         pe(pe.VELOCITY, 13), pe(pe.DURATION, 310)),
        (pe(pe.TIME_SHIFT, 99), pe(pe.NOTE_ON, 67),
         pe(pe.VELOCITY, 16), pe(pe.DURATION, 100)),
        (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 67),
         pe(pe.VELOCITY, 16), pe(pe.DURATION, 1)),
        (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 67),
         pe(pe.VELOCITY, 16), pe(pe.DURATION, 500)),
    ]

    labels = [self.enc.events_to_label(performance, i)
              for i in range(len(performance))]

    expected_labels = [
        (0, 0, 60, 12, 16, 0),
        (5, 5, 64, 12, 12, 9),
        (9, 9, 67, 15, 3, 24),
        (0, 0, 67, 15, 0, 0),
        (0, 0, 67, 15, 19, 24),
    ]

    self.assertEqual(expected_labels, labels)

    inputs = [self.enc.events_to_input(performance, i)
              for i in range(len(performance))]

    for input_ in inputs:
      self.assertEqual(6, input_.nonzero()[0].shape[0])

    decoded_performance = [self.enc.class_index_to_event(label, None)
                           for label in labels]

    self.assertEqual(performance, decoded_performance)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  self.enc = NotePerformanceEventSequenceEncoderDecoder(
      num_velocity_bins=16, max_shift_steps=99, max_duration_steps=500)

  self.assertEqual(10, self.enc.shift_steps_segments)
  self.assertEqual(20, self.enc.duration_steps_segments)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest.testEncodeDecode"><code class="name flex">
<span>def <span class="ident">testEncodeDecode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEncodeDecode(self):
  pe = PerformanceEvent
  performance = [
      (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 60),
       pe(pe.VELOCITY, 13), pe(pe.DURATION, 401)),
      (pe(pe.TIME_SHIFT, 55), pe(pe.NOTE_ON, 64),
       pe(pe.VELOCITY, 13), pe(pe.DURATION, 310)),
      (pe(pe.TIME_SHIFT, 99), pe(pe.NOTE_ON, 67),
       pe(pe.VELOCITY, 16), pe(pe.DURATION, 100)),
      (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 67),
       pe(pe.VELOCITY, 16), pe(pe.DURATION, 1)),
      (pe(pe.TIME_SHIFT, 0), pe(pe.NOTE_ON, 67),
       pe(pe.VELOCITY, 16), pe(pe.DURATION, 500)),
  ]

  labels = [self.enc.events_to_label(performance, i)
            for i in range(len(performance))]

  expected_labels = [
      (0, 0, 60, 12, 16, 0),
      (5, 5, 64, 12, 12, 9),
      (9, 9, 67, 15, 3, 24),
      (0, 0, 67, 15, 0, 0),
      (0, 0, 67, 15, 19, 24),
  ]

  self.assertEqual(expected_labels, labels)

  inputs = [self.enc.events_to_input(performance, i)
            for i in range(len(performance))]

  for input_ in inputs:
    self.assertEqual(6, input_.nonzero()[0].shape[0])

  decoded_performance = [self.enc.class_index_to_event(label, None)
                         for label in labels]

  self.assertEqual(performance, decoded_performance)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest"><code class="flex name class">
<span>class <span class="ident">PerformanceModuloEncodingTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Test class for PerformanceModuloEncoding.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerformanceModuloEncodingTest(absltest.TestCase):
  &#34;&#34;&#34;Test class for PerformanceModuloEncoding.&#34;&#34;&#34;

  def setUp(self):
    self._num_velocity_bins = 16
    self._max_shift_steps = performance_lib.DEFAULT_MAX_SHIFT_STEPS
    self.enc = PerformanceModuloEncoding(
        num_velocity_bins=self._num_velocity_bins,
        max_shift_steps=self._max_shift_steps)

    self._expected_input_size = (
        2 * performance_encoder_decoder.MODULO_PITCH_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_VELOCITY_ENCODER_WIDTH +
        performance_encoder_decoder.MODULO_TIME_SHIFT_ENCODER_WIDTH)

    self._expected_num_classes = (self._num_velocity_bins +
                                  self._max_shift_steps +
                                  (performance_lib.MAX_MIDI_PITCH -
                                   performance_lib.MIN_MIDI_PITCH + 1) * 2)

  def testInputSize(self):
    self.assertEqual(self._expected_input_size, self.enc.input_size)

  def testEmbedPitchClass(self):
    # The following are true only for semitone_steps = 1.
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (1, (cos(pi / 6.0), sin(pi / 6.0))),
        (2, (cos(pi / 3.0), sin(pi / 3.0))),
        (3, (cos(pi / 2.0), sin(pi / 2.0))),
        (4, (cos(2.0 * pi / 3.0), sin(2.0 * pi / 3.0))),
        (5, (cos(5.0 * pi / 6.0), sin(5.0 * pi / 6.0))),
        (6, (cos(pi), sin(pi))),
        (7, (cos(7.0 * pi / 6.0), sin(7.0 * pi / 6.0))),
        (8, (cos(4.0 * pi / 3.0), sin(4.0 * pi / 3.0))),
        (9, (cos(3.0 * pi / 2.0), sin(3.0 * pi / 2.0))),
        (10, (cos(5.0 * pi / 3.0), sin(5.0 * pi / 3.0))),
        (11, (cos(11.0 * pi / 6.0), sin(11.0 * pi / 6.0)))]

    for note, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_pitch_class(note)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEmbedNote(self):
    # The following are true only for semitone_steps = 1.
    base = 72.0
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (13, (cos(pi * 13.0 / base), sin(pi * 13.0 / base))),
        (26, (cos(pi * 26.0 / base), sin(pi * 26.0 / base))),
        (39, (cos(pi * 39.0 / base), sin(pi * 39.0 / base))),
        (52, (cos(pi * 52.0 / base), sin(pi * 52.0 / base))),
        (65, (cos(pi * 65.0 / base), sin(pi * 65.0 / base))),
        (78, (cos(pi * 78.0 / base), sin(pi * 78.0 / base))),
        (91, (cos(pi * 91.0 / base), sin(pi * 91.0 / base))),
        (104, (cos(pi * 104.0 / base), sin(pi * 104.0 / base))),
        (117, (cos(pi * 117.0 / base), sin(pi * 117.0 / base))),
        (130, (cos(pi * 130.0 / base), sin(pi * 130.0 / base))),
        (143, (cos(pi * 143.0 / base), sin(pi * 143.0 / base)))]

    for note, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_note(note)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEmbedTimeShift(self):
    # The following are true only for semitone_steps = 1.
    base = self._max_shift_steps  # 100
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (2, (cos(2.0 * pi * 2.0 / base), sin(2.0 * pi * 2.0 / base))),
        (5, (cos(2.0 * pi * 5.0 / base), sin(2.0 * pi * 5.0 / base))),
        (13, (cos(2.0 * pi * 13.0 / base), sin(2.0 * pi * 13.0 / base))),
        (20, (cos(2.0 * pi * 20.0 / base), sin(2.0 * pi * 20.0 / base))),
        (45, (cos(2.0 * pi * 45.0 / base), sin(2.0 * pi * 45.0 / base))),
        (70, (cos(2.0 * pi * 70.0 / base), sin(2.0 * pi * 70.0 / base))),
        (99, (cos(2.0 * pi * 99.0 / base), sin(2.0 * pi * 99.0 / base)))]

    for time_shift, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_time_shift(time_shift)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEmbedVelocity(self):
    # The following are true only for semitone_steps = 1.
    base = self._num_velocity_bins  # 16
    expected_pairs = [
        (0, (cos(0.0), sin(0.0))),
        (2, (cos(2.0 * pi * 2.0 / base), sin(2.0 * pi * 2.0 / base))),
        (5, (cos(2.0 * pi * 5.0 / base), sin(2.0 * pi * 5.0 / base))),
        (7, (cos(2.0 * pi * 7.0 / base), sin(2.0 * pi * 7.0 / base))),
        (10, (cos(2.0 * pi * 10.0 / base), sin(2.0 * pi * 10.0 / base))),
        (13, (cos(2.0 * pi * 13.0 / base), sin(2.0 * pi * 13.0 / base))),
        (15, (cos(2.0 * pi * 15.0 / base), sin(2.0 * pi * 15.0 / base)))]

    for velocity, expected_embedding in expected_pairs:
      actual_embedding = self.enc.embed_velocity(velocity)
      self.assertEqual(actual_embedding[0], expected_embedding[0])
      self.assertEqual(actual_embedding[1], expected_embedding[1])

  def testEncodeModuloEvent(self):
    expected_pairs = [
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60),
         (0, PerformanceEvent.NOTE_ON, 60)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=0),
         (0, PerformanceEvent.NOTE_ON, 0)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=127),
         (0, PerformanceEvent.NOTE_ON, 127)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=72),
         (5, PerformanceEvent.NOTE_OFF, 72)),
        (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=0),
         (5, PerformanceEvent.NOTE_OFF, 0)),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=127),
         (5, PerformanceEvent.NOTE_OFF, 127)),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=10),
         (10, PerformanceEvent.TIME_SHIFT, 9)),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1),
         (10, PerformanceEvent.TIME_SHIFT, 0)),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100),
         (10, PerformanceEvent.TIME_SHIFT, 99)),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=5),
         (13, PerformanceEvent.VELOCITY, 4)),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=1),
         (13, PerformanceEvent.VELOCITY, 0)),
        (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=16),
         (13, PerformanceEvent.VELOCITY, 15)),
    ]

    # expected_encoded_modulo_event is of the following form:
    # (offset, encoder_width, event_type, value, bins)
    for event, expected_encoded_modulo_event in expected_pairs:
      actual_encoded_modulo_event = self.enc.encode_modulo_event(event)
      self.assertEqual(actual_encoded_modulo_event,
                       expected_encoded_modulo_event)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  self._num_velocity_bins = 16
  self._max_shift_steps = performance_lib.DEFAULT_MAX_SHIFT_STEPS
  self.enc = PerformanceModuloEncoding(
      num_velocity_bins=self._num_velocity_bins,
      max_shift_steps=self._max_shift_steps)

  self._expected_input_size = (
      2 * performance_encoder_decoder.MODULO_PITCH_ENCODER_WIDTH +
      performance_encoder_decoder.MODULO_VELOCITY_ENCODER_WIDTH +
      performance_encoder_decoder.MODULO_TIME_SHIFT_ENCODER_WIDTH)

  self._expected_num_classes = (self._num_velocity_bins +
                                self._max_shift_steps +
                                (performance_lib.MAX_MIDI_PITCH -
                                 performance_lib.MIN_MIDI_PITCH + 1) * 2)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedNote"><code class="name flex">
<span>def <span class="ident">testEmbedNote</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEmbedNote(self):
  # The following are true only for semitone_steps = 1.
  base = 72.0
  expected_pairs = [
      (0, (cos(0.0), sin(0.0))),
      (13, (cos(pi * 13.0 / base), sin(pi * 13.0 / base))),
      (26, (cos(pi * 26.0 / base), sin(pi * 26.0 / base))),
      (39, (cos(pi * 39.0 / base), sin(pi * 39.0 / base))),
      (52, (cos(pi * 52.0 / base), sin(pi * 52.0 / base))),
      (65, (cos(pi * 65.0 / base), sin(pi * 65.0 / base))),
      (78, (cos(pi * 78.0 / base), sin(pi * 78.0 / base))),
      (91, (cos(pi * 91.0 / base), sin(pi * 91.0 / base))),
      (104, (cos(pi * 104.0 / base), sin(pi * 104.0 / base))),
      (117, (cos(pi * 117.0 / base), sin(pi * 117.0 / base))),
      (130, (cos(pi * 130.0 / base), sin(pi * 130.0 / base))),
      (143, (cos(pi * 143.0 / base), sin(pi * 143.0 / base)))]

  for note, expected_embedding in expected_pairs:
    actual_embedding = self.enc.embed_note(note)
    self.assertEqual(actual_embedding[0], expected_embedding[0])
    self.assertEqual(actual_embedding[1], expected_embedding[1])</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedPitchClass"><code class="name flex">
<span>def <span class="ident">testEmbedPitchClass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEmbedPitchClass(self):
  # The following are true only for semitone_steps = 1.
  expected_pairs = [
      (0, (cos(0.0), sin(0.0))),
      (1, (cos(pi / 6.0), sin(pi / 6.0))),
      (2, (cos(pi / 3.0), sin(pi / 3.0))),
      (3, (cos(pi / 2.0), sin(pi / 2.0))),
      (4, (cos(2.0 * pi / 3.0), sin(2.0 * pi / 3.0))),
      (5, (cos(5.0 * pi / 6.0), sin(5.0 * pi / 6.0))),
      (6, (cos(pi), sin(pi))),
      (7, (cos(7.0 * pi / 6.0), sin(7.0 * pi / 6.0))),
      (8, (cos(4.0 * pi / 3.0), sin(4.0 * pi / 3.0))),
      (9, (cos(3.0 * pi / 2.0), sin(3.0 * pi / 2.0))),
      (10, (cos(5.0 * pi / 3.0), sin(5.0 * pi / 3.0))),
      (11, (cos(11.0 * pi / 6.0), sin(11.0 * pi / 6.0)))]

  for note, expected_embedding in expected_pairs:
    actual_embedding = self.enc.embed_pitch_class(note)
    self.assertEqual(actual_embedding[0], expected_embedding[0])
    self.assertEqual(actual_embedding[1], expected_embedding[1])</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedTimeShift"><code class="name flex">
<span>def <span class="ident">testEmbedTimeShift</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEmbedTimeShift(self):
  # The following are true only for semitone_steps = 1.
  base = self._max_shift_steps  # 100
  expected_pairs = [
      (0, (cos(0.0), sin(0.0))),
      (2, (cos(2.0 * pi * 2.0 / base), sin(2.0 * pi * 2.0 / base))),
      (5, (cos(2.0 * pi * 5.0 / base), sin(2.0 * pi * 5.0 / base))),
      (13, (cos(2.0 * pi * 13.0 / base), sin(2.0 * pi * 13.0 / base))),
      (20, (cos(2.0 * pi * 20.0 / base), sin(2.0 * pi * 20.0 / base))),
      (45, (cos(2.0 * pi * 45.0 / base), sin(2.0 * pi * 45.0 / base))),
      (70, (cos(2.0 * pi * 70.0 / base), sin(2.0 * pi * 70.0 / base))),
      (99, (cos(2.0 * pi * 99.0 / base), sin(2.0 * pi * 99.0 / base)))]

  for time_shift, expected_embedding in expected_pairs:
    actual_embedding = self.enc.embed_time_shift(time_shift)
    self.assertEqual(actual_embedding[0], expected_embedding[0])
    self.assertEqual(actual_embedding[1], expected_embedding[1])</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedVelocity"><code class="name flex">
<span>def <span class="ident">testEmbedVelocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEmbedVelocity(self):
  # The following are true only for semitone_steps = 1.
  base = self._num_velocity_bins  # 16
  expected_pairs = [
      (0, (cos(0.0), sin(0.0))),
      (2, (cos(2.0 * pi * 2.0 / base), sin(2.0 * pi * 2.0 / base))),
      (5, (cos(2.0 * pi * 5.0 / base), sin(2.0 * pi * 5.0 / base))),
      (7, (cos(2.0 * pi * 7.0 / base), sin(2.0 * pi * 7.0 / base))),
      (10, (cos(2.0 * pi * 10.0 / base), sin(2.0 * pi * 10.0 / base))),
      (13, (cos(2.0 * pi * 13.0 / base), sin(2.0 * pi * 13.0 / base))),
      (15, (cos(2.0 * pi * 15.0 / base), sin(2.0 * pi * 15.0 / base)))]

  for velocity, expected_embedding in expected_pairs:
    actual_embedding = self.enc.embed_velocity(velocity)
    self.assertEqual(actual_embedding[0], expected_embedding[0])
    self.assertEqual(actual_embedding[1], expected_embedding[1])</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEncodeModuloEvent"><code class="name flex">
<span>def <span class="ident">testEncodeModuloEvent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEncodeModuloEvent(self):
  expected_pairs = [
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60),
       (0, PerformanceEvent.NOTE_ON, 60)),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=0),
       (0, PerformanceEvent.NOTE_ON, 0)),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=127),
       (0, PerformanceEvent.NOTE_ON, 127)),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=72),
       (5, PerformanceEvent.NOTE_OFF, 72)),
      (PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=0),
       (5, PerformanceEvent.NOTE_OFF, 0)),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_OFF, event_value=127),
       (5, PerformanceEvent.NOTE_OFF, 127)),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=10),
       (10, PerformanceEvent.TIME_SHIFT, 9)),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=1),
       (10, PerformanceEvent.TIME_SHIFT, 0)),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=100),
       (10, PerformanceEvent.TIME_SHIFT, 99)),
      (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=5),
       (13, PerformanceEvent.VELOCITY, 4)),
      (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=1),
       (13, PerformanceEvent.VELOCITY, 0)),
      (PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=16),
       (13, PerformanceEvent.VELOCITY, 15)),
  ]

  # expected_encoded_modulo_event is of the following form:
  # (offset, encoder_width, event_type, value, bins)
  for event, expected_encoded_modulo_event in expected_pairs:
    actual_encoded_modulo_event = self.enc.encode_modulo_event(event)
    self.assertEqual(actual_encoded_modulo_event,
                     expected_encoded_modulo_event)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testInputSize"><code class="name flex">
<span>def <span class="ident">testInputSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInputSize(self):
  self.assertEqual(self._expected_input_size, self.enc.input_size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest"><code class="flex name class">
<span>class <span class="ident">PerformanceOneHotEncodingTest</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of unittest.TestCase providing more power.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerformanceOneHotEncodingTest(absltest.TestCase):

  def setUp(self):
    self.enc = performance_encoder_decoder.PerformanceOneHotEncoding(
        num_velocity_bins=16)

  def testEncodeDecode(self):
    expected_pairs = [
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_ON, event_value=60), 60),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_ON, event_value=0), 0),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_ON, event_value=127), 127),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=72), 200),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=0), 128),
        (PerformanceEvent(
            event_type=PerformanceEvent.NOTE_OFF, event_value=127), 255),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=10), 265),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1), 256),
        (PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100), 355),
        (PerformanceEvent(
            event_type=PerformanceEvent.VELOCITY, event_value=5), 360),
        (PerformanceEvent(
            event_type=PerformanceEvent.VELOCITY, event_value=1), 356),
        (PerformanceEvent(
            event_type=PerformanceEvent.VELOCITY, event_value=16), 371)
    ]

    for expected_event, expected_index in expected_pairs:
      index = self.enc.encode_event(expected_event)
      self.assertEqual(expected_index, index)
      event = self.enc.decode_event(expected_index)
      self.assertEqual(expected_event, event)

  def testEventToNumSteps(self):
    self.assertEqual(0, self.enc.event_to_num_steps(
        PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60)))
    self.assertEqual(0, self.enc.event_to_num_steps(
        PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=67)))
    self.assertEqual(0, self.enc.event_to_num_steps(
        PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=10)))

    self.assertEqual(1, self.enc.event_to_num_steps(
        PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=1)))
    self.assertEqual(45, self.enc.event_to_num_steps(
        PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=45)))
    self.assertEqual(100, self.enc.event_to_num_steps(
        PerformanceEvent(
            event_type=PerformanceEvent.TIME_SHIFT, event_value=100)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>absl.testing.absltest.TestCase</li>
<li>absl.third_party.unittest3_backport.case.TestCase</li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  self.enc = performance_encoder_decoder.PerformanceOneHotEncoding(
      num_velocity_bins=16)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.testEncodeDecode"><code class="name flex">
<span>def <span class="ident">testEncodeDecode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEncodeDecode(self):
  expected_pairs = [
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_ON, event_value=60), 60),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_ON, event_value=0), 0),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_ON, event_value=127), 127),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_OFF, event_value=72), 200),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_OFF, event_value=0), 128),
      (PerformanceEvent(
          event_type=PerformanceEvent.NOTE_OFF, event_value=127), 255),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=10), 265),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=1), 256),
      (PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=100), 355),
      (PerformanceEvent(
          event_type=PerformanceEvent.VELOCITY, event_value=5), 360),
      (PerformanceEvent(
          event_type=PerformanceEvent.VELOCITY, event_value=1), 356),
      (PerformanceEvent(
          event_type=PerformanceEvent.VELOCITY, event_value=16), 371)
  ]

  for expected_event, expected_index in expected_pairs:
    index = self.enc.encode_event(expected_event)
    self.assertEqual(expected_index, index)
    event = self.enc.decode_event(expected_index)
    self.assertEqual(expected_event, event)</code></pre>
</details>
</dd>
<dt id="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.testEventToNumSteps"><code class="name flex">
<span>def <span class="ident">testEventToNumSteps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEventToNumSteps(self):
  self.assertEqual(0, self.enc.event_to_num_steps(
      PerformanceEvent(event_type=PerformanceEvent.NOTE_ON, event_value=60)))
  self.assertEqual(0, self.enc.event_to_num_steps(
      PerformanceEvent(event_type=PerformanceEvent.NOTE_OFF, event_value=67)))
  self.assertEqual(0, self.enc.event_to_num_steps(
      PerformanceEvent(event_type=PerformanceEvent.VELOCITY, event_value=10)))

  self.assertEqual(1, self.enc.event_to_num_steps(
      PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=1)))
  self.assertEqual(45, self.enc.event_to_num_steps(
      PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=45)))
  self.assertEqual(100, self.enc.event_to_num_steps(
      PerformanceEvent(
          event_type=PerformanceEvent.TIME_SHIFT, event_value=100)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="note_seq" href="index.html">note_seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest" href="#note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest">ModuloPerformanceEventSequenceEncoderTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.setUp" href="#note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.setUp">setUp</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testDefaultEventLabel" href="#note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testDefaultEventLabel">testDefaultEventLabel</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testEventsToInput" href="#note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testEventsToInput">testEventsToInput</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testInputSize" href="#note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testInputSize">testInputSize</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testNumClasses" href="#note_seq.performance_encoder_decoder_test.ModuloPerformanceEventSequenceEncoderTest.testNumClasses">testNumClasses</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest" href="#note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest">NotePerformanceEventSequenceEncoderDecoderTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest.setUp" href="#note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest.setUp">setUp</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest.testEncodeDecode" href="#note_seq.performance_encoder_decoder_test.NotePerformanceEventSequenceEncoderDecoderTest.testEncodeDecode">testEncodeDecode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest">PerformanceModuloEncodingTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.setUp" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.setUp">setUp</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedNote" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedNote">testEmbedNote</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedPitchClass" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedPitchClass">testEmbedPitchClass</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedTimeShift" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedTimeShift">testEmbedTimeShift</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedVelocity" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEmbedVelocity">testEmbedVelocity</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEncodeModuloEvent" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testEncodeModuloEvent">testEncodeModuloEvent</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testInputSize" href="#note_seq.performance_encoder_decoder_test.PerformanceModuloEncodingTest.testInputSize">testInputSize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest" href="#note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest">PerformanceOneHotEncodingTest</a></code></h4>
<ul class="">
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.setUp" href="#note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.setUp">setUp</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.testEncodeDecode" href="#note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.testEncodeDecode">testEncodeDecode</a></code></li>
<li><code><a title="note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.testEventToNumSteps" href="#note_seq.performance_encoder_decoder_test.PerformanceOneHotEncodingTest.testEventToNumSteps">testEventToNumSteps</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>